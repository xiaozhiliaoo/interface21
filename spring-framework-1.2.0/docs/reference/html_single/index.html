<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring - Java/J2EE Application Framework</title><link rel="stylesheet" href="../styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Spring - Java/J2EE Application Framework</h1></div><div><h2 class="subtitle">
          Reference Documentation
        </h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Rod</span> <span class="surname">Johnson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Juergen</span> <span class="surname">Hoeller</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Alef</span> <span class="surname">Arendsen</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Colin</span> <span class="surname">Sampaleanu</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Darren</span> <span class="surname">Davison</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dmitriy</span> <span class="surname">Kopylenko</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Thomas</span> <span class="surname">Risberg</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Pollack</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Rob</span> <span class="surname">Harrop</span></h3></div></div></div><div><p class="releaseinfo">Version 1.2</p></div><div><div class="legalnotice">Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</div></div><div><p class="pubdate">(Work in progress)</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#preface">Preface</a></dt><dt>1. <a href="#introduction">Introduction</a></dt><dd><dl><dt>1.1. <a href="#introduction-overview">Overview</a></dt><dt>1.2. <a href="#overview-usagescenarios">Usage scenarios</a></dt></dl></dd><dt>2. <a href="#background">Background information</a></dt><dd><dl><dt>2.1. <a href="#background-ioc">Inversion of Control / Dependency Injection</a></dt></dl></dd><dt>3. <a href="#beans">Beans, BeanFactory and the ApplicationContext</a></dt><dd><dl><dt>3.1. <a href="#beans-introduction">Introduction</a></dt><dt>3.2. <a href="#beans-basics">BeanFactory and BeanDefinitions - the basics</a></dt><dd><dl><dt>3.2.1. <a href="#beans-factory">The BeanFactory</a></dt><dt>3.2.2. <a href="#beans-definition">The BeanDefinition</a></dt><dt>3.2.3. <a href="#beans-factory-class">The bean class</a></dt><dd><dl><dt>3.2.3.1. <a href="#d0e455">Bean creation via constructor</a></dt><dt>3.2.3.2. <a href="#d0e471">Bean creation via static factory method</a></dt><dt>3.2.3.3. <a href="#beans-instance-factory-method">Bean creation via instance factory method</a></dt></dl></dd><dt>3.2.4. <a href="#beans-beanname">The bean identifiers (id and
      name)</a></dt><dt>3.2.5. <a href="#beans-factory-modes">To singleton or not to singleton</a></dt></dl></dd><dt>3.3. <a href="#beans-dependencies">Properties, collaborators, autowiring and dependency
    checking</a></dt><dd><dl><dt>3.3.1. <a href="#beans-factory-collaborators">Setting bean properties and collaborators</a></dt><dt>3.3.2. <a href="#d0e722">Constructor Argument Resolution</a></dt><dd><dl><dt>3.3.2.1. <a href="#d0e732">Constructor Argument Type Matching</a></dt><dt>3.3.2.2. <a href="#d0e745">Constructor Argument Index</a></dt></dl></dd><dt>3.3.3. <a href="#beans-factory-properties-detailed">Bean properties and constructor arguments detailed</a></dt><dt>3.3.4. <a href="#beans-factory-method-injection">Method Injection</a></dt><dd><dl><dt>3.3.4.1. <a href="#d0e957">Lookup method Injection</a></dt><dt>3.3.4.2. <a href="#d0e993">Arbitrary method replacement</a></dt></dl></dd><dt>3.3.5. <a href="#beans-factory-dependson">Using depends-on</a></dt><dt>3.3.6. <a href="#beans-factory-autowire">Autowiring collaborators</a></dt><dt>3.3.7. <a href="#beans-factory-dependencies">Checking for dependencies</a></dt></dl></dd><dt>3.4. <a href="#beans-factory-nature">Customizing the nature of a bean</a></dt><dd><dl><dt>3.4.1. <a href="#beans-factory-lifecycle">Lifecycle interfaces</a></dt><dd><dl><dt>3.4.1.1. <a href="#beans-factory-lifecycle-initializingbean">InitializingBean / init-method</a></dt><dt>3.4.1.2. <a href="#beans-factory-lifecycle-disposablebean">DisposableBean / destroy-method</a></dt></dl></dd><dt>3.4.2. <a href="#beans-factory-aware">Knowing who you are</a></dt><dd><dl><dt>3.4.2.1. <a href="#beans-factory-aware-beanfactoryaware">BeanFactoryAware</a></dt><dt>3.4.2.2. <a href="#beans-factory-aware-beannameaware">BeanNameAware</a></dt></dl></dd><dt>3.4.3. <a href="#beans-factory-lifecycle-factorybean">FactoryBean</a></dt></dl></dd><dt>3.5. <a href="#beans-child-bean-definitions">Abstract and child bean definitions</a></dt><dt>3.6. <a href="#beans-factory-client">Interacting with the BeanFactory</a></dt><dd><dl><dt>3.6.1. <a href="#d0e1500">Obtaining a FactoryBean, not its product</a></dt></dl></dd><dt>3.7. <a href="#beans-factory-customizing">Customizing beans with BeanPostprocessors</a></dt><dt>3.8. <a href="#beans-factory-customizing-factory-postprocessors">Customizing bean factories with BeanFactoryPostprocessors</a></dt><dd><dl><dt>3.8.1. <a href="#beans-factory-placeholderconfigurer">The PropertyPlaceholderConfigurer</a></dt><dt>3.8.2. <a href="#beans-factory-overrideconfigurer">The PropertyOverrideConfigurer</a></dt></dl></dd><dt>3.9. <a href="#beans-beanfactory-customeditors">Registering additional custom PropertyEditors</a></dt><dt>3.10. <a href="#beans-beanfactory-alias">Using the alias element to add aliases for existing beans</a></dt><dt>3.11. <a href="#context-introduction">Introduction to the ApplicationContext</a></dt><dt>3.12. <a href="#context-functionality">Added functionality of the
    ApplicationContext</a></dt><dd><dl><dt>3.12.1. <a href="#context-functionality-messagesource">Using the MessageSource</a></dt><dt>3.12.2. <a href="#context-functionality-events">Propagating events</a></dt><dt>3.12.3. <a href="#context-functionality-resources">Using resources within Spring</a></dt></dl></dd><dt>3.13. <a href="#beans-context-customization">Customized behavior in the ApplicationContext</a></dt><dd><dl><dt>3.13.1. <a href="#beans-context-applicationcontextaware">ApplicationContextAware marker
      interface</a></dt><dt>3.13.2. <a href="#beans-context-beanpostprocessor">The BeanPostProcessor</a></dt><dt>3.13.3. <a href="#beans-context-beanfactorypostprocessor">The BeanFactoryPostProcessor</a></dt><dt>3.13.4. <a href="#beans-context-placeholderconfigurer">The PropertyPlaceholderConfigurer</a></dt></dl></dd><dt>3.14. <a href="#beans-applicationcontext-customeditors">Registering additional custom PropertyEditors</a></dt><dt>3.15. <a href="#d0e2083">Setting a bean property or constructor arg from a property
    expression</a></dt><dt>3.16. <a href="#d0e2111">Setting a bean property or constructor arg from a field
    value</a></dt><dt>3.17. <a href="#d0e2131">Invoking another method and optionally using the return
    value.</a></dt><dt>3.18. <a href="#context-import">Importing Bean Definitions from One File Into Another</a></dt><dt>3.19. <a href="#context-create">Creating an ApplicationContext from a web application</a></dt><dt>3.20. <a href="#d0e2287">Glue code and the evil singleton</a></dt><dd><dl><dt>3.20.1. <a href="#d0e2305">Using SingletonBeanFactoryLocator and
      ContextSingletonBeanFactoryLocator</a></dt></dl></dd></dl></dd><dt>4. <a href="#validation">PropertyEditors, data binding, validation and the BeanWrapper</a></dt><dd><dl><dt>4.1. <a href="#validation-introduction">Introduction</a></dt><dt>4.2. <a href="#validation-databinding">Binding data using the DataBinder</a></dt><dt>4.3. <a href="#beans-beans">Bean manipulation and the BeanWrapper</a></dt><dd><dl><dt>4.3.1. <a href="#beans-beans-conventions">Setting and getting basic and nested properties</a></dt><dt>4.3.2. <a href="#beans-beans-conversion">Built-in PropertyEditors, converting
      types</a></dt><dt>4.3.3. <a href="#beans-beans-other">Other features worth mentioning</a></dt></dl></dd></dl></dd><dt>5. <a href="#aop">Spring AOP: Aspect Oriented Programming with Spring</a></dt><dd><dl><dt>5.1. <a href="#aop-introduction">Concepts</a></dt><dd><dl><dt>5.1.1. <a href="#aop-introduction-defn">AOP concepts</a></dt><dt>5.1.2. <a href="#aop-introduction-spring-defn">Spring AOP capabilities and goals</a></dt><dt>5.1.3. <a href="#aop-introduction-proxies">AOP Proxies in Spring</a></dt></dl></dd><dt>5.2. <a href="#aop-introduction-pointcuts">Pointcuts in Spring</a></dt><dd><dl><dt>5.2.1. <a href="#d0e2947">Concepts</a></dt><dt>5.2.2. <a href="#d0e2996">Operations on pointcuts</a></dt><dt>5.2.3. <a href="#d0e3021">Convenience pointcut implementations</a></dt><dd><dl><dt>5.2.3.1. <a href="#d0e3026">Static pointcuts</a></dt><dt>5.2.3.2. <a href="#d0e3073">Dynamic pointcuts</a></dt></dl></dd><dt>5.2.4. <a href="#d0e3106">Pointcut superclasses</a></dt><dt>5.2.5. <a href="#d0e3119">Custom pointcuts</a></dt></dl></dd><dt>5.3. <a href="#d0e3126">Advice types in Spring</a></dt><dd><dl><dt>5.3.1. <a href="#d0e3131">Advice lifecycles</a></dt><dt>5.3.2. <a href="#aop-introduction-advice-types">Advice types in Spring</a></dt><dd><dl><dt>5.3.2.1. <a href="#d0e3153">Interception around advice</a></dt><dt>5.3.2.2. <a href="#d0e3190">Before advice</a></dt><dt>5.3.2.3. <a href="#d0e3224">Throws advice</a></dt><dt>5.3.2.4. <a href="#d0e3264">After Returning advice</a></dt><dt>5.3.2.5. <a href="#d0e3284">Introduction advice</a></dt></dl></dd></dl></dd><dt>5.4. <a href="#d0e3437">Advisors in Spring</a></dt><dt>5.5. <a href="#aop-pfb">Using the ProxyFactoryBean to create AOP proxies</a></dt><dd><dl><dt>5.5.1. <a href="#aop-pfb-1">Basics</a></dt><dt>5.5.2. <a href="#aop-pfb-2">JavaBean properties</a></dt><dt>5.5.3. <a href="#d0e3586">Proxying interfaces</a></dt><dt>5.5.4. <a href="#d0e3653">Proxying classes</a></dt><dt>5.5.5. <a href="#d0e3689">Using 'global' advisors</a></dt></dl></dd><dt>5.6. <a href="#aop-tfb">Convenient proxy creation</a></dt><dd><dl><dt>5.6.1. <a href="#d0e3707">TransactionProxyFactoryBean</a></dt><dt>5.6.2. <a href="#d0e3788">EJB proxies</a></dt></dl></dd><dt>5.7. <a href="#aop-concise-proxy">Concise proxy definitions</a></dt><dt>5.8. <a href="#aop-prog">Creating AOP proxies programmatically with the ProxyFactory</a></dt><dt>5.9. <a href="#d0e3854">Manipulating advised objects</a></dt><dt>5.10. <a href="#aop-autoproxy">Using the "autoproxy" facility</a></dt><dd><dl><dt>5.10.1. <a href="#aop-autoproxy-choices">Autoproxy bean definitions</a></dt><dd><dl><dt>5.10.1.1. <a href="#d0e3944">BeanNameAutoProxyCreator</a></dt><dt>5.10.1.2. <a href="#d0e3967">DefaultAdvisorAutoProxyCreator</a></dt><dt>5.10.1.3. <a href="#d0e4015">AbstractAdvisorAutoProxyCreator</a></dt></dl></dd><dt>5.10.2. <a href="#aop-autoproxy-metadata">Using metadata-driven auto-proxying</a></dt></dl></dd><dt>5.11. <a href="#aop-targetsource">Using TargetSources</a></dt><dd><dl><dt>5.11.1. <a href="#aop-ts-swap">Hot swappable target sources</a></dt><dt>5.11.2. <a href="#aop-ts-pool">Pooling target sources</a></dt><dt>5.11.3. <a href="#aop-ts-prototype">Prototype target sources</a></dt><dt>5.11.4. <a href="#aop-ts-threadlocal">ThreadLocal target sources</a></dt></dl></dd><dt>5.12. <a href="#aop-extensibility">Defining new Advice types</a></dt><dt>5.13. <a href="#d0e4279">Further reading and resources</a></dt><dt>5.14. <a href="#d0e4301">Roadmap</a></dt></dl></dd><dt>6. <a href="#d0e4328">AspectJ Integration</a></dt><dd><dl><dt>6.1. <a href="#d0e4331">Overview</a></dt><dt>6.2. <a href="#d0e4338">Configuring AspectJ aspects using Spring IoC</a></dt><dd><dl><dt>6.2.1. <a href="#d0e4360">"Singleton" aspects</a></dt><dd><dl><dt>6.2.1.1. <a href="#d0e4370">Example</a></dt><dt>6.2.1.2. <a href="#d0e4408">Ordering issues</a></dt></dl></dd><dt>6.2.2. <a href="#d0e4413">Non-singleton aspects</a></dt><dt>6.2.3. <a href="#d0e4418">Gotchas</a></dt></dl></dd><dt>6.3. <a href="#d0e4425">Using AspectJ pointcuts to target Spring advice</a></dt><dt>6.4. <a href="#d0e4434">Spring aspects for AspectJ</a></dt></dl></dd><dt>7. <a href="#transaction">Transaction management</a></dt><dd><dl><dt>7.1. <a href="#d0e4444">The Spring transaction abstraction</a></dt><dt>7.2. <a href="#d0e4501">Transaction strategies</a></dt><dt>7.3. <a href="#d0e4672">Programmatic transaction management</a></dt><dd><dl><dt>7.3.1. <a href="#d0e4696">Using the TransactionTemplate</a></dt><dt>7.3.2. <a href="#d0e4752">Using the PlatformTransactionManager</a></dt></dl></dd><dt>7.4. <a href="#d0e4771">Declarative transaction management</a></dt><dd><dl><dt>7.4.1. <a href="#d0e4894">BeanNameAutoProxyCreator,
      another declarative approach</a></dt></dl></dd><dt>7.5. <a href="#d0e4988">Choosing between programmatic and declarative transaction
    management</a></dt><dt>7.6. <a href="#d0e4995">Do you need an application server for transaction
    management?</a></dt><dt>7.7. <a href="#d0e5011">Common problems</a></dt></dl></dd><dt>8. <a href="#metadata">Source Level Metadata Support</a></dt><dd><dl><dt>8.1. <a href="#metadata-concepts">Source-level metadata</a></dt><dt>8.2. <a href="#metadata-spring">Spring's metadata support</a></dt><dt>8.3. <a href="#metadata-commons">Integration with Jakarta Commons Attributes</a></dt><dt>8.4. <a href="#metadata-uses">Metadata and Spring AOP autoproxying</a></dt><dd><dl><dt>8.4.1. <a href="#d0e5230">Fundamentals</a></dt><dt>8.4.2. <a href="#metadata-tx">Declarative transaction management</a></dt><dt>8.4.3. <a href="#metadata-pool">Pooling</a></dt><dt>8.4.4. <a href="#metadata-arbitrary">Custom metadata</a></dt></dl></dd><dt>8.5. <a href="#d0e5329">Using attributes to minimize MVC web tier configuration</a></dt><dt>8.6. <a href="#d0e5439">Other uses of metadata attributes</a></dt><dt>8.7. <a href="#d0e5444">Adding support for additional metadata APIs</a></dt></dl></dd><dt>9. <a href="#dao">DAO support</a></dt><dd><dl><dt>9.1. <a href="#dao-introduction">Introduction</a></dt><dt>9.2. <a href="#dao-exceptions">Consistent Exception Hierarchy</a></dt><dt>9.3. <a href="#d0e5494">Consistent Abstract Classes for DAO Support</a></dt></dl></dd><dt>10. <a href="#jdbc">Data Access using JDBC</a></dt><dd><dl><dt>10.1. <a href="#jdbc-introduction">Introduction</a></dt><dt>10.2. <a href="#jdbc-core">Using the JDBC Core classes to control basic JDBC processing and
    error handling</a></dt><dd><dl><dt>10.2.1. <a href="#jdbc-JdbcTemplate">JdbcTemplate</a></dt><dt>10.2.2. <a href="#d0e5596">DataSource</a></dt><dt>10.2.3. <a href="#jdbc-SQLExceptionTranslator">SQLExceptionTranslator</a></dt><dt>10.2.4. <a href="#d0e5687">Executing Statements</a></dt><dt>10.2.5. <a href="#d0e5703">Running Queries</a></dt><dt>10.2.6. <a href="#d0e5745">Updating the database</a></dt></dl></dd><dt>10.3. <a href="#jdbc-datasource">Controlling how we connect to the database</a></dt><dd><dl><dt>10.3.1. <a href="#jdbc-DataSourceUtils">DataSourceUtils</a></dt><dt>10.3.2. <a href="#jdbc-SmartDataSource">SmartDataSource</a></dt><dt>10.3.3. <a href="#jdbc-AbstractDataSource">AbstractDataSource</a></dt><dt>10.3.4. <a href="#jdbc-SingleConnectionDataSource">SingleConnectionDataSource</a></dt><dt>10.3.5. <a href="#jdbc-DriverManagerDataSource">DriverManagerDataSource</a></dt><dt>10.3.6. <a href="#jdbc-DataSourceTransactionManager">DataSourceTransactionManager</a></dt></dl></dd><dt>10.4. <a href="#jdbc-object">Modeling JDBC operations as Java objects</a></dt><dd><dl><dt>10.4.1. <a href="#jdbc-SqlQuery">SqlQuery</a></dt><dt>10.4.2. <a href="#jdbc-MappingSqlQuery">MappingSqlQuery</a></dt><dt>10.4.3. <a href="#jdbc-SqlUpdate">SqlUpdate</a></dt><dt>10.4.4. <a href="#jdbc-StoredProcedure">StoredProcedure</a></dt><dt>10.4.5. <a href="#jdbc-SqlFunction">SqlFunction</a></dt></dl></dd></dl></dd><dt>11. <a href="#orm">Data Access using O/R Mappers</a></dt><dd><dl><dt>11.1. <a href="#orm-introduction">Introduction</a></dt><dt>11.2. <a href="#orm-hibernate">Hibernate</a></dt><dd><dl><dt>11.2.1. <a href="#d0e6074">Resource Management</a></dt><dt>11.2.2. <a href="#d0e6103">Resource Definitions in an Application Context</a></dt><dt>11.2.3. <a href="#d0e6131">Inversion of Control: Template and Callback</a></dt><dt>11.2.4. <a href="#d0e6174">Applying an AOP Interceptor Instead of a Template</a></dt><dt>11.2.5. <a href="#d0e6218">Programmatic Transaction Demarcation</a></dt><dt>11.2.6. <a href="#d0e6240">Declarative Transaction Demarcation</a></dt><dt>11.2.7. <a href="#d0e6277">Transaction Management Strategies</a></dt><dt>11.2.8. <a href="#d0e6329">Container Resources versus Local Resources</a></dt><dt>11.2.9. <a href="#d0e6340">Samples</a></dt></dl></dd><dt>11.3. <a href="#d0e6345">JDO</a></dt><dt>11.4. <a href="#d0e6350">iBATIS</a></dt><dd><dl><dt>11.4.1. <a href="#d0e6358">Overview and differences between 1.3.x and 2.0</a></dt><dt>11.4.2. <a href="#d0e6417">iBATIS 1.3.x</a></dt><dd><dl><dt>11.4.2.1. <a href="#d0e6420">Setting up the SqlMap</a></dt><dt>11.4.2.2. <a href="#d0e6451">Using SqlMapDaoSupport</a></dt><dt>11.4.2.3. <a href="#d0e6472">Transaction management</a></dt></dl></dd><dt>11.4.3. <a href="#d0e6483">iBATIS 2</a></dt><dd><dl><dt>11.4.3.1. <a href="#d0e6486">Setting up the SqlMap</a></dt><dt>11.4.3.2. <a href="#d0e6510">Using SqlMapClientDaoSupport</a></dt></dl></dd></dl></dd></dl></dd><dt>12. <a href="#mvc">Web MVC framework</a></dt><dd><dl><dt>12.1. <a href="#mvc-introduction">Introduction to the web MVC framework</a></dt><dd><dl><dt>12.1.1. <a href="#mvc-introduction-pluggability">Pluggability of other MVC implementations</a></dt><dt>12.1.2. <a href="#mvc-features">Features of Spring MVC</a></dt></dl></dd><dt>12.2. <a href="#mvc-servlet">The DispatcherServlet</a></dt><dt>12.3. <a href="#mvc-controller">Controllers</a></dt><dd><dl><dt>12.3.1. <a href="#mvc-controller-abstractcontroller">AbstractController and WebContentGenerator</a></dt><dt>12.3.2. <a href="#mvc-controller-othersimplecontrollers">Other simple controllers</a></dt><dt>12.3.3. <a href="#mvc-controller-multiaction">The MultiActionController</a></dt><dt>12.3.4. <a href="#mvc-controller-command">CommandControllers</a></dt></dl></dd><dt>12.4. <a href="#mvc-handlermapping">Handler mappings</a></dt><dd><dl><dt>12.4.1. <a href="#mvc-handlermapping-beanname">BeanNameUrlHandlerMapping</a></dt><dt>12.4.2. <a href="#mvc-handlermapping-urlhandlermapping">SimpleUrlHandlerMapping</a></dt><dt>12.4.3. <a href="#mvc-handlermapping-interceptor">Adding HandlerInterceptors</a></dt></dl></dd><dt>12.5. <a href="#mvc-viewresolver">Views and resolving them</a></dt><dd><dl><dt>12.5.1. <a href="#mvc-viewresolver-resolver">ViewResolvers</a></dt><dt>12.5.2. <a href="#mvc-viewresolver-chaining">Chaining ViewResolvers</a></dt></dl></dd><dt>12.6. <a href="#mvc-localeresolver">Using locales</a></dt><dd><dl><dt>12.6.1. <a href="#mvc-localeresolver-acceptheader">AcceptHeaderLocaleResolver</a></dt><dt>12.6.2. <a href="#mvc-localeresolver-cookie">CookieLocaleResolver</a></dt><dt>12.6.3. <a href="#mvc-localeresolver-session">SessionLocaleResolver</a></dt><dt>12.6.4. <a href="#mvc-localeresolver-interceptor">LocaleChangeInterceptor</a></dt></dl></dd><dt>12.7. <a href="#mvc-themeresolver">Using themes</a></dt><dt>12.8. <a href="#mvc-multipart">Spring's multipart (fileupload) support</a></dt><dd><dl><dt>12.8.1. <a href="#mvc-multipart-introduction">Introduction</a></dt><dt>12.8.2. <a href="#mvc-multipart-resolver">Using the MultipartResolver</a></dt><dt>12.8.3. <a href="#mvc-multipart-forms">Handling a fileupload in a form</a></dt></dl></dd><dt>12.9. <a href="#mvc-exceptionhandlers">Handling exceptions</a></dt></dl></dd><dt>13. <a href="#view">Integrating view technologies</a></dt><dd><dl><dt>13.1. <a href="#view-introduction">Introduction</a></dt><dt>13.2. <a href="#view-jsp">JSP &amp; JSTL</a></dt><dd><dl><dt>13.2.1. <a href="#view-jsp-resolver">View resolvers</a></dt><dt>13.2.2. <a href="#view-jsp-jstl">'Plain-old' JSPs versus JSTL</a></dt><dt>13.2.3. <a href="#view-jsp-tags">Additional tags facilitating development</a></dt></dl></dd><dt>13.3. <a href="#view-tiles">Tiles</a></dt><dd><dl><dt>13.3.1. <a href="#view-tiles-dependencies">Dependencies</a></dt><dt>13.3.2. <a href="#view-tiles-integrate">How to integrate Tiles</a></dt><dd><dl><dt>13.3.2.1. <a href="#view-tiles-internal">InternalResourceViewResolver</a></dt><dt>13.3.2.2. <a href="#view-tiles-resource">ResourceBundleViewResolver</a></dt></dl></dd></dl></dd><dt>13.4. <a href="#view-velocity">Velocity &amp; FreeMarker</a></dt><dd><dl><dt>13.4.1. <a href="#view-velocity-dependencies">Dependencies</a></dt><dt>13.4.2. <a href="#view-velocity-contextconfig">Context configuration</a></dt><dt>13.4.3. <a href="#view-velocity-createtemplates">Creating templates</a></dt><dt>13.4.4. <a href="#view-velocity-advancedconfig">Advanced configuration</a></dt><dd><dl><dt>13.4.4.1. <a href="#view-velocity-example-velocityproperties">velocity.properties</a></dt><dt>13.4.4.2. <a href="#d0e8065">FreeMarker</a></dt></dl></dd><dt>13.4.5. <a href="#view-velocity-forms">Bind support and form handling</a></dt><dd><dl><dt>13.4.5.1. <a href="#view-velocity-validation">the bind macros</a></dt><dt>13.4.5.2. <a href="#view-velocity-validationmessages">simple binding</a></dt><dt>13.4.5.3. <a href="#d0e8180">form input generation macros</a></dt><dt>13.4.5.4. <a href="#d0e8438">overriding HTML escaping and making tags XHTML
        compliant</a></dt></dl></dd></dl></dd><dt>13.5. <a href="#view-xslt">XSLT</a></dt><dd><dl><dt>13.5.1. <a href="#view-xslt-firstwords">My First Words</a></dt><dd><dl><dt>13.5.1.1. <a href="#view-xslt-beandefs">Bean definitions</a></dt><dt>13.5.1.2. <a href="#view-xslt-controllercode">Standard MVC controller code</a></dt><dt>13.5.1.3. <a href="#view-xslt-subclassing">Convert the model data to XML</a></dt><dt>13.5.1.4. <a href="#view-xslt-viewdefinitions">Defining the view properties</a></dt><dt>13.5.1.5. <a href="#view-xslt-transforming">Document transformation</a></dt></dl></dd><dt>13.5.2. <a href="#view-xslt-summary">Summary</a></dt></dl></dd><dt>13.6. <a href="#view-document">Document views (PDF/Excel)</a></dt><dd><dl><dt>13.6.1. <a href="#view-document-intro">Introduction</a></dt><dt>13.6.2. <a href="#view-document-config">Configuration and setup</a></dt><dd><dl><dt>13.6.2.1. <a href="#view-document-configviews">Document view definitions</a></dt><dt>13.6.2.2. <a href="#view-document-configcontroller">Controller code</a></dt><dt>13.6.2.3. <a href="#view-document-configsubclasses">Subclassing for Excel views</a></dt><dt>13.6.2.4. <a href="#view-document-configsubclasspdf">Subclassing for PDF views</a></dt></dl></dd></dl></dd><dt>13.7. <a href="#view-jasper-reports">JasperReports</a></dt><dd><dl><dt>13.7.1. <a href="#view-jasper-reports-dependencies">Dependencies</a></dt><dt>13.7.2. <a href="#view-jasper-reports-configuration">Configuration</a></dt><dd><dl><dt>13.7.2.1. <a href="#view-jasper-reports-configuration-resolver">Configuring the ViewResolver</a></dt><dt>13.7.2.2. <a href="#view-jasper-reports-configuration-views">Configuring the Views</a></dt><dt>13.7.2.3. <a href="#view-jasper-reports-configuration-report-files">About Report Files</a></dt><dt>13.7.2.4. <a href="#view-jasper-reports-configuration-multiformat-view">Using JasperReportsMultiFormatView</a></dt></dl></dd><dt>13.7.3. <a href="#view-jasper-reports-model">Populating the ModelAndView</a></dt><dt>13.7.4. <a href="#view-jasper-reports-subreports">Working with Sub-Reports</a></dt><dd><dl><dt>13.7.4.1. <a href="#view-jasper-reports-subreports-config-reports">Configuring Sub-Report Files</a></dt><dt>13.7.4.2. <a href="#view-jasper-reports-subreports-config-datasources">Configuring Sub-Report Data Sources</a></dt></dl></dd><dt>13.7.5. <a href="#view-jasper-reports-exporter-parameters">Configuring Exporter Parameters</a></dt></dl></dd></dl></dd><dt>14. <a href="#webintegration">Integrating with other web frameworks</a></dt><dd><dl><dt>14.1. <a href="#intro">Introduction</a></dt><dt>14.2. <a href="#jsf">JavaServer Faces</a></dt><dd><dl><dt>14.2.1. <a href="#jsf-delegatingvariableresolver">DelegatingVariableResolver</a></dt><dt>14.2.2. <a href="#jsf-facescontextutils">FacesContextUtils</a></dt></dl></dd><dt>14.3. <a href="#struts">Struts</a></dt><dd><dl><dt>14.3.1. <a href="#struts-contextloaderplugin">ContextLoaderPlugin</a></dt><dd><dl><dt>14.3.1.1. <a href="#struts-delegatingrequestprocessor">DelegatingRequestProcessor</a></dt><dt>14.3.1.2. <a href="#struts-delegatingactionproxy">DelegatingActionProxy</a></dt></dl></dd><dt>14.3.2. <a href="#struts-actionsupport">ActionSupport Classes</a></dt></dl></dd><dt>14.4. <a href="#view-tapestry">Tapestry</a></dt><dd><dl><dt>14.4.1. <a href="#view-tapestry-architecture">Architecture</a></dt><dt>14.4.2. <a href="#view-tapestry-implementation">Implementation</a></dt><dd><dl><dt>14.4.2.1. <a href="#view-tapestry-context">Sample application context</a></dt><dt>14.4.2.2. <a href="#view-tapestry-appctx">Obtaining beans in Tapestry pages</a></dt><dt>14.4.2.3. <a href="#view-tapestry-exposeappctx">Exposing the application context to Tapestry</a></dt><dt>14.4.2.4. <a href="#view-tapestry-componentdefs">Component definition files</a></dt><dt>14.4.2.5. <a href="#view-tapestry-getters">Adding abstract accessors</a></dt></dl></dd><dt>14.4.3. <a href="#view-tapestry-summary">Summary</a></dt></dl></dd><dt>14.5. <a href="#webwork">WebWork</a></dt></dl></dd><dt>15. <a href="#d0e9685">JMS</a></dt><dd><dl><dt>15.1. <a href="#d0e9688">Introduction</a></dt><dt>15.2. <a href="#d0e9722">Domain unification</a></dt><dt>15.3. <a href="#d0e9732">JmsTemplate</a></dt><dd><dl><dt>15.3.1. <a href="#d0e9766">ConnectionFactory</a></dt><dt>15.3.2. <a href="#d0e9793">Transaction Management</a></dt><dt>15.3.3. <a href="#d0e9836">Destination Management</a></dt></dl></dd><dt>15.4. <a href="#d0e9892">Using the JmsTemplate</a></dt><dd><dl><dt>15.4.1. <a href="#d0e9903">Sending a message</a></dt><dt>15.4.2. <a href="#d0e9941">Synchronous Receiving</a></dt><dt>15.4.3. <a href="#d0e9952">Using Message Converters</a></dt><dt>15.4.4. <a href="#d0e10012">SessionCallback and ProducerCallback</a></dt></dl></dd></dl></dd><dt>16. <a href="#ejb">Accessing and implementing EJBs</a></dt><dd><dl><dt>16.1. <a href="#ejb-access">Accessing EJBs</a></dt><dd><dl><dt>16.1.1. <a href="#ejb-access-concepts">Concepts</a></dt><dt>16.1.2. <a href="#ejb-access-local">Accessing local SLSBs</a></dt><dt>16.1.3. <a href="#ejb-access-remote">Accessing remote SLSBs</a></dt></dl></dd><dt>16.2. <a href="#ejb-implementation">Using Spring convenience EJB implementation classes</a></dt></dl></dd><dt>17. <a href="#remoting">Remoting and web services using Spring</a></dt><dd><dl><dt>17.1. <a href="#d0e10242">Introduction</a></dt><dt>17.2. <a href="#d0e10325">Exposing services using RMI</a></dt><dd><dl><dt>17.2.1. <a href="#d0e10330">Exporting the service using the RmiServiceExporter</a></dt><dt>17.2.2. <a href="#d0e10370">Linking in the service at the client</a></dt></dl></dd><dt>17.3. <a href="#d0e10383">Using Hessian or Burlap to remotely call services via HTTP</a></dt><dd><dl><dt>17.3.1. <a href="#d0e10390">Wiring up the DispatcherServlet for Hessian</a></dt><dt>17.3.2. <a href="#d0e10409">Exposing your beans by using the HessianServiceExporter</a></dt><dt>17.3.3. <a href="#d0e10423">Linking in the service on the client</a></dt><dt>17.3.4. <a href="#d0e10434">Using Burlap</a></dt><dt>17.3.5. <a href="#d0e10445">Applying HTTP basic authentication to a service exposed through Hessian or Burlap</a></dt></dl></dd><dt>17.4. <a href="#d0e10467">Exposing services using HTTP invokers</a></dt><dd><dl><dt>17.4.1. <a href="#d0e10477">Exposing the service object</a></dt><dt>17.4.2. <a href="#d0e10494">Linking in the service at the client</a></dt></dl></dd><dt>17.5. <a href="#d0e10510">Web Services</a></dt><dd><dl><dt>17.5.1. <a href="#d0e10526">Exposing services using JAX-RPC</a></dt><dt>17.5.2. <a href="#d0e10537">Accessing Web Services</a></dt><dt>17.5.3. <a href="#d0e10597">Register Bean Mappings</a></dt><dt>17.5.4. <a href="#d0e10609">Registering our own Handler</a></dt><dt>17.5.5. <a href="#d0e10638">Exposing web services using XFire</a></dt></dl></dd><dt>17.6. <a href="#d0e10669">Auto-detection is not implemented for remote interfaces</a></dt><dt>17.7. <a href="#d0e10681">Considerations when choosing a technology</a></dt></dl></dd><dt>18. <a href="#mail">Sending Email with Spring mail abstraction layer</a></dt><dd><dl><dt>18.1. <a href="#mail-introduction">Introduction</a></dt><dt>18.2. <a href="#mail-structure">Spring mail abstraction structure</a></dt><dt>18.3. <a href="#mail-usage">Using Spring mail abstraction</a></dt><dd><dl><dt>18.3.1. <a href="#d0e10811">Pluggable MailSender implementations</a></dt></dl></dd><dt>18.4. <a href="#d0e10822">Using the JavaMail MimeMessageHelper</a></dt><dd><dl><dt>18.4.1. <a href="#d0e10833">Creating a simple MimeMessage and sending it</a></dt><dt>18.4.2. <a href="#d0e10841">Sending attachments and inline resources</a></dt></dl></dd></dl></dd><dt>19. <a href="#scheduling">Scheduling jobs using Quartz or Timer</a></dt><dd><dl><dt>19.1. <a href="#d0e10858">Introduction</a></dt><dt>19.2. <a href="#d0e10868">Using the OpenSymphony Quartz Scheduler</a></dt><dd><dl><dt>19.2.1. <a href="#d0e10884">Using the JobDetailBean</a></dt><dt>19.2.2. <a href="#d0e10921">Using the MethodInvokingJobDetailFactoryBean</a></dt><dt>19.2.3. <a href="#d0e10958">Wiring up jobs using triggers and the SchedulerFactoryBean</a></dt></dl></dd><dt>19.3. <a href="#d0e10984">Using JDK Timer support</a></dt><dd><dl><dt>19.3.1. <a href="#d0e10991">Creating custom timers</a></dt><dt>19.3.2. <a href="#d0e11013">Using the MethodInvokingTimerTaskFactoryBean</a></dt><dt>19.3.3. <a href="#d0e11030">Wrapping up: setting up the tasks using the TimerFactoryBean</a></dt></dl></dd></dl></dd><dt>20. <a href="#d0e11038">JMX Support</a></dt><dd><dl><dt>20.1. <a href="#jmx-introduction">Introduction</a></dt><dt>20.2. <a href="#jmx-exporting">Exporting your Beans to JMX</a></dt><dd><dl><dt>20.2.1. <a href="#jmx-exporting-mbeanserver">Creating an MBeanServer</a></dt><dt>20.2.2. <a href="#jmx-exporting-lazy">Lazy-Initialized MBeans</a></dt><dt>20.2.3. <a href="#jmx-exporting-auto">Automatic Registration of MBeans</a></dt></dl></dd><dt>20.3. <a href="#jmx-interface">Controlling the Management Interface of Your Beans</a></dt><dd><dl><dt>20.3.1. <a href="#jmx-interface-assembler">The MBeanInfoAssembler Interface</a></dt><dt>20.3.2. <a href="#jmx-interface-metadata">Using Source-Level Metadata</a></dt><dt>20.3.3. <a href="#jmx-interface-annotations">Using JDK 5.0 Annotations</a></dt><dt>20.3.4. <a href="#jmx-interface-metadata-types">Source Level Metadata Types</a></dt><dt>20.3.5. <a href="#jmx-interface-autodetect">The AutodetectCapableMBeanInfoAssembler
      Interface</a></dt><dt>20.3.6. <a href="#jmx-interface-java">Defining Management Interfaces using Java Interfaces</a></dt><dt>20.3.7. <a href="#jmx-interface-methodnames">Using
      MethodNameBasedMBeanInfoAssembler</a></dt></dl></dd><dt>20.4. <a href="#jmx-naming">Controlling the ObjectNames for your
    Beans</a></dt><dd><dl><dt>20.4.1. <a href="#jmx-naming-properties">Reading ObjectNames from
      Properties</a></dt><dt>20.4.2. <a href="#jmx-naiming-metadata">Using the MetadataNamingStrategy</a></dt></dl></dd><dt>20.5. <a href="#jmx-jsr160">Exporting your Beans with JSR-160 Connectors</a></dt><dd><dl><dt>20.5.1. <a href="#jmx-jsr160-server">Server-side Connectors</a></dt><dt>20.5.2. <a href="#jmx-jsr160-client">Client-side Connectors</a></dt><dt>20.5.3. <a href="#jmx-jsr160-protocols">JMX over Burlap/Hessian/SOAP</a></dt></dl></dd><dt>20.6. <a href="#jmx-proxy">Accessing MBeans via Proxies</a></dt></dl></dd><dt>21. <a href="#testing">Testing</a></dt><dd><dl><dt>21.1. <a href="#unit-testing">Unit testing</a></dt><dt>21.2. <a href="#integration-testing">Integration testing</a></dt><dd><dl><dt>21.2.1. <a href="#d0e12141">Context management and caching</a></dt><dt>21.2.2. <a href="#d0e12169">Dependency Injection of test class instances</a></dt><dt>21.2.3. <a href="#d0e12202">Transaction management</a></dt><dt>21.2.4. <a href="#d0e12254">Convenience variables</a></dt><dt>21.2.5. <a href="#d0e12284">Example</a></dt><dt>21.2.6. <a href="#d0e12363">Running integration tests</a></dt></dl></dd></dl></dd><dt>A. <a href="#springbeansdtd">spring-beans.dtd</a></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
        Developing software applications is hard enough even with good tools and 
        technologies. Implementing applications using platforms which promise 
        everything but turn out to be heavy-weight,
        hard to control and not very efficient during the development cycle makes
        it even harder. Spring provides a light-weight solution for 
        building enterprise-ready applications, while still supporting the
		possibility of using declarative transaction management, remote access to
		your logic using RMI or webservices, mailing facilities and various options
		in persisting your data to a database. Spring provides an MVC framework,
        transparent ways of integrating AOP into your software and a 
        well-structured exception hierarchy including automatic mapping from 
		proprietary exception hierarchies.
    </p><p>
        Spring could potentially be a one-stop-shop for all your enterprise
        applications, however, Spring is modular, allowing you to use
        parts of it, without having to bring in the rest. You can use
        the bean container, with Struts on top, but you could also choose to just
        use the Hibernate integration or the JDBC abstraction layer.
        Spring is non-intrusive, meaning dependencies on the framework are 
		generally none or absolutely minimal, depending on the area of use..
    </p><p>
        This document provides a reference guide to Spring's features.
        Since this document is still a work-in-progress, if you have any
        requests or comments, please post them on the user mailing list or
		on the forum at the SourceForge project page:
        <a href="http://www.sf.net/projects/springframework" target="_top">http://www.sf.net/projects/springframework</a> 
    </p><p>
        Before we go on, a few words of gratitude: Chris Bauer (of the
        Hibernate team) prepared and adapted the DocBook-XSL software in
		order  to be able to create Hibernate's reference guide, also allowing
        us to create this one. Also thanks to Russell Healy for doing an extensive
        and valuable review of some of the material.
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction-overview"></a>1.1.&nbsp;Overview</h2></div></div><div></div></div><p>
			Spring contains a lot of functionality and features, which are
			well-organized in seven modules shown in the diagram below.
			This section discusses each the of modules in turn.
		</p><p>
			</p><div class="mediaobject" align="center"><img src="images/spring-overview.gif" align="middle"><div class="caption"><p>Overview of the the Spring Framework
					</p></div></div><p>
		</p><p>
			The <span class="emphasis"><em>Core</em></span> package is the most fundamental part of the framework and
			provides the Dependency Injection features allowing you to manage
			bean container functionality. The basic concept here is the 
			BeanFactory, which provides a factory pattern removing the need for
			programmatic singletons and allowing you to decouple the configuration
			and specification of dependencies from your actual program logic.  
		</p><p>
			On top of the <span class="emphasis"><em>Core</em></span> package sits the 
			<span class="emphasis"><em>Context</em></span> package,
			providing a way to access beans in a framework-style manner,
			somewhat resembling a JNDI-registry. The context package inherits
			its features from the beans package and adds support for text
			messaging using e.g. resource bundles, 
			event-propagation, resource-loading and transparent
			creation of contexts by, for example, a servlet container.
		</p><p>
			The <span class="emphasis"><em>DAO</em></span> package provides a JDBC-abstraction
			layer that removes the need to do tedious JDBC coding and parsing
			of database-vendor specific error codes.
			Also, the JDBC package provides a way to do 
			programmatic as well as declarative transaction
			management, not only for classes implementing special interfaces,
			but for <span class="emphasis"><em>all your POJOs (plain old java objects)</em></span>.
		</p><p>
			The <span class="emphasis"><em>ORM</em></span> package provides integration layers
			for popular object-relational mapping APIs, including JDO, Hibernate
			and iBatis. Using the ORM package you can use all those O/R-mappers
			in combination with all the other features Spring offers, like
			simple declarative transaction management mentioned before.
		</p><p>
			Spring's <span class="emphasis"><em>AOP</em></span> package provides an 
			<span class="emphasis"><em>AOP Alliance</em></span> compliant aspect-oriented
			programming implementation allowing you to define, for example,
			method-interceptors and pointcuts to cleanly decouple code
			implementing functionality that should logically speaking be separated.
			Using source-level metadata functionality you can 
			incorporate all kinds of behavioral information into your code,
			a little like .NET attributes.
		</p><p>
			Spring's <span class="emphasis"><em>Web</em></span> package provides basic 
			web-oriented integration features, such as multipart functionality,
			initialization of contexts using servlet listeners and 
			a web-oriented application context. When using
			Spring together with WebWork or Struts, this is the package to 
			integrate with.
		</p><p>
			Spring's <span class="emphasis"><em>Web MVC</em></span> package provides a 
			Model-View-Controller implementation for web-applications. 
			Spring's MVC implementation is not just any implementation,
			it provides a clean separation between domain model code and
			web forms and allows you to use all the other features of the Spring
			Framework like validation.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-usagescenarios"></a>1.2.&nbsp;Usage scenarios</h2></div></div><div></div></div><p>
			With the building blocks described above you can use Spring in all sorts
			of scenarios, from applets up to fully-fledged enterprise applications
			using Spring's transaction management functionality and Web framework.
		</p><p>			
			</p><div class="mediaobject" align="center"><img src="images/full.gif" align="middle"><div class="caption"><p>Typical full-fledged Spring web application
					</p></div></div><p>
		</p><p>
			A typical web application using most of Spring's features. Using
			<tt class="literal">TransactionProxyFactoryBeans</tt> the web application is fully transactional,
			just as it would be when using container managed transaction as provided by Enterprise
			JavaBeans. All your custom business logic can be implemented using simple POJOs, managed
			by Spring's Dependency Injection container. Additional services such as sending email and
			validation, independent of the web layer enable you to choose where to execute
			validation rules. Spring's ORM support is integrated with Hibernate, JDO and iBatis.  Using
			for example <tt class="literal">HibernateDaoSupport</tt>, you can re-use your existing Hibernate
			mappings. Form controllers seamlessly integrate the web-layer with the domain model, removing
			the need for <tt class="literal">ActionForms</tt> or other classes that transform
			HTTP parameters to values for your domain model.
		</p><p>
			</p><div class="mediaobject" align="center"><img src="images/thirdparty-web.gif" align="middle"><div class="caption"><p>Spring middle-tier using a third-party web framework
					</p></div></div><p>
		</p><p>
			Sometimes the current circumstances do not allow you to
			completely switch to a different framework. Spring does 
			<span class="emphasis"><em>not</em></span> force
			you to use everything within it; it's not an <span class="emphasis"><em>all-or-nothing</em></span>
			solution. Existing frontends using WebWork, Struts, Tapestry,
			or other UI frameworks can be integrated perfectly well with
			a Spring-based middle-tier,
			allowing you to use the transaction features that Spring
			offers. The only thing you need to do is wire up your business
			logic using an <tt class="literal">ApplicationContext</tt> and
			integrate your Web UI layer using a
			<tt class="literal">WebApplicationContext</tt>.
		
		</p><p>
			</p><div class="mediaobject" align="center"><img src="images/remoting.gif" align="middle"><div class="caption"><p>Remoting usage scenario
					</p></div></div><p>
		</p><p>			
			When you need to access existing code via webservices, you can use
			Spring's <tt class="literal">Hessian-</tt>,
			<tt class="literal">Burlap-</tt>, <tt class="literal">Rmi-</tt> or <tt class="literal">JaxRpcProxyFactory</tt> classes. Enabling remote access to existing application is all of a sudden not that hard anymore.
		</p><p>
			</p><div class="mediaobject" align="center"><img src="images/ejb.gif" align="middle"><div class="caption"><p>EJBs - Wrapping existing POJOs
					</p></div></div><p>
		</p><p>
			Spring also provides an access layer and abstraction layer for Enterprise JavaBeans,
			enabling you to reuse your existing POJOs and wrap them in Stateless Session Beans,
			for use in scalable failsafe web applications, that might need declarative security.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="background"></a>Chapter&nbsp;2.&nbsp;Background information</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="background-ioc"></a>2.1.&nbsp;Inversion of Control / Dependency Injection</h2></div></div><div></div></div><p>
    		In early 2004, Martin Fowler asked the readers of his site: when talking about Inversion 
    		of Control: <span class="emphasis"><em>"the question, is what aspect of control are they inverting?"</em></span>.
    		After talking about the term Inversion of Control Martin suggests renaming the 
    		pattern, or at least giving it a more self-explanatory name, and starts to use the
    		term <span class="emphasis"><em>Dependency Injection</em></span>. His article continues to explain some of 
    		the ideas behind Inversion of Control or Dependency Injection. If you need a decent
    		insight: <a href="http://martinfowler.com/articles/injection.html" target="_top">http://martinfowler.com/articles/injection.html</a>.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="beans"></a>Chapter&nbsp;3.&nbsp;Beans, BeanFactory and the ApplicationContext</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-introduction"></a>3.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Two of the most elementary and important packages in Spring are the
    <tt class="literal">org.springframework.beans</tt> and
    <tt class="literal">org.springframework.context</tt> packages. Code in these
    packages provides the basis for Spring's <span class="emphasis"><em>Inversion of
    Control</em></span> (alternately called <span class="emphasis"><em>Dependency
    Injection</em></span>) features. The <tt class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html" target="_top">BeanFactory</a></tt>
    provides an advanced configuration mechanism capable of managing beans
    (objects) of any nature, using potentially any kind of storage facility.
    The <a href="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html" target="_top">ApplicationContext</a>
    builds on top of the BeanFactory (it's a subclass) and adds other
    functionality such as easier integration with Springs AOP features,
    message resource handling (for use in internationalization), event
    propagation, declarative mechanisms to create the ApplicationContext and
    optional parent contexts, and application-layer specific contexts such as
    the <tt class="literal">WebApplicationContext</tt>, among other
    enhancements.</p><p>In short, the <tt class="literal">BeanFactory</tt> provides the
    configuration framework and basic functionality, while the
    <tt class="literal">ApplicationContext</tt> adds enhanced capabilities to it,
    some of them perhaps more J2EE and enterprise-centric. In general, an
    ApplicationContext is a complete superset of a BeanFactory, and any
    description of BeanFactory capabilities and behavior should be considered
    to apply to ApplicationContexts as well.</p><p>Users are sometimes unsure whether a BeanFactory or an
    ApplicationContext are best suited for use in a particular situation.
    Normally when building most applications in a J2EE-environment,
    <span class="emphasis"><em>the best option is to use the ApplicationContext</em></span>,
    since it offers all the features of the BeanFactory and adds on to it in
    terms of features, while also allowing a more declarative approach to use
    of some functionality, which is generally desirable. The main usage
    scenario when you might prefer to use the BeanFactory is when memory usage
    is the greatest concern (such as in an applet where every last kilobyte
    counts), and you don't need all the features of the
    ApplicationContext.</p><p>This chapter covers material related to both the BeanFactory and the
    ApplicationContext. When mention is made only of the BeanFactory, you may
    always assume the text also applies to the ApplicaitonContext. When
    functionality is only available in the ApplicationContext, explicit
    mention is made of this.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-basics"></a>3.2.&nbsp;BeanFactory and BeanDefinitions - the basics</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory"></a>3.2.1.&nbsp;The BeanFactory</h3></div></div><div></div></div><p>The <tt class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html" target="_top">BeanFactory</a></tt>
      is the actual <span class="emphasis"><em>container</em></span> which instantiates,
      configures, and manages a number of beans. These beans typically
      collaborate with one another, and thus have dependencies between
      themselves. These dependencies are reflected in the configuration data
      used by the BeanFactory (although some dependencies may not be visible
      as configuration data, but rather be a function of programmatic
      interactions between beans at runtime).</p><p>A BeanFactory is represented by the interface
      <tt class="literal">org.springframework.beans.factory.BeanFactory</tt>, for
      which there are multiple implementations. The most commonly used simple
      BeanFactory implementation is
      <tt class="literal">org.springframework.beans.factory.xml.XmlBeanFactory</tt>.
      (This should be qualified with the reminder that ApplicationContexts are
      a subclass of BeanFactory, and most users ultimately prefer to use XML
      variants of ApplicationContext).</p><p>Although for most scenarios, almost all user code managed by the
      BeanFactory does not have to be aware of the BeanFactory, the
      BeanFactory does have to be instantiated somehow. This can happen via
      explicit user code such as:</p><pre class="programlisting">InputStream is = new FileInputStream("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);</pre><p>or</p><pre class="programlisting">ClassPathResource res = new ClassPathResource("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(res);</pre><p>or</p><pre class="programlisting">ClassPathXmlApplicationContext appContext = new ClassPathXmlApplicationContext(
        new String[] {"applicationContext.xml", "applicationContext-part2.xml"});
// of course, an ApplicationContext is just a BeanFactory
BeanFactory factory = (BeanFactory) appContext;</pre><p>For many usage scenarios, user code will not have to instantiate
      the BeanFactory, since Spring Framework code will do it. For example,
      the web layer provides support code to load a Spring ApplicationContext
      automatically as part of the normal startup process of a J2EE web-app.
      This declarative process is described <a href="#context-create" title="3.19.&nbsp;Creating an ApplicationContext from a web application">here</a>:</p><p>While programmatic manipulation of BeanFactories will be described
      later, the following sections will concentrate on describing the
      configuration of BeanFactories.</p><p>A BeanFactory configuration consists of, at its most basic level,
      definitions of one or more beans that the BeanFactory must manage. In an
      XmlBeanFactory, these are configured as one or more
      <tt class="literal">bean</tt> elements inside a top-level
      <tt class="literal">beans</tt> element.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd"&gt;

&lt;beans&gt;
  
  &lt;bean id="..." class="..."&gt;
    ...
  &lt;/bean&gt;
  &lt;bean id="..." class="..."&gt;
    ...
  &lt;/bean&gt;

  ...

&lt;/beans&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-definition"></a>3.2.2.&nbsp;The BeanDefinition</h3></div></div><div></div></div><p>Bean definitions inside a DefaultListableBeanFactory variant (like
      XmlBeanFactory) are represented as BeanDefinition objects, which contain
      (among other information) the following details: </p><div class="itemizedlist"><ul type="disc" compact><li><p>a class name: this is normally the actual implementation
            class of the bean being described in the bean definition. However,
            if the bean is to be constructed by calling a static
            <span class="emphasis"><em>factory</em></span> method instead of using a normal
            constructor, this will actually be the class name of the factory
            class.</p></li><li><p>bean behavioral configuration elements, which state how the
            bean should behave in the container (i.e. prototype or singleton,
            autowiring mode, dependency checking mode, initialization and
            destruction methods)</p></li><li><p>constructor arguments and property values to set in the
            newly created bean. An example would be the number of connections
            to use in a bean that manages a connection pool (either specified
            as a property or as a constructor argument), or the pool size
            limit.</p></li><li><p>other beans a bean needs to do its work, i.e.
            <span class="emphasis"><em>collaborators</em></span> (also specified as properties
            or as constructor arguments). These can also be called
            dependencies.</p></li></ul></div><p>The concepts listed above directly translate to a set of elements
      the bean definition consists of. Some of these element groups are listed
      below, along with a link to further documentation about each of them.
      </p><div class="table"><a name="d0e366"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Bean definition explanation</b></p><table summary="Bean definition explanation" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>More info</th></tr></thead><tbody><tr><td>class</td><td><a href="#beans-factory-class" title="3.2.3.&nbsp;The bean class">Section&nbsp;3.2.3, &#8220;The bean class&#8221;</a></td></tr><tr><td>id and name</td><td><a href="#beans-beanname" title="3.2.4.&nbsp;The bean identifiers (id and&#xA;      name)">Section&nbsp;3.2.4, &#8220;The bean identifiers (id and
      name)&#8221;</a></td></tr><tr><td>singleton or prototype</td><td><a href="#beans-factory-modes" title="3.2.5.&nbsp;To singleton or not to singleton">Section&nbsp;3.2.5, &#8220;To singleton or not to singleton&#8221;</a></td></tr><tr><td>constructor arguments</td><td><a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Setting bean properties and collaborators">Section&nbsp;3.3.1, &#8220;Setting bean properties and collaborators&#8221;</a></td></tr><tr><td>bean properties</td><td><a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Setting bean properties and collaborators">Section&nbsp;3.3.1, &#8220;Setting bean properties and collaborators&#8221;</a></td></tr><tr><td>autowiring mode</td><td><a href="#beans-factory-autowire" title="3.3.6.&nbsp;Autowiring collaborators">Section&nbsp;3.3.6, &#8220;Autowiring collaborators&#8221;</a></td></tr><tr><td>dependency checking mode</td><td><a href="#beans-factory-dependencies" title="3.3.7.&nbsp;Checking for dependencies">Section&nbsp;3.3.7, &#8220;Checking for dependencies&#8221;</a></td></tr><tr><td>initialization method</td><td><a href="#beans-factory-lifecycle" title="3.4.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.4.1, &#8220;Lifecycle interfaces&#8221;</a></td></tr><tr><td>destruction method</td><td><a href="#beans-factory-lifecycle" title="3.4.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.4.1, &#8220;Lifecycle interfaces&#8221;</a></td></tr></tbody></table></div><p>Note that a bean definition is represented by the real interface
      <tt class="literal">org.springframework.beans.factory.config.BeanDefinition</tt>,
      and its various sub-interfaces and implementations. However, it is very
      unlikely that most user code would ever work with a
      BeanDefinition.</p><p>Besides bean definitions which contain information on how to
      create a bean, a bean factory can also allow to register existing bean
      instances. DefaultListableBeanFactory supports this through the
      <tt class="literal">registerSingleton</tt> method, as defined by the
      <tt class="literal">org.springframework.beans.factory.config.ConfigurableBeanFactory</tt>
      interface. Typical applications purely work with bean definitions,
      though.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-class"></a>3.2.3.&nbsp;The bean class</h3></div></div><div></div></div><p>The <tt class="literal">class</tt> attribute is normally mandatory (see
      <a href="#beans-instance-factory-method" title="3.2.3.3.&nbsp;Bean creation via instance factory method">Section&nbsp;3.2.3.3, &#8220;Bean creation via instance factory method&#8221;</a> and <a href="#beans-child-bean-definitions" title="3.5.&nbsp;Abstract and child bean definitions">Section&nbsp;3.5, &#8220;Abstract and child bean definitions&#8221;</a> for the two exception) and is
      used for one of two purposes. In the much more common case where the
      BeanFactory itself directly creates the bean by calling its constructor
      (equivalent to Java code calling <span class="emphasis"><em>new</em></span>), the class
      attribute specifies the class of the bean to be constructed. In the less
      common case where the BeanFactory calls a static, so-called
      <span class="emphasis"><em>factory</em></span> method on a class to create the bean, the
      class attribute specifies the actual class containing the static factory
      method. (the type of the returned bean from the static factory method
      may be the same class or another class entirely, it doesn't
      matter).</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e455"></a>3.2.3.1.&nbsp;Bean creation via constructor</h4></div></div><div></div></div><p>When creating a bean using the constructor approach, all normal
        classes are usable by Spring and compatible with Spring. That is, the
        class being created does not need to implement any specific interfaces
        or be coded in a specific fashion. Just specifying the bean class
        should be enough. However, depending on what type of IoC you are going
        to use for that specific bean, you may need a default (empty)
        constructor.</p><p>Additionally, the BeanFactory isn't limited to just managing
        true JavaBeans, it is also able to manage virtually
        <span class="emphasis"><em>any</em></span> class you want it to manage. Most people
        using Spring prefer to have actual JavaBeans (having just a default
        (no-argument) constructor and appropriate setters and getters modeled
        after the properties) in the BeanFactory, but it it's also possible to
        have more exotic non-bean-style classes in your BeanFactory. If, for
        example, you need to use a legacy connection pool that absolutely does
        not adhere to the JavaBean specification, no worries, Spring can
        manage it as well.</p><p>Using the XmlBeanFactory you can specify your bean class as
        follows: </p><pre class="programlisting">&lt;bean id="exampleBean"
      class="examples.ExampleBean"/&gt;
&lt;bean name="anotherExample"
      class="examples.ExampleBeanTwo"/&gt; </pre><p>The mechanism for supplying (optional) arguments to the
        constructor, or setting properties of the object instance after it has
        been constructed, will be described shortly.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e471"></a>3.2.3.2.&nbsp;Bean creation via static factory method</h4></div></div><div></div></div><p>When defining a bean which is to be created using a static
        factory method, along with the <tt class="literal">class</tt> attribute
        which specifies the class containing the static factory method,
        another attribute named <tt class="literal">factory-method</tt> is needed to
        specify the name of the factory method itself. Spring expects to be
        able to call this method (with an optional list of arguments as
        described later) and get back a live object, which from that point on
        is treated as if it had been created normally via a constructor. One
        use for such a bean definition is to call static factories in legacy
        code.</p><p>Following is an example of a bean definition which specifies
        that the bean is to be created by calling a factory-method. Note that
        the definition does not specify the type (class) of the returned
        object, only the class containing the factory method. In this example,
        <tt class="literal">createInstance</tt> must be a
        <span class="emphasis"><em>static</em></span> method.</p><pre class="programlisting">&lt;bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/&gt;</pre><p>The mechanism for supplying (optional) arguments to the factory
        method, or setting properties of the object instance after it has been
        returned from the factory, will be described shortly.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-instance-factory-method"></a>3.2.3.3.&nbsp;Bean creation via instance factory method</h4></div></div><div></div></div><p>Quite similar to using a static factory method to create a bean,
        is the use of an instance (non-static) factory method, where a factory
        method of an existing bean from the factory is called to create the
        new bean.</p><p>To use this mechanism, the <tt class="literal">class</tt> attribute
        must be left empty, and the <tt class="literal">factory-bean</tt> attribute
        must specify the name of a bean in the current or an ancestor bean
        factory which contains the factory method. The factory method itself
        should still be set via the <tt class="literal">factory-method</tt>
        attribute.</p><p>Following is an example:</p><pre class="programlisting">&lt;!-- The factory bean, which contains a method called
     createInstance --&gt;
&lt;bean id="myFactoryBean"
      class="..."&gt;
  ...
&lt;/bean&gt;
&lt;!-- The bean to be created via the factory bean --&gt;
&lt;bean id="exampleBean"
      factory-bean="myFactoryBean"
      factory-method="createInstance"/&gt;</pre><p>Although the mechanisms for setting bean properties are still to
        be discussed, one implication of this approach is that the factory
        bean itself can be managed and configured via Dependency Injection, by
        the container.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beanname"></a>3.2.4.&nbsp;The bean identifiers (<tt class="literal">id</tt> and
      <tt class="literal">name</tt>)</h3></div></div><div></div></div><p>Every bean has one or more ids (also called identifiers, or names;
      these terms refer to the same thing). These ids must be unique within
      the BeanFactory or ApplicationContext the bean is hosted in. A bean will
      almost always have only one id, but if a bean has more than one id, the
      extra ones can essentially be considered aliases.</p><p>In an XmlBeanFactory (including ApplicationContext variants), you
      use the <tt class="literal">id</tt> or <tt class="literal">name</tt> attributes to
      specify the bean id(s), and at least one id must be specified in one or
      both of these attributes. The <tt class="literal">id</tt> attribute allows you
      to specify one id, and as it is marked in the XML DTD (definition
      document) as a real XML element ID attribute, the parser is able to do
      some extra validation when other elements point back to this one. As
      such, it is the preferred way to specify a bean id. However, the XML
      spec does limit the characters which are legal in XML IDs. This is
      usually not really a constraint, but if you have a need to use one of
      these characters, or want to introduce other aliases to the bean, you
      may also or instead specify one or more bean ids (separated by a comma
      (<tt class="literal">,</tt>) or semicolon (<tt class="literal">;</tt>) via the
      <tt class="literal">name</tt> attribute.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-modes"></a>3.2.5.&nbsp;To singleton or not to singleton</h3></div></div><div></div></div><p>Beans are defined to be deployed in one of two modes: singleton or
      non-singleton. (The latter is also called a prototype, although the term
      is used loosely as it doesn't quite fit). When a bean is a singleton,
      only one <span class="emphasis"><em>shared</em></span> instance of the bean will be
      managed and all requests for beans with an id or ids matching that bean
      definition will result in that one specific bean instance being
      returned.</p><p>The non-singleton, prototype mode of a bean deployment results in
      the <span class="emphasis"><em>creation of a new bean instance</em></span> every time a
      request for that specific bean is done. This is ideal for situations
      where for example each user needs an independent user object or
      something similar.</p><p>Beans are deployed in singleton mode by default, unless you
      specify otherwise. Keep in mind that by changing the type to
      non-singleton (prototype), each request for a bean will result in a
      newly created bean and this might not be what you actually want. So only
      change the mode to prototype when absolutely necessary.</p><p>In the example below, two beans are declared of which one is
      defined as a singleton, and the other one is a non-singleton
      (prototype). <tt class="literal">exampleBean</tt> is created each and every
      time a client asks the BeanFactory for this bean, while
      <tt class="literal">yetAnotherExample</tt> is only created once; a reference
      to the exact same instance is returned on each request for this
      bean.</p><pre class="programlisting">&lt;bean id="exampleBean"
      class="examples.ExampleBean" singleton="false"/&gt;
&lt;bean name="yetAnotherExample"
      class="examples.ExampleBeanTwo" singleton="true"/&gt;</pre><p>Note: when deploying a bean in the prototype mode, the lifecycle
      of the bean changes slightly. By definition, Spring cannot manage the
      complete lifecycle of a non-singleton/prototype bean, since after it is
      created, it is given to the client and the container does not keep track
      of it at all any longer. You can think of Spring's role when talking
      about a non-singleton/prototype bean as a replacement for the 'new'
      operator. Any lifecycle aspects past that point have to be handled by
      the client. The lifecycle of a bean in the BeanFactory is further
      described in <a href="#beans-factory-lifecycle" title="3.4.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.4.1, &#8220;Lifecycle interfaces&#8221;</a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-dependencies"></a>3.3.&nbsp;Properties, collaborators, autowiring and dependency
    checking</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-collaborators"></a>3.3.1.&nbsp;Setting bean properties and collaborators</h3></div></div><div></div></div><p>Inversion of Control has already been referred to as
      <span class="emphasis"><em>Dependency Injection</em></span>. The basic principle is that
      beans define their dependencies (i.e. the other objects they work with)
      only through constructor arguments, arguments to a factory method, or
      properties which are set on the object instance after it has been
      constructed or returned from a factory method. Then, it is the job of
      the container to actually <span class="emphasis"><em>inject</em></span> those dependencies
      when it creates the bean. This is fundamentally the inverse (hence the
      name Inversion of Control) of the bean instantiating or locating its
      dependencies on its own using direct construction of classes, or
      something like the <span class="emphasis"><em>Service Locator</em></span> pattern. While
      we will not elaborate too much on the advantages of Dependency
      Injection, it becomes evident upon usage that code gets much cleaner and
      reaching a higher grade of decoupling is much easier when beans do not
      look up their dependencies, but are provided with them, and additionally
      do not even know where the dependencies are located and of what actual
      type they are.</p><p>As touched on in the previous paragraph, Inversion of
      Control/Dependency Injection exists in two major variants:</p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>setter-based</em></span> dependency injection is
            realized by calling setters on your beans after invoking a
            no-argument constructor or no-argument static factory method to
            instantiate your bean. Beans defined in the BeanFactory that use
            setter-based dependency injection are <span class="emphasis"><em>true
            JavaBeans</em></span>. Spring generally advocates usage of
            setter-based dependency injection, since a large number of
            constructor arguments can get unwieldy, especially when some
            properties are optional.</p></li><li><p><span class="emphasis"><em>constructor-based</em></span> dependency injection
            is realized by invoking a constructor with a number of arguments,
            each representing a collaborator or property. Additionally,
            calling a static factory method with specific arguments, to
            construct the bean, can be considered almost equivalent, and the
            rest of this text will consider arguments to a constructor and
            arguments to a static factory method similarly. Although Spring
            generally advocates usage of setter-based dependency injection for
            most situations, it does fully support the constructor-based
            approach as well, since you may wish to use it with pre-existing
            beans which provide only multi-argument constructors, and no
            setters. Additionally, for simpler beans, some people prefer the
            constructor approach as a means of ensuring beans cannot be
            constructed in an invalid state.</p></li></ul></div><p>The <tt class="classname">BeanFactory</tt> supports both of these
      variants for injecting dependencies into beans it manages. (It in fact
      also supports injecting setter-based dependencies after some
      dependencies have already been supplied via the constructor approach.)
      The configuration for the dependencies comes in the form of a
      <tt class="literal">BeanDefinition</tt>, which is used together with JavaBeans
      <tt class="literal">PropertyEditors</tt> to know how to convert properties
      from one format to another. The actual values being passed around are
      done in the form of <tt class="literal">PropertyValue</tt> objects. However,
      most users of Spring will not be dealing with these classes directly
      (i.e. programmatically), but rather with an XML definition file which
      will be converted internally into instances of these classes, and used
      to load an entire BeanFactory or ApplicationContext.</p><p>Bean dependency resolution generally happens as
      follows:</p><div class="orderedlist"><ol type="1" compact><li><p>The BeanFactory is created and initialized with a
            configuration which describes all the beans. Most Spring users use
            a BeanFactory or ApplicationContext variant which supports XML
            format configuration files.</p></li><li><p>Each bean has dependencies expressed in the form of
            properties, constructor arguments, or arguments to the
            static-factory method when that is used instead of a normal
            constructor. These dependencies will be provided to the bean,
            <span class="emphasis"><em>when the bean is actually created</em></span>.</p></li><li><p>Each property or constructor-arg is either an actual
            definition of the value to set, or a reference to another bean in
            the BeanFactory. In the case of the ApplicationContext, the
            reference can be to a bean in a parent ApplicationContext.</p></li><li><p><a name="beans-factory-collaborators-propertyeditor"></a>Each property or
            constructor argument which is a value must be able to be converted
            from whatever format it was specified in, to the actual type of
            that property or constructor argument. By default Spring can
            convert a value supplied in string format to all built-in types,
            such as <tt class="literal">int</tt>, <tt class="literal">long</tt>,
            <tt class="literal">String</tt>, <tt class="literal">boolean</tt>, etc.
            Additionally, when talking about the XML based BeanFactory
            variants (including the ApplicationContext variants), these have
            built-in support for defining Lists, Maps, Sets, and Properties
            collection types. Additionally, Spring uses JavaBeans
            <tt class="classname">PropertyEditor</tt> definitions to be able to
            convert string values to other, arbitrary types. (You can provide
            the BeanFactory with your own <tt class="literal">PropertyEditor</tt>
            definitions to be able to convert your own custom types; more
            information about PropertyEditors and how to manually add custom
            ones, can be found in <a href="#beans-beanfactory-customeditors" title="3.9.&nbsp;Registering additional custom PropertyEditors">Section&nbsp;3.9, &#8220;Registering additional custom PropertyEditors&#8221;</a>). When a bean
            property is a Java Class type, Spring allows you to specify the
            value for that property as a string value which is the name of the
            class, and the <tt class="literal">ClassEditor</tt> PropertyEditor,
            which is built-in, will take care of converting that class name to
            an actual Class instance.</p></li><li><p>It is important to realize that Spring validates the
            configuration of each bean in the BeanFactory when the BeanFactory
            is created, including the validation that properties which are
            bean references are actually referring to valid beans (i.e. the
            beans being referred to are also defined in the BeanFactory, or in
            the case of ApplicationContext, a parent context). However, the
            bean properties themselves are not set until the bean <span class="emphasis"><em>is
            actually created</em></span>. For beans which are singleton and set
            to be pre-instantiated (such as singleton beans in an
            ApplicationContext), creation happens at the time that the
            BeanFactory is created, but otherwise this is only when the bean
            is requested. When a bean actually has to be created, this will
            potentially cause a graph of other beans to be created, as its
            dependencies and its dependencies' dependencies (and so on) are
            created and assigned.</p></li><li><p>You can generally trust Spring to do the right thing. It
            will pick up configuration issues, including references to
            non-existent beans and circular dependencies, at BeanFactory
            load-time. It will actually set properties and resolve
            dependencies (i.e. create those dependencies if needed) as late as
            possible, which is when the bean is actually created. This does
            mean that a BeanFactory which has loaded correctly, can later
            generate an exception when you request a bean, if there is a
            problem creating that bean or one of its dependencies. This could
            happen if the bean throws an exception as a result of a missing or
            invalid property, for example. This potentially delayed visibility
            of some configuration issues is why ApplicationContext by default
            pre-instantiates singleton beans. At the cost of some upfront time
            and memory to create these beans before they are actually needed,
            you find out about configuration issues when the
            ApplicationContext is created, not later. If you wish, you can
            still override this default behavior and set any of these
            singleton beans to lazy-load (not be pre-instantiated).</p></li></ol></div><p>Some examples:</p><p>First, an example of using the BeanFactory for setter-based
      dependency injection. Below is a small part of an
      <tt class="literal">XmlBeanFactory</tt> configuration file specifying some
      bean definitions. Following is the code for the actual main bean itself,
      showing the appropriate setters declared. </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;property name="beanOne"&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/property&gt;
    &lt;property name="beanTwo"&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/property&gt;
    &lt;property name="integerProperty"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><p>
      </p><pre class="programlisting">public class ExampleBean {
    
    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }
    
    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }
    
    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}</pre><p>As you can see, setters have been declared to match against
      the properties specified in the XML file. (The properties from the XML
      file, directly relate to the <tt class="literal">PropertyValues</tt> object
      from the <tt class="literal">RootBeanDefinition</tt>)</p><p>Now, an example of using the BeanFactory for IoC type 3
      (constructor-based dependency injection). Below is a snippet from an XML
      configuration that specifies constructor arguments and the actual bean
      code, showing the constructor: </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;constructor-arg&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg type="int"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><p>
      </p><pre class="programlisting">public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}</pre><p>As you can see, the constructor arguments specified in the
      bean definition will be used to pass in as arguments to the constructor
      of the <tt class="literal">ExampleBean</tt>.</p><p>Now consider a variant of this where instead of using a
      constructor, Spring is told to call a static factory method to return an
      instance of the object.: </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance"&gt;
    &lt;constructor-arg&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;value&gt;1&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><p>
      </p><pre class="programlisting">public class ExampleBean {

    ...

    // a private constructor
    private ExampleBean(...) {
      ...
    }
    
    // a static factory method
    // the arguments to this method can be considered the dependencies of the bean that
    // is returned, regardless of how those arguments are actually used.
    public static ExampleBean createInstance(
            AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        ExampleBean eb = new ExampleBean(...);
        // some other operations
        ...
        return eb;
    }
}</pre><p>Note that arguments to the static factory method are supplied via
      <tt class="literal">constructor-arg</tt> elements, exactly the same as if a
      constructor had actually been used. These arguments are optional. Also,
      it is important to realize that the type of the class being returned by
      the factory method does not have to be of the same type as the class
      which contains the static factory method, although in this example it
      is. An instance (non-static) factory method, mentioned previously, would
      be used in an essentially identical fashion (aside from the use of the
      <tt class="literal">factory-bean</tt> attribute instead of the
      <tt class="literal">class</tt> attribute), so will not be detailed
      here.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e722"></a>3.3.2.&nbsp;Constructor Argument Resolution</h3></div></div><div></div></div><p>Constructor argument resolution matching occurs using the
      argument's type. When another bean is referenced, the type is known, and
      matching can occur. When a simple type is used, such as
      <tt class="literal">&lt;value&gt;true&lt;value&gt;</tt>, Spring cannot
      determine the type of the value, and so cannot match by type without
      help. Consider the following class, which is used for the following two
      sections: </p><pre class="programlisting">package examples;

public class ExampleBean {

    private int years;             //No. of years to the calculate the Ultimate Answer
    private String ultimateAnswer; //The Answer to Life, the Universe, and Everything

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e732"></a>3.3.2.1.&nbsp;Constructor Argument Type Matching</h4></div></div><div></div></div><p>The above scenario <span class="emphasis"><em>can</em></span> use type matching
        with simple types by explicitly specifying the type of the constructor
        argument using the <tt class="literal">type</tt> attribute. For example:
        </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
     &lt;constructor-arg type="int"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/constructor-arg&gt;
     &lt;constructor-arg type="java.lang.String"&gt;&lt;value&gt;42&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt; </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e745"></a>3.3.2.2.&nbsp;Constructor Argument Index</h4></div></div><div></div></div><p>Constructor arguments can have their index specified explicitly
        by use of the <tt class="literal">index</tt> attribute. For example:
        </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
     &lt;constructor-arg index="0"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/constructor-arg&gt;
     &lt;constructor-arg index="1"&gt;&lt;value&gt;42&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt; </pre><p> As well as solving the ambiguity problem of
        multiple simple values, specifying an index also solves the problem of
        ambiguity where a constructor may have two arguments of the same type.
        Note that the <span class="emphasis"><em>index is 0 based</em></span>.</p><p>Specifying a constructor argument index is the preferred way of
        performing constructor IoC.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-properties-detailed"></a>3.3.3.&nbsp;Bean properties and constructor arguments detailed</h3></div></div><div></div></div><p>As mentioned in the previous section, bean properties and
      constructor arguments can be defined as either references to other
      managed beans (collaborators), or values defined inline. The
      <tt class="literal">XmlBeanFactory</tt> supports a number of sub-element types
      within its <tt class="literal">property</tt> and
      <tt class="literal">constructor-arg</tt> elements for this purpose.</p><p>The <tt class="literal">value</tt> element specifies a property or
      constructor argument as a human-readable string representation. As
      mentioned in detail <a href="#beans-factory-collaborators-propertyeditor">previously</a>,
      JavaBeans PropertyEditors are used to convert these string values from a
      <tt class="literal">java.lang.String</tt> to the actual property or argument
      type.</p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;!-- results in a setDriverClassName(String) call --&gt;
        &lt;property name="driverClassName"&gt;
            &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="url"&gt;
            &lt;value&gt;jdbc:mysql://localhost:3306/mydb&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="username"&gt;
            &lt;value&gt;root&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt; </pre><p>The <tt class="literal">null</tt> element is used to handle null values.
      Spring treats empty arguments for properties and the like as empty
      Strings. The following XmlBeanFactory configuration: </p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
    &lt;property name="email"&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;        </pre><p>results in the email property being set
      to "", equivalent to the java code:
      <tt class="literal">exampleBean.setEmail("")</tt>. The special
      <tt class="literal">&lt;null&gt;</tt> element may be used to indicate a null
      value, so that: </p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
    &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;
&lt;/bean&gt;        </pre><p>is equivalent to the java code:
      <tt class="literal">exampleBean.setEmail(null)</tt>.</p><p>The <tt class="literal">list</tt>, <tt class="literal">set</tt>,
      <tt class="literal">map</tt>, and <tt class="literal">props</tt> elements allow
      properties and arguments of Java type <tt class="literal">List</tt>,
      <tt class="literal">Set</tt>, <tt class="literal">Map</tt>, and
      <tt class="literal">Properties</tt>, respectively, to be defined and
      set.</p><pre class="programlisting">&lt;beans&gt;
    ...
    &lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
        &lt;!-- results in a setPeople(java.util.Properties) call --&gt;
        &lt;property name="people"&gt;
            &lt;props&gt;
                &lt;prop key="HarryPotter"&gt;The magic property&lt;/prop&gt;
                &lt;prop key="JerrySeinfeld"&gt;The funny property&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;!-- results in a setSomeList(java.util.List) call --&gt;
        &lt;property name="someList"&gt;
            &lt;list&gt;
                &lt;value&gt;a list element followed by a reference&lt;/value&gt;
                &lt;ref bean="myDataSource"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
        &lt;property name="someMap"&gt;
            &lt;map&gt;
                &lt;entry key="yup an entry"&gt;
                    &lt;value&gt;just some string&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry key="yup a ref"&gt;
                    &lt;ref bean="myDataSource"/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
        &lt;property name="someSet"&gt;
            &lt;set&gt;
                &lt;value&gt;just some string&lt;/value&gt;
                &lt;ref bean="myDataSource"/&gt;
            &lt;/set&gt;
        &lt;/property&gt;

    &lt;/bean&gt;
&lt;/beans&gt;</pre><p><span class="emphasis"><em>Note that the value of a Map entry, or a set value, can
      also again be any of the elements:</em></span></p><pre class="programlisting">(bean | ref | idref | list | set | map | props | value | null)</pre><p>A <tt class="literal">bean</tt> element inside the
      <tt class="literal">property</tt> element is used to define a bean value
      inline, instead of referring to a bean defined elsewhere in the
      BeanFactory. The inline bean definition does not need to have any id
      defined. </p><pre class="programlisting">&lt;bean id="outer" class="..."&gt;
    &lt;!-- Instead of using a reference to target, just use an inner bean --&gt;
    &lt;property name="target"&gt;
        &lt;bean class="com.mycompany.PersonImpl"&gt;
            &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
            &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
        &lt;/bean&gt;
   &lt;/property&gt;
&lt;/bean&gt;</pre><p>An idref element is simply a shorthand and
      error-proof way to set a property to the String <span class="emphasis"><em>id</em></span>
      or <span class="emphasis"><em>name</em></span> of another bean in the
      container.</p><pre class="programlisting">&lt;bean id="theTargetBean" class="..."&gt;
&lt;/bean&gt;
&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;idref bean="theTargetBean"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>This is exactly equivalent at runtime to the
      following fragment:</p><pre class="programlisting">&lt;bean id="theTargetBean" class="..."&gt;
&lt;/bean&gt;
&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;value&gt;theTargetBean&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>The main reason the first form is preferable to
      the second is that using the <tt class="literal">idref</tt> tag will allow
      Spring to validate at deployment time that the other bean actually
      exists. In the second variation, the class who's
      <span class="emphasis"><em>targetName</em></span> property is forced to do its own
      validation, and that will only happen when that class is actually
      instantiated by Spring, possibly long after the container is actually
      deployed.</p><p>Additionally, if the bean being referred to is in the same actual
      XML file, and the bean name is the bean <span class="emphasis"><em>id</em></span>, the
      <tt class="literal">local</tt> attribute may be used, which will allow the XML
      parser itself to validate the bean name even earlier, at XML document
      parse time.</p><pre class="programlisting">    &lt;property name="targetName"&gt;
        &lt;idref local="theTargetBean"/&gt;
    &lt;/property&gt;</pre><p>The <tt class="literal">ref</tt> element is the final element allowed
      inside a <tt class="literal">property</tt> definition element. It is used to
      set the value of the specified property to be a reference to another
      bean managed by the container, a collaborator, so to speak. As mentioned
      in a previous section, the referred-to bean is considered to be a
      dependency of the bean who's property is being set, and will be
      initialized on demand as needed (if it is a singleton bean it may have
      already been initialized by the container) before the property is set.
      All references are ultimately just a reference to another object, but
      there are 3 variations on how the id/name of the other object may be
      specified, which determines how scoping and validation is
      handled.</p><p>Specifying the target bean by using the <tt class="literal">bean</tt>
      attribute of the <tt class="literal">ref</tt> tag is the most general form,
      and will allow creating a reference to any bean in the same
      BeanFactory/ApplicationContext (whether or not in the same XML file), or
      parent BeanFactory/ApplicationContext. The value of the
      <tt class="literal">bean</tt> attribute may be the same as either the
      <tt class="literal">id</tt> attribute of the target bean, or one of the values
      in the <tt class="literal">name</tt> attribute of the target
      bean.</p><pre class="programlisting">    &lt;ref bean="someBean"/&gt;</pre><p>Specifying the target bean by using the <tt class="literal">local</tt>
      attribute leverages the ability of the XML parser to validate XML id
      references within the same file. The value of the
      <tt class="literal">local</tt> attribute must be the same as the
      <tt class="literal">id</tt> attribute of the target bean. The XML parser will
      issue an error if no matching element is found in the same file. As
      such, using the local variant is the best choice (in order to know about
      errors are early as possible) if the target bean is in the same XML
      file.</p><pre class="programlisting">    &lt;ref local="someBean"/&gt;</pre><p>Specifying the target bean by using the <tt class="literal">parent</tt>
      attribute allows a reference to be created to a bean which is in a
      parent BeanFactory (or ApplicationContext) of the current BeanFactory
      (or ApplicationContext). The value of the <tt class="literal">parent</tt>
      attribute may be the same as either the <tt class="literal">id</tt> attribute
      of the target bean, or one of the values in the <tt class="literal">name</tt>
      attribute of the target bean, and the target bean must be in a parent
      BeanFactory or ApplicationContext to the current one. The main use of
      this bean reference variant is when there is a need to wrap an existing
      bean in a parent context with some sort of proxy (which may have the
      same name as the parent), and needs the original object so it may wrap
      it. </p><pre class="programlisting">    &lt;ref parent="someBean"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-method-injection"></a>3.3.4.&nbsp;Method Injection</h3></div></div><div></div></div><p>For most users, the majority of the beans in the container will be
      singletons. When a singleton bean needs to collaborate with (use)
      another singleton bean, or a non-singleton bean needs to collaborate
      with another non-singleton bean, the typical and common approach of
      handling this dependency by defining one bean to be a property of the
      other, is quite adequate. There is however a problem when the bean
      lifecycles are different. Consider a singleton bean A which needs to use
      a non-singleton (prototype) bean B, perhaps on each method invocation on
      A. The container will only create the singleton bean A once, and thus
      only get the opportunity to set its properties once. There is no
      opportunity for the container to provide bean A with a new instance of
      bean B every time one is needed.</p><p>One solution to this problem is to forgo some inversion of
      control. Bean A can be aware of the container (as described <a href="#beans-factory-aware-beanfactoryaware" title="3.4.2.1.&nbsp;BeanFactoryAware">here</a>) by
      implementing<tt class="literal"> BeanFactoryAware</tt>, and use programmatic
      means (as described <a href="#beans-factory-client" title="3.6.&nbsp;Interacting with the BeanFactory">here</a>) to
      ask the container via a <tt class="literal">getBean("B")</tt> call for (a new)
      bean B every time it needs it. This is generally not a desirable
      solution since the bean code is then aware of and coupled to
      Spring.</p><p>Method Injection, an advanced feature of the BeanFactory, allows
      this use case to be handled in a clean fashion, along with some other
      scenarios.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e957"></a>3.3.4.1.&nbsp;Lookup method Injection</h4></div></div><div></div></div><p>Lookup method injection refers to the ability of the container
        to override abstract or concrete methods on managed beans in the
        container, to return the result of looking up another named bean in
        the container. The lookup will typically be of a non-singleton bean as
        per the scenario described above (although it can also be a
        singleton). Spring implements this through a dynamically generated
        subclass overriding the method, using bytecode generation via the
        CGLIB library.</p><p>In the client class containing the method to be injected, the
        method definition must be an abstract (or concrete) definition in this
        form:</p><pre class="programlisting">protected abstract SingleShotHelper createSingleShotHelper();</pre><p>If the method is not abstract, Spring will simply override the
        existing implementation. In the XmlBeanFactory case, you instruct
        Spring to inject/override this method to return a particular bean from
        the container, by using the <tt class="literal">lookup-method</tt> element
        inside the bean definition. For example:</p><pre class="programlisting">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id="singleShotHelper class="..." singleton="false"&gt;
&lt;/bean&gt;

&lt;!-- myBean uses singleShotHelper --&gt;
&lt;bean id="myBean" class="..."&gt;
  &lt;lookup-method name="createSingleShotHelper"
                 bean="singleShotHelper"/&gt;
  &lt;property&gt;
    ...
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The bean identified as <span class="emphasis"><em>myBean</em></span> will call its
        own method <tt class="literal">createSingleShotHelper</tt> whenever it needs
        a new instance of the <span class="emphasis"><em>singleShotHelper</em></span> bean. It
        is important to note that the person deploying the beans must be
        careful to deploy <span class="emphasis"><em>singleShotHelper</em></span> as a
        non-singleton (if that is actually what is needed). If it is deployed
        as a singleton (either explicitly, or relying on the default
        <span class="emphasis"><em>true</em></span> setting for this flag), the same instance of
        singleShotHelper will be returned each time!</p><p>Note that lookup method injection can be combined with
        Constructor Injection (supplying optional constructor arguments to the
        bean being constructed), and also with Setter Injection (settings
        properties on the bean being constructed).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e993"></a>3.3.4.2.&nbsp;Arbitrary method replacement</h4></div></div><div></div></div><p>A less commonly useful form of method injection than Lookup
        Method Injection is the ability to replace arbitrary methods in a
        managed bean with another method implementation. Users may safely skip
        the rest of this section (which describes this somewhat advanced
        feature), until this functionality is actually needed.</p><p>In an XmlBeanFactory, the <tt class="literal">replaced-method</tt>
        element may be used to replace an existing method implementation with
        another, for a deployed bean. Consider the following class, with a
        method computeValue, which we want to override:</p><pre class="programlisting">...
public class MyValueCalculator {
  public String computeValue(String input) {
    ... some real code
  }

  ... some other methods
}</pre><p>A class implementing the
        <tt class="literal">org.springframework.beans.factory.support.MethodReplacer</tt>
        interface is needed to provide the new method
        definition.</p><pre class="programlisting">/** meant to be used to override the existing computeValue
    implementation in MyValueCalculator */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ... 
        return ...;
}</pre><p>The BeanFactory deployment definition to deploy the original
        class and specify the method override would look like:</p><pre class="programlisting">&lt;bean id="myValueCalculator class="x.y.z.MyValueCalculator"&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplaceMentComputeValue"&gt;
&lt;/bean&gt;</pre><p>One or more contained
        <tt class="literal">arg-type</tt> elements within the
        <tt class="literal">replaced-method</tt> element may be used to indicate the
        method signature of the method being overridden. Note that the
        signature for the arguments is actually only needed in the case that
        the method is actually overloaded and there are multiple variants
        within the class. For convenience, the type string for an argument may
        be a substring of the fully qualified type name. For example, all the
        following would match
        <span class="emphasis"><em>java.lang.String</em></span>.</p><pre class="programlisting">    java.lang.String
    String
    Str</pre><p>Since the number of arguments is often enough to
        distinguish between each possible choice, this shortcut can save a lot
        of typing, by just using the shortest string which will match an
        argument.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependson"></a>3.3.5.&nbsp;Using <tt class="literal">depends-on</tt></h3></div></div><div></div></div><p>For most situations, the fact that a bean is a dependency of
      another is expressed simply by the fact that one bean is set as a
      property of another. This is typically done with the
      <tt class="literal">ref</tt> element in the XmlBeanFactory. In a variation of
      this, sometimes a bean which is aware of the container is simply given
      the id of its dependency (using a string value or alternately the
      <tt class="literal">idref</tt> element, which evaluates the same as a string
      value). The first bean then programmatically asks the container for its
      dependency. In either case, the dependency is properly initialized
      before the dependent bean.</p><p>For the relatively infrequent situations where dependencies
      between beans are less direct (for example, when a static initializer in
      a class needs to be triggered, such as database driver registration),
      the <tt class="literal">depends-on</tt> element may be used to explicitly
      force one or more beans to be initialized before the bean using this
      element is initialized.</p><p>Following is an example configuration:</p><pre class="programlisting">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"&gt;
    &lt;property name="manager"&gt;&lt;ref local="manager"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-autowire"></a>3.3.6.&nbsp;Autowiring collaborators</h3></div></div><div></div></div><p>A BeanFactory is able to <span class="emphasis"><em>autowire</em></span>
      relationships between collaborating beans. This means it's possible to
      automatically let Spring resolve collaborators (other beans) for your
      bean by inspecting the contents of the BeanFactory. The autowiring
      functionality has five modes. Autowiring is specified
      <span class="emphasis"><em>per</em></span> bean and can thus be enabled for some beans,
      while other beans won't be autowired. Using autowiring, it is possible
      to reduce or eliminate the need to specify properties or constructor
      arguments, saving a significant amount of typing.<sup>[<a name="d0e1062" href="#ftn.d0e1062">1</a>]</sup>In an XmlBeanFactory, the autowire mode for a bean
      definition is specified by using the <tt class="literal">autowire</tt>
      attribute of the bean element. The following values are allowed.</p><div class="table"><a name="d0e1070"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Autowiring modes</b></p><table summary="Autowiring modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>no</td><td>No autowiring at all. Bean references must be defined
                via a <tt class="literal">ref</tt> element. This is the default, and
                changing this is discouraged for larger deployments, since
                explicitly specifying collaborators gives greater control and
                clarity. To some extent, it is a form of documentation about
                the structure of a system.</td></tr><tr><td>byName</td><td>Autowiring by property name. This option will inspect
                the BeanFactory and look for a bean named exactly the same as
                the property which needs to be autowired. For example, if you
                have a bean definition which is set to autowire by name, and
                it contains a <span class="emphasis"><em>master</em></span> property (that is,
                it has a <span class="emphasis"><em>setMaster</em></span>(...) method), Spring
                will look for a bean definition named master, and use it to
                set the property.</td></tr><tr><td>byType</td><td>Allows a property to be autowired if there is exactly
                one bean of the property type in the BeanFactory. If there is
                more than one, a fatal exception is thrown, and this indicates
                that you may not use <span class="emphasis"><em>byType</em></span> autowiring
                for that bean. If there are no matching beans, nothing
                happens; the property is not set. If this is not desirable,
                setting the <tt class="literal">dependency-check="objects"</tt>
                attribute value specifies that an error should be thrown in
                this case.</td></tr><tr><td>constructor</td><td>This is analogous to <span class="emphasis"><em>byType</em></span>, but
                applies to constructor arguments. If there isn't exactly one
                bean of the constructor argument type in the bean factory, a
                fatal error is raised.</td></tr><tr><td>autodetect</td><td>Chooses <span class="emphasis"><em>constructor</em></span> or
                <span class="emphasis"><em>byType</em></span> through introspection of the bean
                class. If a default constructor is found, byType gets
                applied.</td></tr></tbody></table></div><p>Note that explicit dependencies in <tt class="literal">property</tt> and
      <tt class="literal">constructor-arg</tt> elements always override autowiring.
      Autowire behavior can be combined with dependency checking, which will
      be performed after all autowiring has been
      completed.<span class="emphasis"><em></em></span></p><p>It's important to understand the pros and cons around autowiring.
      Some advantages of autowiring:</p><div class="itemizedlist"><ul type="disc"><li><p>It can significantly reduce the volume of configuration
          required. (However, mechanisms such as the use of a configuration
          "template," discussed elsewhere in this chapter, are also valuable
          here.)</p></li><li><p>It can cause configuration to keep itself up to date as your
          objects evolve. For example, if you need to add an additional
          dependency to a class, that dependency can be satisfied
          automatically without the need to modify configuration. Thus there
          may be a strong case for autowiring during development, without
          ruling out the option of switching to explicit wiring when the code
          base becomes more stable.</p></li></ul></div><p>Some disadvantages of autowiring:</p><div class="itemizedlist"><ul type="disc"><li><p>It's more magical than explicit wiring. Although, as noted in
          the above table, Spring is careful to avoid guessing in case of
          ambiguity which might have unexpected results, the relationships
          between your Spring-managed objects is no longer explicitly
          documented.</p></li><li><p>Wiring information may not be available to tools that may
          generate documentation from a Spring application context.</p></li><li><p>Autowiring by type will only work when there is a single bean
          definition of the type specified by the setter method or constructor
          argument. You need to use explicit wiring if there is any potential
          ambiguity.</p></li></ul></div><p>There is no "wrong" or "right" answer in all cases. We recommend a
      degree of consistency across a project. For example, if autowiring is
      not used in general, it might be confusing to developers to use it just
      to one or two bean definitions.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependencies"></a>3.3.7.&nbsp;Checking for dependencies</h3></div></div><div></div></div><p>Spring has the ability to try to check for the existence of
      unresolved dependencies of a bean deployed into the BeanFactory. These
      are JavaBeans properties of the bean, which do not have actual values
      set for them in the bean definition, or alternately provided
      automatically by the autowiring feature.</p><p>This feature is sometimes useful when you want to ensure that all
      properties (or all properties of a certain type) are set on a bean. Of
      course, in many cases a bean class will have default values for many
      properties, or some properties do not apply to all usage scenarios, so
      this feature is of limited use. Dependency checking can also be enabled
      and disabled per bean, just as with the autowiring functionality. The
      default is to <span class="emphasis"><em>not</em></span> check dependencies. Dependency
      checking can be handled in several different modes. In an
      XmlBeanFactory, this is specified via the
      <tt class="literal">dependency-check</tt> attribute in a bean definition,
      which may have the following values.</p><div class="table"><a name="d0e1177"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Dependency checking modes</b></p><table summary="Dependency checking modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>none</td><td>No dependency checking. Properties of the bean which
                have no value specified for them are simply not set.</td></tr><tr><td>simple</td><td>Dependency checking is performed for primitive types
                and collections (everything except collaborators, i.e. other
                beans)</td></tr><tr><td>object</td><td>Dependency checking is performed for
                collaborators</td></tr><tr><td>all</td><td>Dependency checking is done for collaborators,
                primitive types and collections</td></tr></tbody></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-nature"></a>3.4.&nbsp;Customizing the nature of a bean</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lifecycle"></a>3.4.1.&nbsp;Lifecycle interfaces</h3></div></div><div></div></div><p>Spring provides several marker interfaces to change the behavior
      of your bean in the BeanFactory. They include
      <tt class="literal">InitializingBean</tt> and
      <tt class="literal">DisposableBean</tt>. Implementing these interfaces will
      result in the BeanFactory calling
      <tt class="literal">afterPropertiesSet()</tt> for the former and
      <tt class="literal">destroy()</tt> for the latter to allow the bean to perform
      certain actions upon initialization and destruction.</p><p>Internally, Spring uses <tt class="literal">BeanPostProcessors</tt> to
      process any marker interfaces it can find and call the appropriate
      methods. If you need custom features or other lifecycle behavior Spring
      doesn't offer out-of-the-box, you can implement a
      <tt class="literal">BeanPostProcessor</tt> yourself. More information about
      this can be found in <a href="#beans-factory-customizing" title="3.7.&nbsp;Customizing beans with BeanPostprocessors">Section&nbsp;3.7, &#8220;Customizing beans with BeanPostprocessors&#8221;</a>.</p><p>All the different lifecycle marker interfaces are described below.
      In one of the appendices, you can find diagram that show how Spring
      manages beans and how those lifecycle features change the nature of your
      beans and how they are managed.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-initializingbean"></a>3.4.1.1.&nbsp;InitializingBean / <tt class="literal">init-method</tt></h4></div></div><div></div></div><p>Implementing the
        <tt class="literal">org.springframework.beans.factory.InitializingBean</tt>
        allows a bean to perform initialization work after all necessary
        properties on the bean are set by the BeanFactory. The
        InitializingBean interface specifies exactly one
        method:</p><pre class="programlisting">    * Invoked by a BeanFactory after it has set all bean properties supplied
    * (and satisfied BeanFactoryAware and ApplicationContextAware).
    * &lt;p&gt;This method allows the bean instance to perform initialization only
    * possible when all bean properties have been set and to throw an
    * exception in the event of misconfiguration.
    * @throws Exception in the event of misconfiguration (such
    * as failure to set an essential property) or if initialization fails.
    */
    void afterPropertiesSet() throws Exception;</pre><p><span class="emphasis"><em>Note: generally, the use of the
        <tt class="literal">InitializingBean</tt> marker interface can be avoided
        (and is discouraged since it unnecessarily couples the code to
        Spring). A bean definition provides support for a generic
        initialization method to be specified. In the case of the
        XmlBeanFactory, this is done via the <tt class="literal">init-method</tt>
        attribute. For example, the following definition:</em></span></p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;

public class ExampleBean {
    public void init() {
        // do some initialization work
    }
}</pre><p>Is exactly the same as: </p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;

public class AnotherExampleBean implements InitializingBean {
    public void afterPropertiesSet() {
        // do some initialization work
    }
}</pre><p>but does not couple the code to Spring.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-disposablebean"></a>3.4.1.2.&nbsp;DisposableBean / <tt class="literal">destroy-method</tt></h4></div></div><div></div></div><p>Implementing the
        <tt class="literal">org.springframework.beans.factory.DisposableBean</tt>
        interface allows a bean to get a callback when the BeanFactory
        containing it is destroyed. The DisposableBean interface specifies one
        method: </p><pre class="programlisting">    /**
    * Invoked by a BeanFactory on destruction of a singleton.
    * @throws Exception in case of shutdown errors.
    * Exceptions will get logged but not re-thrown to allow
    * other beans to release their resources too.
    */
    void destroy() throws Exception;
</pre><p><span class="emphasis"><em>Note: generally, the use of the
        <tt class="literal">DisposableBean</tt> marker interface can be avoided (and
        is discouraged since it unnecessarily couples the code to Spring). A
        bean definition provides support for a generic destroy method to be
        specified. In the case of the XmlBeanFactory, this is done via the
        <tt class="literal">destroy-method</tt> attribute. For example, the
        following definition: </em></span></p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;

public class ExampleBean {
    public void cleanup() {
        // do some destruction work (like closing connection)
    }
}</pre><p> Is exactly the same as: </p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;

public class AnotherExampleBean implements DisposableBean {
    public void destroy() {
        // do some destruction work
    }
}</pre><p>but does not couple the code to Spring.</p><p><span class="emphasis"><em>Important note: when deploying a bean in the prototype
        mode, the lifecycle of the bean changes slightly. By definition,
        Spring cannot manage the complete lifecycle of a
        non-singleton/prototype bean, since after it is created, it is given
        to the client and the container does not keep track of it at all any
        longer. You can think of Spring's role when talking about a
        non-singleton/prototype bean as a replacement for the 'new' operator.
        Any lifecycle aspects past that point have to be handled by the
        client. The lifecycle of a bean in the BeanFactory is further
        described in <a href="#beans-factory-lifecycle" title="3.4.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.4.1, &#8220;Lifecycle interfaces&#8221;</a></em></span>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-aware"></a>3.4.2.&nbsp;Knowing who you are</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beanfactoryaware"></a>3.4.2.1.&nbsp;BeanFactoryAware</h4></div></div><div></div></div><p>A class which implements the
        <tt class="literal">org.springframework.beans.factory.BeanFactoryAware</tt>
        interface is provided with a reference to the BeanFactory that created
        it, when it is created by that BeanFactory.</p><pre class="programlisting">public interface BeanFactoryAware {
   /**
    * Callback that supplies the owning factory to a bean instance.
    * &lt;p&gt;Invoked after population of normal bean properties but before an init
    * callback like InitializingBean's afterPropertiesSet or a custom init-method.
    * @param beanFactory owning BeanFactory (may not be null).
    * The bean can immediately call methods on the factory.
    * @throws BeansException in case of initialization errors
    * @see BeanInitializationException
    */
    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}</pre><p>This allows beans to manipulate the BeanFactory that created
        them programmatically, through the
        <tt class="literal">org.springframework.beans.factory.BeanFactory</tt>
        interface, or by casting the reference to a known subclass of this
        which exposes additional functionality. Primarily this would consist
        of programmatic retrieval of other beans. While there are cases when
        this capability is useful, it should generally be avoided, since it
        couples the code to Spring, and does not follow the Inversion of
        Control style, where collaborators are provided to beans as
        properties.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beannameaware"></a>3.4.2.2.&nbsp;BeanNameAware</h4></div></div><div></div></div><p>If a bean implements the
        <tt class="literal">org.springframework.beans.factory.BeanNameAware</tt>
        interface and is deployed in a BeanFactory, the BeanFactory will call
        the bean through this interface to inform the bean of the
        <span class="emphasis"><em>id</em></span> it was deployed under. The callback will be
        Invoked after population of normal bean properties but before an init
        callback like <tt class="literal">InitializingBean</tt>'s
        <span class="emphasis"><em>afterPropertiesSet</em></span> or a custom
        init-method.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lifecycle-factorybean"></a>3.4.3.&nbsp;FactoryBean</h3></div></div><div></div></div><p>The
      <tt class="literal">org.springframework.beans.factory.FactoryBean</tt>
      interface is to be implemented by objects that <span class="emphasis"><em>are themselves
      factories</em></span>. The BeanFactory interface provides three method:
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">Object getObject()</tt>: has to return an
            instance of the object this factory creates. The instance can
            possibly be shared (depending on whether this factory returns
            singletons or prototypes).</p></li><li><p><tt class="literal">boolean isSingleton()</tt>: has to return
            <span class="emphasis"><em>true</em></span> if this FactoryBean returns singletons,
            <span class="emphasis"><em>false</em></span> otherwise</p></li><li><p><tt class="literal">Class getObjectType()</tt>: has to return
            either the object type returned by the
            <tt class="literal">getObject()</tt> method or <tt class="literal">null</tt>
            if the type isn't known in advance</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-child-bean-definitions"></a>3.5.&nbsp;Abstract and child bean definitions</h2></div></div><div></div></div><p>A bean definition potentially contains a large amount of
    configuration information, including container specific information (i.e.
    initialization method, static factory method name, etc.) and constructor
    arguments and property values. A child bean definition is a bean
    definition which inherits configuration data from a parent definition. It
    is then able to override some values, or add others, as needed. Using
    parent and child bean definitions can potentially save a lot of typing.
    Effectively, this is a form of templating.</p><p>When working with a BeanFactory programmatically, child bean
    definitions are represented by the <tt class="literal">ChildBeanDefinition</tt>
    class. Most users will never work with them on this level, instead
    configuring bean definitions declaratively in something like the
    XmlBeanFactory. In an XmlBeanFactory bean definition, a child bean
    definition is indicated simply by using the <tt class="literal">parent</tt>
    attribute, specifying the parent bean as the value of this
    attribute.</p><pre class="programlisting">&lt;bean id="inheritedTestBean" abstract="true"
    class="org.springframework.beans.TestBean"&gt;
    &lt;property name="name"&gt;&lt;value&gt;parent&lt;/value&gt;&lt;/property&gt;
    &lt;property name="age"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass" class="org.springframework.beans.DerivedTestBean"
      parent="inheritedTestBean" init-method="initialize"&gt;
    &lt;property name="name"&gt;&lt;value&gt;override&lt;/value&gt;&lt;/property&gt;
    &lt;!-- age should inherit value of 1 from parent --&gt;
  &lt;/bean&gt;</pre><p>A child bean definition will use the bean class from the parent
    definition if none is specified, but can also override it. In the latter
    case, the child bean class must be compatible with the parent, i.e. it
    must accept the parent's property values.</p><p>A child bean definition will inherit constructor argument values,
    property values and method overrides from the parent, with the option to
    add new values. If init method, destroy method and/or static factory
    method are specified, they will override the corresponding parent
    settings.</p><p>The remaining settings will <span class="emphasis"><em>always</em></span> be taken
    from the child definition: <span class="emphasis"><em>depends on</em></span>,
    <span class="emphasis"><em>autowire mode</em></span>, <span class="emphasis"><em>dependency check</em></span>,
    <span class="emphasis"><em>singleton</em></span>, <span class="emphasis"><em>lazy init</em></span>.</p><p>Note that in the example above, we have explicitly marked the parent
    bean definition as <span class="emphasis"><em>abstract</em></span> by using the
    <span class="emphasis"><em>abstract</em></span> attribute. In the case that the parent
    definition does not specify a class:</p><pre class="programlisting">&lt;bean id="inheritedTestBeanWithoutClass"&gt;
    &lt;property name="name"&gt;&lt;value&gt;parent&lt;/value&gt;&lt;/property&gt;
    &lt;property name="age"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
      parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
    &lt;property name="name"&gt;&lt;value&gt;override&lt;/value&gt;&lt;/property&gt;
    &lt;!-- age should inherit value of 1 from parent --&gt;
&lt;/bean&gt;</pre><p>the parent bean cannot get instantiated on its own since it is
    incomplete, and it's also considered abstract. When a definition is
    considered abstract like this (explicitly or implicitly), it's usable just
    as a pure template or abstract bean definition that will serve as parent
    definition for child definitions. Trying to use such an abstract parent
    bean on its own (by referring to it as a ref property of another bean, or
    doing an explicit getBean() call with the parent bean id, will result in
    an error. Similarly, the container's internal
    <span class="emphasis"><em>preInstantiateSingletons</em></span> method will completely
    ignore bean definitions which are considered abstract.</p><p><span class="emphasis"><em>Important Note</em></span>: Application contexts (but not
    simple bean factories) will by default pre-instantiate all singletons.
    Therefore it is important (at least for singleton beans) that if you have
    a (parent) bean definition which you intend to use only as a template, and
    this definition specifies a class, you must make sure to set the
    <span class="emphasis"><em>abstract</em></span> attribute to <span class="emphasis"><em>true</em></span>,
    otherwise the application context will actually pre-instantiate it.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-client"></a>3.6.&nbsp;Interacting with the BeanFactory</h2></div></div><div></div></div><p>A BeanFactory is essentially nothing more than the interface for an
    advanced factory capable of maintaining a registry of different beans and
    their dependencies. The BeanFactory enables you to read bean definitions
    and access them using the bean factory. When using just the BeanFactory
    you would create one and read in some bean definitions in the XML format
    as follows: </p><pre class="programlisting">InputStream is = new FileInputStream("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);</pre><p>Basically that's all there is to it. Using
    <tt class="literal">getBean(String)</tt> you can retrieve instances of your
    beans. You'll get a reference to the same bean if you defined it as a
    singleton (the default) or you'll get a new instance each time if you set
    <tt class="literal">singleton</tt> to <span class="emphasis"><em>false</em></span>. The
    client-side view of the BeanFactory is surprisingly simple. The
    <tt class="literal">BeanFactory</tt> interface has only five methods for clients
    to call: </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">boolean containsBean(String)</tt>: returns true
          if the BeanFactory contains a bean definition or bean instance that
          matches the given name</p></li><li><p><tt class="literal">Object getBean(String)</tt>: returns an instance
          of the bean registered under the given name. Depending on how the
          bean was configured by the BeanFactory configuration, either a
          singleton and thus shared instance or a newly created bean will be
          returned. A <tt class="literal">BeansException</tt> will be thrown when
          either the bean could not be found (in which case it'll be a
          <tt class="literal">NoSuchBeanDefinitionException</tt>), or an exception
          occurred while instantiating and preparing the bean</p></li><li><p><tt class="literal">Object getBean(String,Class)</tt>: returns a
          bean, registered under the given name. The bean returned will be
          cast to the given Class. If the bean could not be cast,
          corresponding exceptions will be thrown
          (<tt class="literal">BeanNotOfRequiredTypeException</tt>). Furthermore,
          all rules of the getBean(String) method apply (see above)</p></li><li><p><tt class="literal">boolean isSingleton(String)</tt>: determines
          whether or not the bean definition or bean instance registered under
          the given name is a singleton or a prototype. If no bean
          corresponding to the given name could not be found, an exception
          will be thrown
          (<tt class="literal">NoSuchBeanDefinitionException</tt>)</p></li><li><p><tt class="literal">String[] getAliases(String)</tt>: Return the
          aliases for the given bean name, if any were defined in the bean
          definition</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1500"></a>3.6.1.&nbsp;Obtaining a FactoryBean, not its product</h3></div></div><div></div></div><p>Sometimes there is a need to ask a BeanFactory for an actual
      FactoryBean instance itself, not the bean it produces. This may be done
      by prepending the bean id with <tt class="literal">&amp;</tt> when calling the
      <tt class="methodname">getBean</tt> method of BeanFactory (including
      ApplicationContext). So for a given FactoryBean with an id
      <tt class="literal">myBean</tt>, invoking <tt class="literal">getBean("myBean")</tt>
      on the BeanFactory will return the product of the FactoryBean, but
      invoking <tt class="literal">getBean("&amp;myBean")</tt> will return the
      FactoryBean instance itself.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-customizing"></a>3.7.&nbsp;Customizing beans with BeanPostprocessors</h2></div></div><div></div></div><p>A bean post-processor is a java class which implements the
    <tt class="literal">org.springframework.beans.factory.config.BeanPostProcessor</tt>
    interface, which consists of two callback methods. When such a class is
    registered as a post-processor with the BeanFactory, for each bean
    instance that is created by the BeanFactory, the post-processor will get a
    callback from the BeanFactory before any initialization methods
    (<span class="emphasis"><em>afterPropertiesSet</em></span> and any declared init method) are
    called, and also afterwords. The post-processor is free to do what it
    wishes with the bean, including ignoring the callback completely. A bean
    post-processor will typically check for marker interfaces, or do something
    such as wrap a bean with a proxy. Some Spring helper classes are
    implemented as bean post-processors.</p><p>It is important to know that a BeanFactory treats bean
    post-processors slightly differently than an ApplicationContext. An
    ApplicationContext will automatically detect any beans which are deployed
    into it which implement the <tt class="literal">BeanPostProcessor</tt>
    interface, and register them as post-processors, to be then called
    appropriately by the factory on bean creation. Nothing else needs to be
    done other than deploying the post-processor in a similar fashion to any
    other bean. On the other hand, when using plain BeanFactories, bean
    post-processors have to manually be <span class="emphasis"><em>explicitly</em></span>
    registered, with a code sequence such as the following:</p><pre class="programlisting">ConfigurableBeanFactory bf = new .....;     // create BeanFactory
   ...                       // now register some beans
// now register any needed BeanPostProcessors
MyBeanPostProcessor pp = new MyBeanPostProcessor();
bf.addBeanPostProcessor(pp);

// now start using the factory
  ...</pre><p>Since this manual registration step is not convenient, and
    ApplictionContexts are functionally supersets of BeanFactories, it is
    generally recommended that ApplicationContext variants are used when bean
    post-processors are needed.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-customizing-factory-postprocessors"></a>3.8.&nbsp;Customizing bean factories with BeanFactoryPostprocessors</h2></div></div><div></div></div><p>A bean factory post-processor is a java class which implements the
    <tt class="literal">org.springframework.beans.factory.config.BeanFactoryPostProcessor</tt>
    interface. It is executed manually (in the case of the BeanFactory) or
    automatically (in the case of the ApplicationContext) to apply changes of
    some sort to an entire BeanFactory, after it has been constructed. Spring
    includes a number of pre-existing bean factory post-processors, such as
    <tt class="literal">PropertyResourceConfigurer</tt> and
    <tt class="literal">PropertyPlaceHolderConfigurer</tt>, both described below,
    and <tt class="literal">BeanNameAutoProxyCreator</tt>, very useful for wrapping
    other beans transactionally or with any other kind of proxy, as described
    later in this manual. The BeanFactoryPostProcessor can be used to add
    custom editors (as also mentioned in <a href="#beans-beanfactory-customeditors" title="3.9.&nbsp;Registering additional custom PropertyEditors">Section&nbsp;3.9, &#8220;Registering additional custom PropertyEditors&#8221;</a>).</p><p>In a BeanFactory, the process of applying a BeanFactoryPostProcessor
    is manual, and will be similar to this:</p><pre class="programlisting">XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
// create placeholderconfigurer to bring in some property
// values from a Properties file
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));
// now actually do the replacement
cfg.postProcessBeanFactory(factory);</pre><p><a name="beans-factory-autodetect-beanfactorypostprocessors"></a>An
    ApplicationContext will detect any beans which are deployed into it which
    implement the <tt class="literal">BeanFactoryPostProcessor</tt> interface, and
    automatically use them as bean factory post-processors, at the appropriate
    time. Nothing else needs to be done other than deploying these
    post-processor in a similar fashion to any other bean.</p><p>Since this manual step is not convenient, and ApplictionContexts are
    functionally supersets of BeanFactories, it is generally recommended that
    ApplicationContext variants are used when bean factory post-processors are
    needed.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-placeholderconfigurer"></a>3.8.1.&nbsp;The <tt class="literal">PropertyPlaceholderConfigurer</tt></h3></div></div><div></div></div><p>The <tt class="literal">PropertyPlaceholderConfigurer</tt>, implemented
      as a bean factory post-processor, is used to externalize some property
      values from a BeanFactory definition, into another separate file in Java
      Properties format. This is useful to allow the person deploying an
      application to customize some key properties (for example database URLs,
      usernames and passwords), without the complexity or risk of modifying
      the main XML definition file or files for the BeanFactory.</p><p>Consider a fragment from a BeanFactory definition, where a
      DataSource with placeholder values is defined:</p><p>In the example below, a datasource is defined, and we will
      configure some properties from an external Properties file. At runtime,
      we will apply a <tt class="literal">PropertyPlaceholderConfigurer</tt> to the
      BeanFactory which will replace some properties of the datasource:</p><pre class="programlisting">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName"&gt;&lt;value&gt;${jdbc.driverClassName}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="url"&gt;&lt;value&gt;${jdbc.url}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="username"&gt;&lt;value&gt;${jdbc.username}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="password"&gt;&lt;value&gt;${jdbc.password}&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The actual values come from another file in Properties
      format:</p><pre class="programlisting">jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre><p>To use this with a BeanFactory, the bean factory post-processor is
      manually executed on it:</p><pre class="programlisting">XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));
cfg.postProcessBeanFactory(factory);</pre><p>Note that ApplicationContexts are able to automatically recognize
      and apply beans deployed in them which implement
      BeanFactoryPostProcessor. This means that as described here, applying
      PropertyPlaceholderConfiguer is much more convenient when using an
      ApplicationContext. For this reason, it is recommended that users
      wishing to use this or other bean factory postprocessors use an
      ApplicationContext instead of a BeanFactory.</p><p>The <tt class="literal">PropertyPlaceHolderConfigurer</tt> doesn't only
      look for properties in the Properties file you specify, but also checks
      against the Java System properties if it cannot find a property you are
      trying to use. This behavior can be customized by setting the
      <tt class="literal">systemPropertiesMode</tt> property of the configurer. It
      has three values, one to tell the configurer to always override, one to
      let it <span class="emphasis"><em>never</em></span> override and one to let it override
      only if the property cannot be found in the properties file specified.
      Please consult the JavaDoc for the PropertiesPlaceholderConfigurer for
      more information.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-overrideconfigurer"></a>3.8.2.&nbsp;The <tt class="literal">PropertyOverrideConfigurer</tt></h3></div></div><div></div></div><p>The <tt class="literal">PropertyOverrideConfigurer</tt>, another bean
      factory post-processor, is similar to the
      <tt class="literal">PropertyPlaceholderConfigurer</tt>, but in contrast to the
      latter, the original definitions can have default values or no values at
      all for bean properties. If an overriding Properties file does not have
      an entry for a certain bean property, the default context definition is
      used.</p><p>Note that the bean factory definition is <span class="emphasis"><em>not</em></span>
      aware of being overridden, so it is not immediately obvious when looking
      at the XML definition file that the override configurer is being used.
      In case that there are multiple PropertyOverrideConfigurers that define
      different values for the same bean property, the last one will win (due
      to the overriding mechanism).</p><p>Properties file configuration lines are expected to be in the
      format:</p><pre class="programlisting"><span class="emphasis"><em>beanName.property=value</em></span></pre><p>An example properties file could look like:</p><pre class="programlisting">dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre><p>This example file would be usable against a BeanFactory definition
      which contains a bean in it called <span class="emphasis"><em>dataSource</em></span>,
      which has <span class="emphasis"><em>driver</em></span> and <span class="emphasis"><em>url</em></span>
      properties.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beanfactory-customeditors"></a>3.9.&nbsp;Registering additional custom PropertyEditors</h2></div></div><div></div></div><p>When setting bean properties as a string value, a BeanFactory
    ultimately uses standard JavaBeans PropertyEditors to convert these
    Strings to the complex type of the property. Spring pre-registers a number
    of custom PropertyEditors (for example, to convert a classname expressed
    as a string into a real Class object). Additionally, Java's standard
    JavaBeans PropertyEditor lookup mechanism allows a PropertyEditor for a
    class to be simply named appropriately and placed in the same package as
    the class it provides support for, to be found automatically.</p><p>If there is a need to register other custom PropertyEditors, there
    are several mechanisms available.</p><p>The most manual approach, which is not normally convenient or
    recommended, is to simply use the
    <tt class="literal">registerCustomEditor()</tt> method of the
    <tt class="literal">ConfigurableBeanFactory</tt> interface, assuming you have a
    BeanFactory reference.</p><p>The more convenient mechanism is to use a special bean factory
    post-processor called <tt class="literal">CustomEditorConfigurer</tt>. Although
    bean factory post-processors can be used semi-manually with BeanFactories,
    this one has a nested property setup, so it is strongly recommended that,
    as described <a href="#beans-applicationcontext-customeditors" title="3.14.&nbsp;Registering additional custom PropertyEditors">here</a>, it is used
    with the ApplicationContext, where it may be deployed in similar fashion
    to any other bean, and automatically detected and applied.</p><p>Note that all bean factories and application contexts automatically
    use a number of built-in property editors, through their use of something
    called a <tt class="literal">BeanWrapper</tt> to handle property conversions.
    The standard property editors that the BeanWrapper registers are listed in
    the next chapter. Additionally, ApplicationContexts also override or add
    an additional 3 editors to handle resource lookups in a manner appropriate
    to the specific application context type. Thee are:
    <tt class="literal">InputStreamEditor</tt>, <tt class="literal">ResourceEditor</tt>
    and <tt class="literal">URLEditor</tt>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beanfactory-alias"></a>3.10.&nbsp;Using the alias element to add aliases for existing beans</h2></div></div><div></div></div><p>In a bean definition itself, you may supply more than one name for
    the bean, by using a combination of up to one name spcified via the
    <tt class="literal">id</tt> attribute, and any number of other names via the
    <tt class="literal">alias</tt> attribute. All these names can be considered
    equivalent aliases to the same bean, and are useful for some situations,
    such as allowing each component used in an application to refer to a
    common dependency using a bean name that is specific to that component
    itslef.</p><p>Having to specify all alias when the bean is actually defined is not
    always adequate however. It is sometimes desirable to introduce an alias
    for a bean which is define elsewhere. This may be done via a standalone
    <tt class="literal">alias</tt> element.</p><p><tt class="literal"> &lt;alias name="fromName"
    alias="toName"/&gt;</tt></p><p>In this case, a bean in the same context which is named
    <tt class="literal">fromName</tt>, may also after the use of this alias
    definition, be referred to as <tt class="literal">toName</tt>.</p><p>As a concrete example, consider the case where component A defines a
    DataSource bean called componentA-dataSource, in its XML fragment.
    Component B would however like to refer to the DataSource as
    componentB-dataSource in its XML fragment. And the main application,
    MyApp, defines its own XML fragment and assembles the final application
    context from all three fragments, and would like to refer to the
    DataSource as myApp-dataSource. This scenario can be easily handled by
    adding to the MyApp XML fragement the following standalone aliases:</p><p><tt class="literal"> </tt><tt class="literal">&lt;alias name="componentA-dataSource"
    alias="componentB-dataSource"/&gt; &lt;alias name="componentA-dataSource"
    alias="myApp-dataSource"/&gt;</tt></p><p>Now each component and the main app can refer to the dataSource via
    a name that is unique and guaranteed not to clash with any other
    definition (effectively there is a namespace), yet they refer to the same
    bean.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-introduction"></a>3.11.&nbsp;Introduction to the <tt class="literal">ApplicationContext</tt></h2></div></div><div></div></div><p>While the <tt class="literal">beans</tt> package provides basic
    functionality for managing and manipulating beans, often in a programmatic
    way, the <tt class="literal">context</tt> package adds <tt class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html" target="_top">ApplicationContext</a></tt>,
    which enhances BeanFactory functionality in a more
    <span class="emphasis"><em>framework-oriented style</em></span>. Many users will use
    ApplicationContext in a completely declarative fashion, not even having to
    create it manually, but instead relying on support classes such as
    ContextLoader to automatically start an ApplicationContext as part of the
    normal startup process of a J2EE web-app. Of course, it is still possible
    to programmatically create an ApplicationContext.</p><p>The basis for the context package is the
    <tt class="literal">ApplicationContext</tt> interface, located in the
    <tt class="literal">org.springframework.context</tt> package. Deriving from the
    BeanFactory interface, it provides all the functionality of BeanFactory.
    To allow working in a more framework-oriented fashion, using layering and
    hierarchical contexts, the context package also provides the following:
    </p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>MessageSource</em></span>, providing access to
          messages in, i18n-style</p></li><li><p><span class="emphasis"><em>Access to resources</em></span>, such as URLs and
          files</p></li><li><p><span class="emphasis"><em>Event propagation</em></span> to beans implementing
          the <tt class="literal">ApplicationListener</tt> interface</p></li><li><p><span class="emphasis"><em>Loading of multiple (hierarchical)
          contexts</em></span>, allowing each to be focused on one particular
          layer, for example the web layer of an application</p></li></ul></div><p>As the ApplicationContext includes all functionality of the
    BeanFactory, it is generally recommended that it be used over the
    BeanFactory, except for a few limited situations such as perhaps in an
    Applet, where memory consumption might be critical, and a few extra
    kilobytes might make a difference. The following sections described
    functionality which ApplicationContext adds to basic BeanFactory
    capabilities.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-functionality"></a>3.12.&nbsp;Added functionality of the
    <tt class="literal">ApplicationContext</tt></h2></div></div><div></div></div><p>As already stated in the previous section, the ApplicationContext
    has a couple of features that distinguish it from the BeanFactory. Let us
    review them one-by-one.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-messagesource"></a>3.12.1.&nbsp;Using the <tt class="literal">MessageSource</tt></h3></div></div><div></div></div><p>The ApplicationContext interface extends an interface called
      <tt class="literal">MessageSource</tt>, and therefore provides messaging (i18n
      or internationalization) functionality. Together with the
      <tt class="literal">NestingMessageSource</tt>, capable of resolving
      hierarchical messages, these are the basic interfaces Spring provides to
      do message resolution. Let's quickly review the methods defined there:
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">String getMessage (String code, Object[] args,
            String default, Locale loc)</tt>: the basic method used to
            retrieve a message from the MessageSource. When no message is
            found for the specified locale, the default message is used. Any
            arguments passed in are used as replacement values, using the
            <tt class="literal">MessageFormat</tt> functionality provided by the
            standard library.</p></li><li><p><tt class="literal">String getMessage (String code, Object[] args,
            Locale loc)</tt>: essentially the same as the previous
            method, but with one difference: no default message can be
            specified; if the message cannot be found, a
            <tt class="literal">NoSuchMessageException</tt> is thrown.</p></li><li><p><tt class="literal">String getMessage(MessageSourceResolvable
            resolvable, Locale locale)</tt>: all properties used in the
            methods above are also wrapped in a class named
            <tt class="literal">MessageSourceResolvable</tt>, which you can use via
            this method.</p></li></ul></div><p>When an ApplicationContext gets loaded, it automatically searches
      for a MessageSource bean defined in the context. The bean has to have
      the name <tt class="literal">messageSource</tt>. If such a bean is found, all
      calls to the methods described above will be delegated to the message
      source that was found. If no message source was found, the
      ApplicationContext attempts to see if it has a parent containing a bean
      with the same name. If so, it uses that bean as the MessageSource. If it
      can't find any source for messages, an empty
      <tt class="literal">StaticMessageSource</tt> will be instantiated in order to
      be able to accept calls to the methods defined above.</p><p>Spring currently provides two <tt class="literal">MessageSource</tt>
      implementations. These are the
      <tt class="literal">ResourceBundleMessageSource</tt> and the
      <tt class="literal">StaticMessageSource</tt>. Both implement
      <tt class="literal">NestingMessageSource</tt> in order to do nested messaging.
      The StaticMessageSource is hardly ever used but provides programmatic
      ways to add messages to the source. The ResourceBundleMessageSource is
      more interesting and is the one we will provides an example for:
      </p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="messageSource" 
            class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basenames"&gt;
            &lt;list&gt;
                &lt;value&gt;format&lt;/value&gt;
                &lt;value&gt;exceptions&lt;/value&gt;
                &lt;value&gt;windows&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt; </pre><p>This assumes you have three resource bundles defined on your
      classpath called <tt class="literal">format</tt>,
      <tt class="literal">exceptions</tt> and <tt class="literal">windows</tt>. Using the
      JDK standard way of resolving messages through ResourceBundles, any
      request to resolve a message will be handled. TODO: SHOW AN
      EXAMPLE</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-events"></a>3.12.2.&nbsp;Propagating events</h3></div></div><div></div></div><p>Event handling in the ApplicationContext is provided through the
      <tt class="literal">ApplicationEvent</tt> class and
      <tt class="literal">ApplicationListener</tt> interface. If a bean which
      implements the <tt class="literal">ApplicationListener</tt> interface is
      deployed into the context, every time an
      <tt class="literal">ApplicationEvent</tt> gets published to the
      ApplicationContext, that bean will be notified. Essentially, this is the
      standard <span class="emphasis"><em>Observer</em></span> design pattern. Spring provides
      three standard events: </p><div class="table"><a name="d0e1880"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Built-in Events</b></p><table summary="Built-in Events" border="1"><colgroup><col><col></colgroup><thead><tr><th>Event</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">ContextRefreshedEvent</tt></td><td>Event published when the ApplicationContext is
                initialized or refreshed. Initialized here means that all
                beans are loaded, singletons are pre-instantiated and the
                ApplicationContext is ready for use</td></tr><tr><td><tt class="literal">ContextClosedEvent</tt></td><td>Event published when the ApplicationContext is closed,
                using the <tt class="literal">close()</tt> method on the
                ApplicationContext. Closed here means that singletons are
                destroyed</td></tr><tr><td><tt class="literal">RequestHandledEvent</tt></td><td>A web-specific event telling all beans that a HTTP
                request has been serviced (i.e. this will be published
                <span class="emphasis"><em>after</em></span> the request has been finished).
                Note that this event is only applicable for web applications
                using Spring's DispatcherServlet</td></tr></tbody></table></div><p>Implementing custom events can be done as well. Simply call the
      <tt class="literal">publishEvent()</tt> method on the ApplicationContext,
      specifying a parameter which is an instance of your custom event class
      implementing ApplicationEvent. Event listeners receive events
      synchronously. This means the publishEvent() method blocks until all
      listeners have finished processing the event. Furthermore, when a
      listener receives an event it operates inside the transaction context of
      the publisher, if a transaction context is available.</p><p>Let's look at an example. First, the ApplicationContext:
      </p><pre class="programlisting">&lt;bean id="emailer" class="example.EmailBean"&gt;
    &lt;property name="blackList"&gt;
        &lt;list&gt;
            &lt;value&gt;black@list.org&lt;/value&gt;
            &lt;value&gt;white@list.org&lt;/value&gt;
            &lt;value&gt;john@doe.org&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="blackListListener" class="example.BlackListNotifier"&gt;
    &lt;property name="notificationAddress"&gt;
        &lt;value&gt;spam@list.org&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>and then, the actual beans: </p><pre class="programlisting">public class EmailBean implements ApplicationContextAware {

    /** the blacklist */
    private List blackList;
    
    public void setBlackList(List blackList) {
        this.blackList = blackList;
    }
    
    public void setApplicationContext(ApplicationContext ctx) {
        this.ctx = ctx;
    }
    
    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent evt = new BlackListEvent(address, text);
            ctx.publishEvent(evt);
            return;
        }
        // send email
    }
}

public class BlackListNotifier implement ApplicationListener {

    /** notification address */
    private String notificationAddress;
    
    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(ApplicationEvent evt) {
        if (evt instanceof BlackListEvent) {
            // notify appropriate person
        }
    }
}</pre><p>Of course, this particular example could probably be
      implemented in better ways (perhaps by using AOP features), but it
      should be sufficient to illustrate the basic event mechanism.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-resources"></a>3.12.3.&nbsp;Using resources within Spring</h3></div></div><div></div></div><p>Many applications need to access resources. Resources could
      include files, but also things like web pages or NNTP newsfeeds. Spring
      provides a clean and transparent way of accessing resources in a
      protocol independent way. The ApplicationContext interface includes a
      method (<tt class="literal">getResource(String)</tt>) to take care of
      this.</p><p>The Resource class defines a couple of methods that are shared
      across all Resource implementations: </p><div class="table"><a name="d0e1940"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;Resource functionality</b></p><table summary="Resource functionality" border="1"><colgroup><col><col></colgroup><thead><tr><th>Method</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">getInputStream()</tt></td><td>Opens an InputStream on the resource and returns
                it</td></tr><tr><td><tt class="literal">exists()</tt></td><td>Checks if the resource exists, returning false if it
                doesn't</td></tr><tr><td><tt class="literal">isOpen()</tt></td><td>Will return true is multiple streams cannot be opened
                for this resource. This will be false for some resources, but
                file-based resources for instance, cannot be read multiple
                times concurrently</td></tr><tr><td><tt class="literal">getDescription()</tt></td><td>Returns a description of the resource, often the fully
                qualified file name or the actual URL</td></tr></tbody></table></div><p>A couple of Resource implementations are provided by Spring. They
      all need a String representing the actual location of the resource.
      Based upon that String, Spring will automatically choose the right
      Resource implementation for you. When asking an ApplicationContext for a
      resource first of all Spring will inspect the resource location you're
      specifying and look for any prefixes. Depending on the implementation of
      the ApplicationContext more or less Resource implementations are
      available. Resources can best be configured by using the ResourceEditor
      and for example the XmlBeanFactory.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-context-customization"></a>3.13.&nbsp;Customized behavior in the ApplicationContext</h2></div></div><div></div></div><p>The BeanFactory already offers a number of mechanisms to control the
    lifecycle of beans deployed in it (such as marker interfaces like
    <tt class="literal">InitializingBean</tt> or <tt class="literal">DisposableBean</tt>,
    their configuration only equivalents such as the
    <tt class="literal">init-method</tt> and <tt class="literal">destroy-method</tt>
    attributes in an XmlBeanFactory config, and bean post-processors. In an
    ApplicationContext, all of these still work, but additional mechanisms are
    added for customizing behavior of beans and the container.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-context-applicationcontextaware"></a>3.13.1.&nbsp;<tt class="literal">ApplicationContextAware</tt> marker
      interface</h3></div></div><div></div></div><p>All marker interfaces available with BeanFactories still work. The
      ApplicationContext does add one extra marker interface which beans may
      implement,
      <tt class="literal">org.springframework.context.ApplicationContextAware</tt>.
      A bean which implements this interface and is deployed into the context
      will be called back on creation of the bean, using the interface's
      <tt class="literal">setApplicationContext()</tt> method, and provided with a
      reference to the context, which may be stored for later interaction with
      the context.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-context-beanpostprocessor"></a>3.13.2.&nbsp;The <tt class="literal">BeanPostProcessor</tt></h3></div></div><div></div></div><p>Bean post-processors, java classes which implement the
      <tt class="literal">org.springframework.beans.factory.config.BeanPostProcessor</tt>
      interface, have <a href="#beans-factory-customizing" title="3.7.&nbsp;Customizing beans with BeanPostprocessors">already</a>
      been mentioned. It is worth mentioning again here though, that
      post-processors are much more convenient to use in ApplicationContexts
      than in plain BeanFactories. In an ApplicationContext, any deployed bean
      which implements the above marker interface is automatically detected
      and registered as a bean post-processor, to be called appropriately at
      creation time for each bean in the factory.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-context-beanfactorypostprocessor"></a>3.13.3.&nbsp;The <tt class="literal">BeanFactoryPostProcessor</tt></h3></div></div><div></div></div><p>Bean factory post-processors, java classes which implement the
      <tt class="literal">org.springframework.beans.factory.config.BeanFactoryPostProcessor</tt>
      interface, have <a href="#beans-factory-customizing-factory-postprocessors" title="3.8.&nbsp;Customizing bean factories with BeanFactoryPostprocessors">already</a>
      been mentioned. It is worth mentioning again here though, that bean
      factory post-processors are much more convenient to use in
      ApplicationContexts than in plain BeanFactories. In an
      ApplicationContext, any deployed bean which implements the above marker
      interface is automatically detected as a bean factory post-processor, to
      be called at the appropriate time.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-context-placeholderconfigurer"></a>3.13.4.&nbsp;The <tt class="literal">PropertyPlaceholderConfigurer</tt></h3></div></div><div></div></div><p>The <tt class="literal">PropertyPlaceholderConfigurer</tt> has <a href="#beans-factory-placeholderconfigurer" title="3.8.1.&nbsp;The PropertyPlaceholderConfigurer">already</a> been
      described, as used with a BeanFactory. It is worth mentioning here
      though, that it is generally more convenient to use it with an
      ApplicationContext, since the context will automatically recognize and
      apply any bean factory post-processors, such as this one, when they are
      simply deployed into it like any other bean. There is no need for a
      manual step to execute it.</p><pre class="programlisting">&lt;!-- property placeholder post-processor --&gt;
&lt;bean id="placeholderConfig"
      class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="location"&gt;&lt;value&gt;jdbc.properties&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-applicationcontext-customeditors"></a>3.14.&nbsp;Registering additional custom PropertyEditors</h2></div></div><div></div></div><p>As <a href="#beans-beanfactory-customeditors" title="3.9.&nbsp;Registering additional custom PropertyEditors">previously</a>
    mentioned, standard JavaBeans PropertyEditors are used to convert property
    values expressed as strings to the actual complex type of the property.
    <tt class="literal">CustomEditorConfigurer</tt>, a bean factory post-processor,
    may be used to conveniently add support for additional PropertyEditors to
    an ApplicationContext.</p><p>Consider a user class <span class="emphasis"><em>ExoticType</em></span>, and another
    class <span class="emphasis"><em>DependsOnExoticType</em></span> which needs ExoticType set
    as a property:</p><pre class="programlisting">public class ExoticType {
    private String name;
    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType {    
    private ExoticType type;
    public void setType(ExoticType type) {
        this.type = type;
    }
}</pre><p>When things are properly set up, we want to be able to
    assign the type property as a string, which a PropertyEditor will behind
    the scenes convert into a real ExoticType object.: </p><pre class="programlisting">&lt;bean id="sample" class="example.DependsOnExoticType"&gt;
    &lt;property name="type"&gt;&lt;value&gt;aNameForExoticType&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The PropertyEditor could look similar to this:
    </p><pre class="programlisting">// converts string representation to ExoticType object
public class ExoticTypeEditor extends PropertyEditorSupport {

    private String format;

    public void setFormat(String format) {
        this.format = format;
    }
    
    public void setAsText(String text) {
        if (format != null &amp;&amp; format.equals("upperCase")) {
            text = text.toUpperCase();
        }
        ExoticType type = new ExoticType(text);
        setValue(type);
    }
}</pre><p>Finally, we use <tt class="literal">CustomEditorConfigurer</tt> to
    register the new PropertyEditor with the ApplicationContext, which will
    then be able to use it as needed.: </p><pre class="programlisting">&lt;bean id="customEditorConfigurer" 
    class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
    &lt;property name="customEditors"&gt;
        &lt;map&gt;
            &lt;entry key="example.ExoticType"&gt;
                &lt;bean class="example.ExoticTypeEditor"&gt;
                    &lt;property name="format"&gt;
                        &lt;value&gt;upperCase&lt;/value&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2083"></a>3.15.&nbsp;Setting a bean property or constructor arg from a property
    expression</h2></div></div><div></div></div><p><tt class="literal">PropertyPathFactoryBean</tt> is a
    <tt class="literal">FactoryBean</tt> that evaluates a property path on a given
    target object. The target object can be specified directly or via a bean
    name. This value may then be used in another bean definition as a property
    value or constructor argument.</p><p>Here's an example where a path is used against another bean, by
    name:</p><pre class="programlisting">// target bean to be referenced by name
&lt;bean id="person" class="org.springframework.beans.TestBean" singleton="false"&gt;
  &lt;property name="age"&gt;&lt;value&gt;10&lt;/value&gt;&lt;/property&gt;
  &lt;property name="spouse"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age"&gt;&lt;value&gt;11&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

// will result in 11, which is the value of property 'spouse.age' of bean 'person'
&lt;bean id="theAge" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
  &lt;property name="targetBeanName"&gt;&lt;value&gt;person&lt;/value&gt;&lt;/property&gt;
  &lt;property name="propertyPath"&gt;&lt;value&gt;spouse.age&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>In this example, a path is evaluated against an inner bean:</p><pre class="programlisting">// will result in 12, which is the value of property 'age' of the inner bean
&lt;bean id="theAge" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
  &lt;property name="targetObject"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age"&gt;&lt;value&gt;12&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
   &lt;property name="propertyPath"&gt;&lt;value&gt;age&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p> There is also a shortcut form, where the bean
    name is the property path.</p><pre class="programlisting">// will result in 10, which is the value of property 'age' of bean 'person'
&lt;bean id="person.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</pre><p>This form does mean that there is no choice in the name of the bean,
    any reference to it will also have to use the same id, which is the path.
    Of curse, if used as an inner bean, there is no need to refer to it at
    all:</p><pre class="programlisting">&lt;bean id="..." class="..."&gt;
  &lt;proprty name="age"&gt;
    &lt;bean id="person.age"
          class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The result type may be specifically set in the
    actual definition. This is not necessary for most use cases, but can be of
    use for some. Please see the JavaDocs for more info on this
    feature.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2111"></a>3.16.&nbsp;Setting a bean property or constructor arg from a field
    value</h2></div></div><div></div></div><p>FieldRetrievingFactoryBean is a FactoryBean which retrieves a static
    or non-static field value. It is typically used for retrieving public
    static final constants, which may then be used to set a property value or
    constructor arg for another bean.</p><p>Here's an example which shows how a static field is exposed, by
    using the staticField property:</p><pre class="programlisting">&lt;bean id="myField"
      class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"&gt;
  &lt;property name="staticField"&gt;&lt;value&gt;java.sql.Connection.TRANSACTION_SERIALIZABLE&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>There's also a convenience usage form where the static field is
    specified as a bean name:</p><pre class="programlisting">&lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
      class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;</pre><p>This means there is no longer any choice in what the bean id is (so
    any other bean that refers to it will also have to use this longer name),
    but this form is very concise to define, and very convenient to use as an
    inner bean since the id doesn't have to be specified for the bean
    reference:</p><pre class="programlisting">&lt;bean id="..." class="..."&gt;
  &lt;proprty name="isolation"&gt;
    &lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
      class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>It's also possible to access a non-static field
    of another bean, as described in the JavaDocs.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2131"></a>3.17.&nbsp;Invoking another method and optionally using the return
    value.</h2></div></div><div></div></div><p>it is sometimes necessary to call a static or non-static method in
    one class, just to perform some sort of initialization, before some other
    class is used. Additionally, it is sometimes necessary to set a property
    on a bean, as the result of a method call on another bean in the
    container, or a static method call on any arbitrary class. For both of
    these purposes, a helper class called
    <tt class="classname">MethodInvokingFactoryBean</tt> may be used. This is a
    <tt class="literal"><tt class="classname">FactoryBean</tt></tt> which returns a
    value which is the result of a static or instance method
    invocation.</p><p>We would however recommend that for the second use case,
    factory-methods, described previously, are a better all around
    choice.</p><p>An example (in an XML based BeanFactory definition) of a bean
    definition which uses this class to force some sort of static
    initialization:</p><pre class="programlisting">&lt;bean id="force-init" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="staticMethod"&gt;&lt;value&gt;com.example.MyClass.initialize&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="bean1" class="..." depends-on="force-init"&gt;
  ...
&lt;/bean&gt;</pre><p>Note that the definition for
    <tt class="literal">bean1</tt> has used the <tt class="literal">depends-on</tt>
    attribute to refer to the <tt class="literal">force-init</tt> bean, which will
    trigger initializing <tt class="literal">force-init</tt> first, and thus calling
    the static initializer method, when <tt class="literal">bean1</tt> is first
    initialized.</p><p>Here's an example of a bean definition which uses this class to call
    a static factory method:</p><pre class="programlisting">&lt;bean id="myClass" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="staticMethod"&gt;&lt;value&gt;com.whatever.MyClassFactory.getInstance&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>An example of calling a static method then an instance method to get
    at a Java System property. Somewhat verbose, but it works.</p><pre class="programlisting">&lt;bean id="sysProps" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetClass"&gt;&lt;value&gt;java.lang.System&lt;/value&gt;&lt;/property&gt;
  &lt;property name="targetMethod"&gt;&lt;value&gt;getProperties&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="javaVersion" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetObject"&gt;&lt;ref local="sysProps"/&gt;&lt;/property&gt;
  &lt;property name="targetMethod"&gt;&lt;value&gt;getProperty&lt;/value&gt;&lt;/property&gt;
  &lt;property name="arguments"&gt;
    &lt;list&gt;
      &lt;value&gt;java.version&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that as it is expected to be used mostly for accessing factory
    methods, MethodInvokingFactoryBean by default operates in a
    <span class="emphasis"><em>singleton</em></span> fashion. The first request by the container
    for the factory to produce an object will cause the specified method
    invocation, whose return value will be cached and returned for the current
    and subsequent requests. An internal <tt class="literal">singleton</tt> property
    of the factory may be set to false, to cause it to invoke the target
    method each time it is asked for an object.</p><p>A static target method may be specified by setting the
    <tt class="literal">targetMethod</tt> property to a String representing the
    static method name, with <tt class="literal">targetClass</tt> specifying the
    Class that the static method is defined on. Alternatively, a target
    instance method may be specified, by setting the
    <tt class="literal">targetObject</tt> property as the target object, and the
    <tt class="literal">targetMethod</tt> property as the name of the method to call
    on that target object. Arguments for the method invocation may be
    specified by setting the <tt class="literal">args</tt> property.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-import"></a>3.18.&nbsp;Importing Bean Definitions from One File Into Another</h2></div></div><div></div></div><p>It's often useful to split up container definitions into multiple
    XML files. One way to then load an application context which is configured
    from all these XML fragments is to use the application context constructor
    which takes multiple Resource locations. With a bean factory, a bean
    definition reader can be used multiple times to read definitions from each
    file in turn.</p><p>Generally, the Spring team prefers the above approach, since it
    keeps container configurations files unaware of the fact that they are
    being combined with others. However, an alternate approach is to from one
    XML bean definition file, use one or more instances of the
    <tt class="literal">import</tt> element to load definitions from one or more
    other files. Any <tt class="literal">import</tt> elements must be placed before
    <tt class="literal">bean</tt> elements in the file doing the importing. Let's
    look at a sample:</p><pre class="programlisting">&lt;beans&gt;

  &lt;import resource="services.xml"/&gt;

  &lt;import resource="resources/messageSource.xml"/&gt;

  &lt;import resource="/resources/themeSource.xml"/&gt;

  &lt;bean id="bean1" class="..."/&gt;

  &lt;bean id="bean2" class="..."/&gt;
  . . .</pre><p>In this example, external bean definitions are being loaded from 3
    files, <tt class="literal">services.xml</tt>,
    <tt class="literal">messageSource.xml</tt>, and
    <tt class="literal">themeSource.xml</tt>. All location paths are considered
    relative to the definition file doing the importing, so
    <tt class="literal">services.xml</tt> in this case must be in the same directory
    or classpath location as the file doing the importing, while
    <tt class="literal">messageSource.xml</tt> and
    <tt class="literal">themeSource.xml</tt> must be in a
    <tt class="literal">resources</tt> location below the location of the importing
    file. As you can see, a leading slash is actually ignored, but given that
    these are considered relative paths, it is probably better form not to use
    the slash at all.</p><p>The contents of the files being imported must be fully valid XML
    bean definition files according to the DTD, including the top level
    <tt class="literal">beans</tt> element.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-create"></a>3.19.&nbsp;Creating an ApplicationContext from a web application</h2></div></div><div></div></div><p>As opposed to the BeanFactory, which will often be created
    programmatically, ApplicationContexts can be created declaratively using
    for example a <tt class="literal">ContextLoader</tt>. Of course you can also
    create ApplicationContexts programmatically using one of the
    ApplicationContext implementations. First, let's examine the ContextLoader
    and its implementations.</p><p>The ContextLoader has two implementations: the
    <tt class="literal">ContextLoaderListener</tt> and the
    <tt class="literal">ContextLoaderServlet</tt>. They both have the same
    functionality but differ in that the listener cannot be used in Servlet
    2.2 compatible containers. Since the Servlet 2.4 specification, listeners
    are required to initialize after startup of a web application. A lot of
    2.3 compatible containers already implement this feature. It is up to you
    as to which one you use, but all things being equal you should probably
    prefer <tt class="literal">ContextLoaderListener</tt>; for more information on
    compatibility, have a look at the JavaDoc for the
    <tt class="literal">ContextLoaderServlet</tt>.</p><p>You can register an ApplicationContext using the
    <tt class="literal">ContextLoaderListener</tt> as follows: </p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!-- OR USE THE CONTEXTLOADERSERVLET INSTEAD OF THE LISTENER
&lt;servlet&gt;
    &lt;servlet-name&gt;context&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
--&gt;</pre><p> The listener inspects the
    <tt class="literal">contextConfigLocation</tt> parameter. If it doesn't exist,
    it'll use <tt class="literal">/WEB-INF/applicationContext.xml</tt> as a default.
    When it <span class="emphasis"><em>does</em></span> exist, it'll separate the String using
    predefined delimiters (comma, semi-colon and space) and use the values as
    locations where application contexts will be searched for. The
    ContextLoaderServlet can - as said - be used instead of the
    ContextLoaderListener. The servlet will use the contextConfigLocation
    parameter just as the listener does.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2287"></a>3.20.&nbsp;Glue code and the evil singleton</h2></div></div><div></div></div><p>The majority of the code inside an application is best written in a
    Dependency Injection (Inversion of Control) style, where that code is
    served out of a BeanFactory or ApplicationContext container, has its own
    dependencies supplied by the container when it is created, and is
    completely unaware of the container. However, for the small glue layers of
    code that are sometimes needed to tie other code together, there is
    sometimes a need for singleton (or quasi-singleton) style access to a
    BeanFactory or ApplicationContext. For example, third party code may try
    to construct new objects directly (<tt class="literal">Class.forName()</tt>
    style), without the ability to force it to get these objects out of a
    BeanFactory. If the object constructed by the third party code is just a
    small stub or proxy, which then uses a singleton style access to a
    BeanFactory/ApplicationContext to get a real object to delegate to, then
    inversion of control has still been achieved for the majority of the code
    (the object coming out of the BeanFactory); thus most code is still
    unaware of the container or how it is accessed, and remains uncoupled from
    other code, with all ensuing benefits. EJBs may also use this stub/proxy
    approach to delegate to a plain java implementation object, coming out of
    a BeanFactory. While the BeanFactory ideally does not have to be a
    singleton, it may be unrealistic in terms of memory usage or
    initialization times (when using beans in the BeanFactory such as a
    Hibernate SessionFactory) for each bean to use its own, non-singleton
    BeanFactory.</p><p>As another example, in a complex J2EE apps with multiple layers
    (i.e. various JAR files, EJBs, and WAR files packaged as an EAR), with
    each layer having its own ApplicationContext definition (effectively
    forming a hierarchy), the preferred approach when there is only one
    web-app (WAR) in the top hierarchy is to simply create one composite
    ApplicationContext from the multiple XML definition files from each layer.
    All the ApplicationContext variants may be constructed from multiple
    definition files in this fashion. However, if there are multiple sibling
    web-apps at the top of the hierarchy, it is problematic to create an
    ApplicationContext for each web-app which consists of mostly identical
    bean definitions from lower layers, as there may be issues due to
    increased memory usage, issues with creating multiple copies of beans
    which take a long time to initialize (i.e. a Hibernate SessionFactory),
    and possible issues due to side-effects. As an alternative, classes such
    as <tt class="literal"><a href="???" target="_top">ContextSingletonBeanFactoryLocator</a></tt> or
    <tt class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a></tt>
    may be used to demand load multiple hierarchical (i.e. one is a parent of
    another) BeanFactories or ApplicationContexts in an effectively singleton
    fashion, which may then be used as the parents of the web-app
    ApplicationContexts. The result is that bean definitions for lower layers
    are loaded only as needed, and loaded only once.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2305"></a>3.20.1.&nbsp;Using SingletonBeanFactoryLocator and
      ContextSingletonBeanFactoryLocator</h3></div></div><div></div></div><p>You can see a detailed example of using <tt class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a></tt>
      and <tt class="literal"><a href="???" target="_top">ContextSingletonBeanFactoryLocator</a></tt> by
      viewing their respective JavaDocs.</p><p>As mentioned in the chapter on EJBs, the Spring convenience base
      classes for EJBs normally use a non-singleton
      <tt class="literal">BeanFactoryLocator</tt> implementation, which is easily
      replaced by the use of <tt class="literal">SingletonBeanFactoryLocator</tt>
      and <tt class="literal">ContextSingletonBeanFactoryLocator</tt> if there is a
      need.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e1062" href="#d0e1062">1</a>] </sup>See <a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Setting bean properties and collaborators">Section&nbsp;3.3.1, &#8220;Setting bean properties and collaborators&#8221;</a></p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="validation"></a>Chapter&nbsp;4.&nbsp;PropertyEditors, data binding, validation and the BeanWrapper</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-introduction"></a>4.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The big question is whether or not validation should be considered
    <span class="emphasis"><em>business logic</em></span>. There are pros and cons for both
    answers, and Spring offers a design for validation (and data binding) that
    does not exclude either one of them. Validation should specifically not be
    tied to the web tier, should be easy to localize and it should be
    possible to plug in any validator available. Considering the above, Spring
    has come up with a <tt class="literal">Validator</tt> interface that's both
    basic and usable in every layer of an application.</p><p>Data binding is useful for allowing user input to be dynamically
    bound to the domain model of an application (or whatever objects you use
    to process user input). Spring provides the so-called
    <tt class="literal">DataBinder</tt> to do exactly that. The Validator and the
    DataBinder make up the <tt class="literal">validation</tt> package, which is
    primarily used in but not limited to the MVC framework.</p><p>The <tt class="literal">BeanWrapper</tt> is a fundamental concept in the
    Spring Framework and is used in a lot of places. However, you probably
    will not ever have the need to use the BeanWrapper directly. Because this
    is reference documentation however, we felt that some explanation might be
    right. We're explaining the BeanWrapper in this chapter since if you were
    going to use it at all, you would probably do that when trying to bind
    data to objects, which is strongly related to the BeanWrapper.</p><p>Spring uses PropertyEditors all over the place. The concept of a
    PropertyEditor is part of the JavaBeans specification. Just as the
    BeanWrapper, it's best to explain the use of PropertyEditors in this
    chapter as well, since it's closely related to the BeanWrapper and the
    DataBinder.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-databinding"></a>4.2.&nbsp;Binding data using the <tt class="literal">DataBinder</tt></h2></div></div><div></div></div><p>The DataBinder builds on top of the BeanWrapper<sup>[<a name="d0e2365" href="#ftn.d0e2365">2</a>]</sup>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beans"></a>4.3.&nbsp;Bean manipulation and the <tt class="literal">BeanWrapper</tt></h2></div></div><div></div></div><p>The <tt class="literal">org.springframework.beans</tt> package adheres to
    the JavaBeans standard provided by Sun. A JavaBean is simply a class with
    a default no-argument constructor, which follows a naming conventions
    where a property named <tt class="literal">prop</tt> has a setter
    <tt class="literal">setProp(...)</tt> and a getter <tt class="literal">getProp()</tt>.
    For more information about JavaBeans and the specification, please refer
    to Sun's website (<a href="http://java.sun.com/products/javabeans/" target="_top">java.sun.com/products/javabeans</a>).</p><p>One quite important concept of the beans package is the
    <tt class="literal">BeanWrapper</tt> interface and its corresponding
    implementation (<tt class="literal">BeanWrapperImpl</tt>). As quoted from the
    JavaDoc, the BeanWrapper offers functionality to set and get property
    values (individually or in bulk), get property descriptors, and to query
    properties to determine if they are readable or writable. Also, the
    BeanWrapper offers support for nested properties, enabling the setting of
    properties on sub-properties to an unlimited depth. Then, the BeanWrapper
    support the ability to add standard JavaBeans
    <tt class="literal">PropertyChangeListeners</tt> and
    <tt class="literal">VetoableChangeListeners</tt>, without the need for
    supporting code in the target class. Last but not least, the BeanWrapper
    provides support for the setting of indexed properties. The BeanWrapper
    usually isn't used by application code directly, but by the
    <tt class="literal">DataBinder</tt> and the
    <tt class="literal">BeanFactory</tt>.</p><p>The way the BeanWrapper works is partly indicated by its name:
    <span class="emphasis"><em>it wraps a bean</em></span> to perform actions on that bean, like
    setting and retrieving properties.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conventions"></a>4.3.1.&nbsp;Setting and getting basic and nested properties</h3></div></div><div></div></div><p>Setting and getting properties is done using the
      <tt class="literal">setPropertyValue(s)</tt> and
      <tt class="literal">getPropertyValue(s)</tt> methods that both come with a
      couple of overloaded variants. They're all described in more detail in
      the JavaDoc Spring comes with. What's important to know is that there
      are a couple of conventions for indicating properties of an object. A
      couple of examples: </p><div class="table"><a name="d0e2430"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Examples of properties</b></p><table summary="Examples of properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Expression</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">name</tt></td><td>Indicates the property <tt class="literal">name</tt>
                corresponding to the methods <tt class="literal">getName()</tt> or
                <tt class="literal">isName()</tt> and
                <tt class="literal">setName()</tt></td></tr><tr><td><tt class="literal">account.name</tt></td><td>Indicates the nested property <tt class="literal">name</tt>
                of the property <tt class="literal">account</tt> corresponding e.g.
                to the methods <tt class="literal">getAccount().setName()</tt> or
                <tt class="literal">getAccount().getName()</tt></td></tr><tr><td><tt class="literal">account[2]</tt></td><td>Indicates the <span class="emphasis"><em>third</em></span> element of the
                indexed property <tt class="literal">account</tt>. Indexed
                properties can be of type <tt class="literal">array</tt>,
                <tt class="literal">list</tt> or other <span class="emphasis"><em>naturally
                ordered</em></span> collection</td></tr><tr><td><tt class="literal">account[COMPANYNAME]</tt></td><td>Indicates the value of the map entry indexed by the key
                <span class="emphasis"><em>COMPANYNAME</em></span> of the Map property
                <tt class="literal">account</tt></td></tr></tbody></table></div><p>Below you'll find some examples of working with the BeanWrapper to
      get and set properties.</p><p><span class="emphasis"><em>Note: this part is not important to you if you're not
      planning to work with the BeanWrapper directly. If you're just using the
      <tt class="literal">DataBinder</tt> and the <tt class="literal">BeanFactory</tt> and
      their out-of-the-box implementation, you should skip ahead to the
      section about <tt class="literal">PropertyEditors</tt>.</em></span></p><p>Consider the following two classes: </p><pre class="programlisting">public class Company {
    private String name;
    private Employee managingDirector;

    public String getName()	{ 
        return this.name; 
    }
    public void setName(String name) { 
        this.name = name; 
    } 
    public Employee getManagingDirector() { 
        return this.managingDirector; 
    }
    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}</pre><p> </p><pre class="programlisting">public class Employee {
    private float salary;

    public float getSalary() {
        return salary;
    }
    public void setSalary(float salary) {
        this.salary = salary;
    }
}</pre><p>The following code snippets show some examples of how to retrieve
      and manipulate some of the properties of instantiated:
      <tt class="literal">Companies</tt> and <tt class="literal">Employees</tt>
      </p><pre class="programlisting">Company c = new Company();
BeanWrapper bwComp = BeanWrapperImpl(c);
// setting the company name...
bwComp.setPropertyValue("name", "Some Company Inc.");
// ... can also be done like this:
PropertyValue v = new PropertyValue("name", "Some Company Inc.");
bwComp.setPropertyValue(v);

// ok, let's create the director and tie it to the company:
Employee jim = new Employee();
BeanWrapper bwJim = BeanWrapperImpl(jim);
bwJim.setPropertyValue("name", "Jim Stravinsky");
bwComp.setPropertyValue("managingDirector", jim);

// retrieving the salary of the managingDirector through the company
Float salary = (Float)bwComp.getPropertyValue("managingDirector.salary");</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conversion"></a>4.3.2.&nbsp;Built-in <tt class="literal">PropertyEditors</tt>, converting
      types</h3></div></div><div></div></div><p>Spring heavily uses the concept of
      <tt class="literal">PropertyEditors</tt>. Sometimes it might be handy to be
      able to represent properties in a different way than the object itself.
      For example, a date can be represented in a human readable way, while
      we're still able to convert the human readable form back to the original
      date (or even better: convert any date entered in a human readable form,
      back to Date objects). This behavior can be achieved by
      <span class="emphasis"><em>registering custom editors</em></span>, of type
      <tt class="literal">java.beans.PropertyEditor</tt>. Registering custom editors
      on a BeanWrapper or alternately in a specific Application Context as
      mentioned in the previous chapter, gives it the knowledge of how to
      convert properties to the desired type. Read more about PropertyEditors
      in the JavaDoc of the <tt class="literal">java.beans</tt> package provided by
      Sun.</p><p>A couple of examples where property editing is used in Spring
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>setting properties on beans</em></span> is done
            using PropertyEditors. When mentioning
            <tt class="literal">java.lang.String</tt> as the value of a property of
            some bean you're declaring in XML file, Spring will (if the setter
            of the corresponding property has a Class-parameter) use the
            <tt class="literal">ClassEditor</tt> to try to resolve the parameter to
            a Class object</p></li><li><p><span class="emphasis"><em>parsing HTTP request parameters</em></span> in
            Spring's MVC framework is done using all kinds of PropertyEditors
            that you can manually bind in all subclasses of the
            <tt class="literal">CommandController</tt></p></li></ul></div><p>Spring has a number of built-in PropertyEditors to make life easy.
      Each of those is listed below and they are all located in the
      <tt class="literal">org.springframework.beans.propertyeditors</tt> package.
      Most, but not all (as indicated below), are registered by default by
      BeanWrapperImpl. Where the property editor is configurable in some
      fashion, you can of course still register your own variant to override
      the default one: </p><div class="table"><a name="d0e2586"></a><p class="title"><b>Table&nbsp;4.2.&nbsp;Built-in PropertyEditors</b></p><table summary="Built-in PropertyEditors" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">ByteArrayPropertyEditor</tt></td><td>Editor for byte arrays. Strings will simply be
                converted to their corresponding byte representations.
                Registered by default by BeanWrapperImpl.</td></tr><tr><td><tt class="literal">ClassEditor</tt></td><td>Parses Strings representing classes to actual classes
                and the other way around. When a class is not found, an
                IllegalArgumentException is thrown. Registered by default by
                BeanWrapperImpl.</td></tr><tr><td><tt class="literal">CustomBooleanEditor</tt></td><td>Customizable property editor for Boolean properties.
                Registered by default by BeanWrapperImpl, but, can be
                overridden by registering custom instance of it as custom
                editor.</td></tr><tr><td><tt class="literal">CustomCollectionEdit</tt></td><td>Property editor for Collections, converting any source Collection
                to a given target Collection type.</td></tr><tr><td><tt class="literal">CustomDateEditor</tt></td><td>Customizable property editor for java.util.Date,
                supporting a custom DateFormat. NOT registered by default. Must
                be user registered as needed with appropriate format.</td></tr><tr><td><tt class="literal">CustomNumberEditor</tt></td><td>Customizable property editor for any Number subclass
                like Integer, Long, Float, Double. Registered by default by
                BeanWrapperImpl, but, can be overridden by registering custom
                instance of it as custom editor.</td></tr><tr><td><tt class="literal">FileEditor</tt></td><td>Capable of resolving Strings to
                <tt class="literal">File</tt>-objects. Registered by default by
                BeanWrapperImpl. </td></tr><tr><td><tt class="literal">InputStreamEditor</tt></td><td>One-way property editor, capable of taking a text
                string and producing (via an intermediate ResourceEditor and
                Resource) an InputStream, so InputStream properties may be
                directly setCapable of resolving Strings to
                <tt class="literal">File</tt>-objects. Note that the default usage
                will not close the InputStream for you!. Registered by default
                by BeanWrapperImpl.</td></tr><tr><td><tt class="literal">LocaleEditor</tt></td><td>Capable of resolving Strings to
                <tt class="literal">Locale</tt>-objects and vice versa (the String
                format is [language]_[country]_[variant], which is the same
                thing the toString() method of Locale provides. Registered by
                default by BeanWrapperImpl.</td></tr><tr><td><tt class="literal">PropertiesEditor</tt></td><td>Capable of converting Strings (formatted using the
                format as defined in the Javadoc for the java.lang.Properties
                class) to <tt class="literal">Properties</tt>-objects. Registered by
                default by BeanWrapperImpl.</td></tr><tr><td><tt class="literal">StringArrayPropertyEditor</tt></td><td>Capable of resolving a comma-delimited list of String
                to a String-array and vice versa. Registered by default by
                BeanWrapperImpl.</td></tr><tr><td><tt class="literal">StringTrimmerEditor</tt></td><td>Property editor that trims Strings. Optionally allows
                transforming an empty string into a null value. NOT registered
                by default. Must be user registered as needed.</td></tr><tr><td><tt class="literal">URLEditor</tt></td><td>Capable of resolving a String representation of a URL
                to an actual <tt class="literal">URL</tt>-object. Registered by
                default by BeanWrapperImpl.</td></tr></tbody></table></div><p>Spring uses the
      <tt class="literal">java.beans.PropertyEditorManager</tt> to set the
      search path for property editors that might be needed. The search path
      also includes <tt class="literal">sun.bean.editors</tt>, which includes
      PropertyEditors for Font, Color and all the primitive types. Note also
      that the standard JavaBeans infrastructure will automatically discover
      PropertyEditors (without you having to register them) if they are in the
      same package as the class they handle, and have the same name as that
      class, with 'Editor' appended.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-other"></a>4.3.3.&nbsp;Other features worth mentioning</h3></div></div><div></div></div><p>Besides the features you've seen in the previous sections there a
      couple of features that might be interesting to you, though not worth an
      entire section. </p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>determining readability and
            writability</em></span>: using the <tt class="literal">isReadable()</tt>
            and <tt class="literal">isWritable()</tt> methods, you can determine
            whether or not a property is readable or writable</p></li><li><p><span class="emphasis"><em>retrieving PropertyDescriptors</em></span>: using
            <tt class="literal">getPropertyDescriptor(String)</tt> and
            <tt class="literal">getPropertyDescriptors()</tt> you can retrieve
            objects of type <tt class="literal">java.beans.PropertyDescriptor</tt>,
            that might come in handy sometimes</p></li></ul></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e2365" href="#d0e2365">2</a>] </sup>See <a href="#beans" title="Chapter&nbsp;3.&nbsp;Beans, BeanFactory and the ApplicationContext">the beans chapter</a> for more
        information</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="aop"></a>Chapter&nbsp;5.&nbsp;Spring AOP: Aspect Oriented Programming with Spring</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-introduction"></a>5.1.&nbsp;Concepts</h2></div></div><div></div></div><p><span class="emphasis"><em>Aspect-Oriented Programming</em></span>
    (<span class="emphasis"><em>AOP</em></span>) complements OOP by providing another way of
    thinking about program structure. While OO decomposes applications into a
    hierarchy of objects, AOP decomposes programs into
    <span class="emphasis"><em>aspects</em></span> or <span class="emphasis"><em>concerns</em></span>. This
    enables modularization of concerns such as transaction management that
    would otherwise cut across multiple objects. (Such concerns are often
    termed <span class="emphasis"><em>crosscutting</em></span> concerns.)</p><p>One of the key components of Spring is the <span class="emphasis"><em>AOP
    framework</em></span>. While the Spring IoC containers (BeanFactory and
    ApplicationContext) do not depend on AOP, meaning you don't need to use
    AOP if you don't want to, AOP complements Spring IoC to provide a very
    capable middleware solution.</p><p>AOP is used in Spring:</p><div class="itemizedlist"><ul type="disc"><li><p>To provide declarative enterprise services, especially as a
        replacement for EJB declarative services. The most important such
        service is <span class="emphasis"><em>declarative transaction management</em></span>,
        which builds on Spring's transaction abstraction.</p></li><li><p>To allow users to implement custom aspects, complementing their
        use of OOP with AOP.</p></li></ul></div><p>Thus you can view Spring AOP as either an enabling technology that
    allows Spring to provide declarative transaction management without EJB;
    or use the full power of the Spring AOP framework to implement custom
    aspects.</p><i><span class="remark">If you are interested only in generic declarative services or
    other pre-packaged declarative middleware services such as pooling, you
    don't need to work directly with Spring AOP, and can skip most of this
    chapter.</span></i><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-defn"></a>5.1.1.&nbsp;AOP concepts</h3></div></div><div></div></div><p>Let us begin by defining some central AOP concepts. These terms
      are not Spring-specific. Unfortunately, AOP terminology is not
      particularly intuitive. However, it would be even more confusing if
      Spring used its own terminology.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Aspect</em></span>: A modularization of a concern for
          which the implementation might otherwise cut across multiple
          objects. Transaction management is a good example of a crosscutting
          concern in J2EE applications. Aspects are implemented using Spring
          as Advisors or interceptors.</p></li><li><p><span class="emphasis"><em>Joinpoint</em></span>: Point during the execution of
          a program, such as a method invocation or a particular exception
          being thrown. In Spring AOP, a joinpoint is always method
          invocation. Spring does not use the term joinpoint prominently;
          joinpoint information is accessible through methods on the
          <tt class="literal">MethodInvocation</tt> argument passed to interceptors,
          and is evaluated by implementations of the
          <tt class="literal">org.springframework.aop.Pointcut
          </tt>interface.</p></li><li><p><span class="emphasis"><em>Advice</em></span>: Action taken by the AOP framework
          at a particular joinpoint. Different types of advice include
          "around," "before" and "throws" advice. Advice types are discussed
          below. Many AOP frameworks, including Spring, model an advice as an
          <span class="emphasis"><em>interceptor</em></span>, maintaining a chain of
          interceptors "around" the joinpoint.</p></li><li><p><span class="emphasis"><em>Pointcut</em></span>: A set of joinpoints specifying
          when an advice should fire. An AOP framework must allow developers
          to specify pointcuts: for example, using regular expressions.</p></li><li><p><span class="emphasis"><em>Introduction</em></span>: Adding methods or fields to
          an advised class. Spring allows you to introduce new interfaces to
          any advised object. For example, you could use an introduction to
          make any object implement an <tt class="literal">IsModified</tt>
          interface, to simplify caching.</p></li><li><p><span class="emphasis"><em>Target object</em></span>: Object containing the
          joinpoint. Also referred to as <span class="emphasis"><em>advised</em></span> or
          <span class="emphasis"><em>proxied</em></span> object.</p></li><li><p><span class="emphasis"><em>AOP proxy</em></span>: Object created by the AOP
          framework, including advice. In Spring, an AOP proxy will be a JDK
          dynamic proxy or a CGLIB proxy.</p></li><li><p><span class="emphasis"><em>Weaving</em></span>: Assembling aspects to create an
          advised object. This can be done at compile time (using the AspectJ
          compiler, for example), or at runtime. Spring, like other pure Java
          AOP frameworks, performs weaving at runtime.</p></li></ul></div><p>Different advice types include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Around advice</em></span>: Advice that surrounds a
          joinpoint such as a method invocation. This is the most powerful
          kind of advice. Around advices will perform custom behavior before
          and after the method invocation. They are responsible for choosing
          whether to proceed to the joinpoint or to shortcut executing by
          returning their own return value or throwing an exception.</p></li><li><p><span class="emphasis"><em>Before advice</em></span>: Advice that executes
          before a joinpoint, but which does not have the ability to prevent
          execution flow proceeding to the joinpoint (unless it throws an
          exception).</p></li><li><p><span class="emphasis"><em>Throws advice</em></span>: Advice to be executed if a
          method throws an exception. Spring provides strongly typed throws
          advice, so you can write code that catches the exception (and
          subclasses) you're interested in, without needing to cast from
          Throwable or Exception.</p></li><li><p><span class="emphasis"><em>After returning advice</em></span>: Advice to be
          executed after a joinpoint completes normally: for example, if a
          method returns without throwing an exception.</p></li></ul></div><p>Around advice is the most general kind of advice. Most
      interception-based AOP frameworks, such as Nanning Aspects, provide only
      around advice.</p><p>As Spring, like AspectJ, provides a full range of advice types, we
      recommend that you use the least powerful advice type that can implement
      the required behavior. For example, if you need only to update a cache
      with the return value of a method, you are better off implementing an
      after returning advice than an around advice, although an around advice
      can accomplish the same thing. Using the most specific advice type
      provides a simpler programming model with less potential for errors. For
      example, you don't need to invoke the <tt class="literal">proceed()</tt>
      method on the MethodInvocation used for around advice, and hence can't
      fail to invoke it.</p><p>The pointcut concept is the key to AOP, distinguishing AOP from
      older technologies offering interception. Pointcuts enable advice to be
      targeted independently of the OO hierarchy. For example, an around
      advice providing declarative transaction management can be applied to a
      set of methods spanning multiple objects. Thus pointcuts provide the
      structural element of AOP.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-spring-defn"></a>5.1.2.&nbsp;Spring AOP capabilities and goals</h3></div></div><div></div></div><p>Spring AOP is implemented in pure Java. There is no need for a
      special compilation process. Spring AOP does not need to control the
      class loader hierarchy, and is thus suitable for use in a J2EE web
      container or application server.</p><p>Spring currently supports interception of method invocations.
      Field interception is not implemented, although support for field
      interception could be added without breaking the core Spring AOP
      APIs.</p><i><span class="remark">Field interception arguably violates OO encapsulation. We don't
      believe it is wise in application development. If you require field
      interception, consider using AspectJ.</span></i><p>Spring provides classes to represent pointcuts and different
      advice types. Spring uses the term <span class="emphasis"><em>advisor</em></span> for an
      object representing an aspect, including both an advice and a pointcut
      targeting it to specific joinpoints.</p><p>Different advice types are <tt class="literal">MethodInterceptor</tt>
      (from the AOP Alliance interception API); and the advice interfaces
      defined in the <tt class="literal">org.springframework.aop</tt> package. All
      advices must implement the <tt class="literal">org.aopalliance.aop.Advice</tt>
      tag interface. Advices supported out the box are
      <tt class="literal">MethodInterceptor</tt> ; <tt class="literal">ThrowsAdvice</tt>;
      <tt class="literal">BeforeAdvice</tt>; and
      <tt class="literal">AfterReturningAdvice</tt>. We'll discuss advice types in
      detail below.</p><p>Spring implements the <span class="emphasis"><em>AOP Alliance</em></span>
      interception interfaces (<a href="http://www.sourceforge.net/projects/aopalliance" target="_top">http://www.sourceforge.net/projects/aopalliance</a>).
      Around advice must implement the AOP Alliance
      <tt class="literal">org.aopalliance.intercept.MethodInterceptor</tt>
      interface. Implementations of this interface can run in Spring or any
      other AOP Alliance compliant implementation. Currently JAC implements
      the AOP Alliance interfaces, and Nanning and Dynaop are likely to in
      early 2004.</p><p>Spring's approach to AOP differs from that of most other AOP
      frameworks. The aim is not to provide the most complete AOP
      implementation (although Spring AOP is quite capable); it is rather to
      provide a close integration between AOP implementation and Spring IoC to
      help solve common problems in enterprise applications.</p><p>Thus, for example, Spring's AOP functionality is normally used in
      conjunction with a Spring IoC container. AOP advice is specified using
      normal bean definition syntax (although this allows powerful
      "autoproxying" capabilities); advice and pointcuts are themselves
      managed by Spring IoC: a crucial difference from other AOP
      implementations. There are some things you can't do easily or
      efficiently with Spring AOP, such as advise very fine-grained objects.
      AspectJ is probably the best choice in such cases. However, our
      experience is that Spring AOP provides an excellent solution to most
      problems in J2EE applications that are amenable to AOP.</p><p>Spring AOP will never strive to compete with AspectJ or
      AspectWerkz to provide a comprehensive AOP solution. We believe that
      both proxy-based frameworks like Spring and full-blown frameworks such
      as AspectJ are valuable, and that they are complementary, rather than in
      competition. Thus a major priority for Spring 1.1 will be seamlessly
      integrating Spring AOP and IoC with AspectJ, to enable all uses of AOP
      to be catered for within a consistent Spring-based application
      architecture. This integration will not affect the Spring AOP API or the
      AOP Alliance API; Spring AOP will remain backward-compatible.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-proxies"></a>5.1.3.&nbsp;AOP Proxies in Spring</h3></div></div><div></div></div><p>Spring defaults to using J2SE <span class="emphasis"><em>dynamic proxies</em></span>
      for AOP proxies. This enables any interface or set of interfaces to be
      proxied.</p><p>Spring can also use CGLIB proxies. This is necessary to proxy
      classes, rather than interfaces. CGLIB is used by default if a business
      object doesn't implement an interface. As it's good practice to
      <span class="emphasis"><em>program to interfaces rather than classes</em></span>, business
      objects normally will implement one or more business interfaces.</p><p>It is possible to force the use of CGLIB: we'll discuss this
      below, and explain why you'd want to do this.</p><i><span class="remark">Beyond Spring 1.0, Spring may offer additional types of AOP
      proxy, including wholly generated classes. This won't affect the
      programming model.</span></i></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-introduction-pointcuts"></a>5.2.&nbsp;Pointcuts in Spring</h2></div></div><div></div></div><p>Let's look at how Spring handles the crucial pointcut
    concept.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2947"></a>5.2.1.&nbsp;Concepts</h3></div></div><div></div></div><p>Spring's pointcut model enables pointcut reuse independent of
      advice types. It's possible to target different advice using the same
      pointcut.</p><p>The <tt class="literal">org.springframework.aop.Pointcut</tt> interface
      is the central interface, used to target advices to particular classes
      and methods. The complete interface is shown below:</p><pre class="programlisting">public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

}</pre><p>Splitting the <tt class="literal">Pointcut</tt> interface into two parts
      allows reuse of class and method matching parts, and fine-grained
      composition operations (such as performing a "union" with another method
      matcher).</p><p>The <tt class="literal">ClassFilter</tt> interface is used to restrict
      the pointcut to a given set of target classes. If the
      <tt class="literal">matches()</tt> method always returns true, all target
      classes will be matched:</p><pre class="programlisting">public interface ClassFilter {

    boolean matches(Class clazz);
}</pre><p>The <tt class="literal">MethodMatcher</tt> interface is normally more
      important. The complete interface is shown below:</p><pre class="programlisting">public interface MethodMatcher {

    boolean matches(Method m, Class targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class targetClass, Object[] args);
}</pre><p>The <tt class="literal">matches(Method, Class) </tt>method is used to
      test whether this pointcut will ever match a given method on a target
      class. This evaluation can be performed when an AOP proxy is created, to
      avoid the need for a test on every method invocation. If the 2-argument
      matches method returns true for a given method, and the
      <tt class="literal">isRuntime()</tt> method for the MethodMatcher returns
      true, the 3-argument matches method will be invoked on every method
      invocation. This enables a pointcut to look at the arguments passed to
      the method invocation immediately before the target advice is to
      execute.</p><p>Most MethodMatchers are static, meaning that their
      <tt class="literal">isRuntime()</tt> method returns false. In this case, the
      3-argument matches method will never be invoked.</p><i><span class="remark">If possible, try to make pointcuts static, allowing the AOP
      framework to cache the results of pointcut evaluation when an AOP proxy
      is created.</span></i></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2996"></a>5.2.2.&nbsp;Operations on pointcuts</h3></div></div><div></div></div><p>Spring supports operations on pointcuts: notably,
      <span class="emphasis"><em>union</em></span> and <span class="emphasis"><em>intersection</em></span>.</p><p>Union means the methods that either pointcut matches.</p><p>Intersection means the methods that both pointcuts match.</p><p>Union is usually more useful.</p><p>Pointcuts can be composed using the static methods in the
      <span class="emphasis"><em>org.springframework.aop.support.Pointcuts</em></span> class, or
      using the <span class="emphasis"><em>ComposablePointcut</em></span> class in the same
      package.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3021"></a>5.2.3.&nbsp;Convenience pointcut implementations</h3></div></div><div></div></div><p>Spring provides several convenient pointcut implementations. Some
      can be used out of the box; others are intended to be subclassed in
      application-specific pointcuts.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3026"></a>5.2.3.1.&nbsp;Static pointcuts</h4></div></div><div></div></div><p>Static pointcuts are based on method and target class, and
        cannot take into account the method's arguments. Static pointcuts are
        sufficient--and best--for most usages. It's possible for Spring to
        evaluate a static pointcut only once, when a method is first invoked:
        after that, there is no need to evaluate the pointcut again with each
        method invocation.</p><p>Let's consider some static pointcut implementations included
        with Spring.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3033"></a>5.2.3.1.1.&nbsp;Regular expression pointcuts</h5></div></div><div></div></div><p>One obvious way to specific static pointcuts is regular
          expressions. Several AOP frameworks besides Spring make this
          possible.
          <tt class="literal">org.springframework.aop.support.RegexpMethodPointcut</tt>
          is a generic regular expression pointcut, using Perl 5 regular
          expression syntax.</p><p>Using this class, you can provide a list of pattern Strings.
          If any of these is a match, the pointcut will evaluate to true. (So
          the result is effectively the union of these pointcuts.)</p><p>The usage is shown below:</p><pre class="programlisting">&lt;bean id="settersAndAbsquatulatePointcut" 
    class="org.springframework.aop.support.RegexpMethodPointcut"&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*get.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>A convenience subclass of
          <tt class="literal">RegexpMethodPointcut</tt>,
          <tt class="literal">RegexpMethodPointcutAdvisor</tt>, allows us to
          reference an Advice also. (Remember that an Advice can be an
          interceptor, before advice, throws advice etc.) This simplifies
          wiring, as the one bean serves as both pointcut and advisor, as
          shown below:</p><pre class="programlisting">&lt;bean id="settersAndAbsquatulateAdvisor" 
    class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
    &lt;property name="advice"&gt;
        &lt;ref local="beanNameOfAopAllianceInterceptor"/&gt;
    &lt;/property&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*get.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>RegexpMethodPointcutAdvisor</em></span> can be used
          with any Advice type.</p><i><span class="remark">The RegexpMethodPointcut class requires the Jakarta ORO
          regular expression package.</span></i></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3065"></a>5.2.3.1.2.&nbsp;Attribute-driven pointcuts</h5></div></div><div></div></div><p>An important type of static pointcut is a
          <span class="emphasis"><em>metadata-driven</em></span> pointcut. This uses the values
          of metadata attributes: typically, source-level metadata.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3073"></a>5.2.3.2.&nbsp;Dynamic pointcuts</h4></div></div><div></div></div><p>Dynamic pointcuts are costlier to evaluate than static
        pointcuts. They take into account method
        <span class="emphasis"><em>arguments</em></span>, as well as static information. This
        means that they must be evaluated with every method invocation; the
        result cannot be cached, as arguments will vary.</p><p>The main example is the <tt class="literal">control flow</tt>
        pointcut.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3086"></a>5.2.3.2.1.&nbsp;Control flow pointcuts</h5></div></div><div></div></div><p>Spring control flow pointcuts are conceptually similar to
          AspectJ <span class="emphasis"><em>cflow</em></span> pointcuts, although less
          powerful. (There is currently no way to specify that a pointcut
          executes below another pointcut.) A control flow pointcut matches
          the current call stack. For example, it might fire if the joinpoint
          was invoked by a method in the <tt class="literal">com.mycompany.web</tt>
          package, or by the <tt class="literal">SomeCaller</tt> class. Control flow
          pointcuts are specified using the
          <tt class="literal">org.springframework.aop.support.ControlFlowPointcut
          </tt>class.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Control flow pointcuts are significantly more expensive to
              evaluate at runtime than even other dynamic pointcuts. In Java
              1.4, the cost is about 5 times that of other dynamic pointcuts;
              in Java 1.3 more than 10.</p></td></tr></table></div></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3106"></a>5.2.4.&nbsp;Pointcut superclasses</h3></div></div><div></div></div><p>Spring provides useful pointcut superclasses to help you to
      implement your own pointcuts.</p><p>Because static pointcuts are most useful, you'll probably subclass
      StaticMethodMatcherPointcut, as shown below. This requires implemented
      just one abstract method (although it's possible to override other
      methods to customize behavior):</p><pre class="programlisting">class TestStaticPointcut extends StaticMethodMatcherPointcut {

    public boolean matches(Method m, Class targetClass) {
        // return true if custom criteria match
    }
}</pre><p>There are also superclasses for dynamic pointcuts.</p><p>You can use custom pointcuts with any advice type in Spring 1.0
      RC2 and above.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3119"></a>5.2.5.&nbsp;Custom pointcuts</h3></div></div><div></div></div><p>Because pointcuts in Spring are Java classes, rather than language
      features (as in AspectJ) it's possible to declare custom pointcuts,
      whether static or dynamic. However, there is no support out of the box
      for the sophisticated pointcut expressions that can be coded in AspectJ
      syntax. However, custom pointcuts in Spring can be arbitrarily
      complex.</p><i><span class="remark">Later versions of Spring may offer support for "semantic
      pointcuts" as offered by JAC: for example, "all methods that change
      instance variables in the target object."</span></i></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3126"></a>5.3.&nbsp;Advice types in Spring</h2></div></div><div></div></div><p>Let's now look at how Spring AOP handles advice.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3131"></a>5.3.1.&nbsp;Advice lifecycles</h3></div></div><div></div></div><p>Spring advices can be shared across all advised objects, or unique
      to each advised object. This corresponds to
      <span class="emphasis"><em>per-class</em></span> or <span class="emphasis"><em>per-instance</em></span>
      advice.</p><p>Per-class advice is used most often. It is appropriate for generic
      advice such as transaction advisors. These do not depend on the state of
      the proxied object or add new state; they merely act on the method and
      arguments.</p><p>Per-instance advice is appropriate for introductions, to support
      mixins. In this case, the advice adds state to the proxied
      object.</p><p>It's possible to use a mix of shared and per-instance advice in
      the same AOP proxy.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-advice-types"></a>5.3.2.&nbsp;Advice types in Spring</h3></div></div><div></div></div><p>Spring provides several advice types out of the box, and is
      extensible to support arbitrary advice types. Let us look at the basic
      concepts and standard advice types.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3153"></a>5.3.2.1.&nbsp;Interception around advice</h4></div></div><div></div></div><p>The most fundamental advice type in Spring is
        <span class="emphasis"><em>interception around advice</em></span>.</p><p>Spring is compliant with the AOP Alliance interface for around
        advice using method interception. MethodInterceptors implementing
        around advice should implement the following interface:</p><pre class="programlisting">public interface MethodInterceptor extends Interceptor {
  
    Object invoke(MethodInvocation invocation) throws Throwable;
}</pre><p>The <span class="emphasis"><em>MethodInvocation</em></span> argument to the
        <span class="emphasis"><em>invoke()</em></span> method exposes the method being invoked;
        the target joinpoint; the AOP proxy; and the arguments to the method.
        The <span class="emphasis"><em>invoke()</em></span> method should return the
        invocation's result: the return value of the joinpoint.</p><p>A simple <span class="emphasis"><em>MethodInterceptor</em></span> implementation
        looks as follows:</p><pre class="programlisting">public class DebugInterceptor implements MethodInterceptor {

    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before: invocation=[" + invocation + "]");
        Object rval = invocation.proceed();
        System.out.println("Invocation returned");
        return rval;
    }
}</pre><p>Note the call to the MethodInvocation's
        <span class="emphasis"><em>proceed()</em></span> method. This proceeds down the
        interceptor chain towards the joinpoint. Most interceptors will invoke
        this method, and return its return value. However, a
        MethodInterceptor, like any around advice, can return a different
        value or throw an exception rather than invoke the proceed method.
        However, you don't want to do this without good reason!</p><i><span class="remark">MethodInterceptors offer interoperability with other AOP
        Alliance-compliant AOP implementations. The other advice types
        discussed in the remainder of this section implement common AOP
        concepts, but in a Spring-specific way. While there is an advantage in
        using the most specific advice type, stick with MethodInterceptor
        around advice if you are likely to want to run the aspect in another
        AOP framework. Note that pointcuts are not currently interoperable
        between frameworks, and the AOP Alliance does not currently define
        pointcut interfaces.</span></i></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3190"></a>5.3.2.2.&nbsp;Before advice</h4></div></div><div></div></div><p>A simpler advice type is a <span class="bold"><b>before
        advice</b></span>. This does not need a
        <tt class="literal">MethodInvocation</tt> object, since it will only be
        called before entering the method.</p><p>The main advantage of a before advice is that there is no need
        to invoke the <tt class="literal">proceed() </tt>method, and therefore no
        possibility of inadvertently failing to proceed down the interceptor
        chain.</p><p>The <tt class="literal">MethodBeforeAdvice</tt> interface is shown
        below. (Spring's API design would allow for field before advice,
        although the usual objects apply to field interception and it's
        unlikely that Spring will ever implement it).</p><pre class="programlisting">public interface MethodBeforeAdvice extends BeforeAdvice {

    void before(Method m, Object[] args, Object target) throws Throwable;
}</pre><p>Note the the return type is <tt class="literal">void</tt>. Before
        advice can insert custom behavior before the joinpoint executes, but
        cannot change the return value. If a before advice throws an
        exception, this will abort further execution of the interceptor chain.
        The exception will propagate back up the interceptor chain. If it is
        unchecked, or on the signature of the invoked method, it will be
        passed directly to the client; otherwise it will be wrapped in an
        unchecked exception by the AOP proxy.</p><p>An example of a before advice in Spring, which counts all
        method invocations:</p><pre class="programlisting">public class CountingBeforeAdvice implements MethodBeforeAdvice {
    private int count;
    public void before(Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() { 
        return count; 
    }
}</pre><i><span class="remark">Before advice can be used with any pointcut.</span></i></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3224"></a>5.3.2.3.&nbsp;Throws advice</h4></div></div><div></div></div><p><span class="bold"><b>Throws advice</b></span> is invoked after
        the return of the joinpoint if the joinpoint threw an exception.
        Spring offers typed throws advice. Note that this means that the
        <tt class="literal">org.springframework.aop.ThrowsAdvice</tt> interface does
        not contain any methods: it is a tag interface identifying that the
        given object implements one or more typed throws advice methods. These
        should be of form</p><pre class="programlisting">afterThrowing([Method], [args], [target], subclassOfThrowable) </pre><p>Only the last argument is required. Thus there from one to four
        arguments, depending on whether the advice method is interested in the
        method and arguments. The following are examples of throws
        advices.</p><p>This advice will be invoked if a
        <tt class="literal">RemoteException</tt> is thrown (including
        subclasses):</p><pre class="programlisting">public  class RemoteThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
}</pre><p>The following advice is invoked if a
        <span class="emphasis"><em>ServletException</em></span> is thrown. Unlike the above
        advice, it declares 4 arguments, so that it has access to the invoked
        method, method arguments and target object:</p><pre class="programlisting">public static class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something will all arguments
    }
}</pre><p>The final example illustrates how these two methods could be
        used in a single class, which handles both
        <tt class="literal">RemoteException</tt> and
        <tt class="literal">ServletException</tt>. Any number of throws advice
        methods can be combined in a single class.</p><pre class="programlisting">public static class CombinedThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
 
    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something will all arguments
    }
}</pre><i><span class="remark">Throws advice can be used with any pointcut.</span></i></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3264"></a>5.3.2.4.&nbsp;After Returning advice</h4></div></div><div></div></div><p>An after returning advice in Spring must implement the
        <span class="emphasis"><em>org.springframework.aop.AfterReturningAdvice</em></span>
        interface, shown below:</p><pre class="programlisting">public interface AfterReturningAdvice extends Advice {

    void afterReturning(Object returnValue, Method m, Object[] args, Object target) 
            throws Throwable;
}</pre><p>An after returning advice has access to the return value (which
        it cannot modify), invoked method, methods arguments and
        target.</p><p>The following after returning advice counts all successful
        method invocations that have not thrown exceptions:</p><pre class="programlisting">public class CountingAfterReturningAdvice implements AfterReturningAdvice {
    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</pre><p>This advice doesn't change the execution path. If it throws an
        exception, this will be thrown up the interceptor chain instead of the
        return value.</p><i><span class="remark">After returning advice can be used with any pointcut.</span></i></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3284"></a>5.3.2.5.&nbsp;Introduction advice</h4></div></div><div></div></div><p>Spring treats introduction advice as a special kind of
        interception advice.</p><p>Introduction requires an <tt class="literal">IntroductionAdvisor</tt>,
        and an <tt class="literal">IntroductionInterceptor</tt>, implementing the
        following interface:</p><pre class="programlisting">public interface IntroductionInterceptor extends MethodInterceptor {

    boolean implementsInterface(Class intf);
}</pre><p>The <tt class="literal">invoke() </tt>method inherited from the AOP
        Alliance <tt class="literal">MethodInterceptor</tt> interface must implement
        the introduction: that is, if the invoked method is on an introduced
        interface, the introduction interceptor is responsible for handling
        the method call--it cannot invoke <tt class="literal">proceed()</tt>.</p><p>Introduction advice cannot be used with any pointcut, as it
        applies only at class, rather than method, level. You can only use
        introduction advice with the InterceptionIntroductionAdvisor, which
        has the following methods:</p><pre class="programlisting">public interface InterceptionIntroductionAdvisor extends InterceptionAdvisor {

    ClassFilter getClassFilter();

    IntroductionInterceptor getIntroductionInterceptor();

    Class[] getInterfaces();
}</pre><p>There is no <tt class="literal">MethodMatcher</tt>, and hence no
        <tt class="literal">Pointcut</tt>, associated with introduction advice. Only
        class filtering is logical.</p><p>The <tt class="literal">getInterfaces()</tt> method returns the
        interfaces introduced by this advisor.</p><p>Let's look at a simple example from the Spring test suite. Let's
        suppose we want to introduce the following interface to one or more
        objects:</p><pre class="programlisting">public interface Lockable {
    void lock();
    void unlock();
    boolean locked();
}</pre><p>This illustrates a <span class="bold"><b>mixin</b></span>. We
        want to be able to cast advised objects to Lockable, whatever their
        type, and call lock and unlock methods. If we call the lock() method,
        we want all setter methods to throw a
        <tt class="literal">LockedException</tt>. Thus we can add an aspect that
        provides the ability to make objects immutable, without them having
        any knowledge of it: a good example of AOP.</p><p>Firstly, we'll need an
        <tt class="literal">IntroductionInterceptor</tt> that does the heavy
        lifting. In this case, we extend the
        <tt class="literal">org.springframework.aop.support.DelegatingIntroductionInterceptor</tt>
        convenience class. We could implement IntroductionInterceptor
        directly, but using
        <tt class="literal">DelegatingIntroductionInterceptor</tt> is best for most
        cases.</p><p>The <tt class="literal">DelegatingIntroductionInterceptor</tt> is
        designed to delegate an introduction to an actual implementation of
        the introduced interface(s), concealing the use of interception to do
        so. The delegate can be set to any object using a constructor
        argument; the default delegate (when the no-arg constructor is used)
        is this. Thus in the example below, the delegate is the
        <tt class="literal">LockMixin</tt> subclass of
        <tt class="literal">DelegatingIntroductionInterceptor</tt>. Given a delegate
        (by default itself) a
        <tt class="literal">DelegatingIntroductionInterceptor</tt> instance looks
        for all interfaces implemented by the delegate (other than
        IntroductionInterceptor), and will support introductions against any
        of them. It's possible for subclasses such as
        <tt class="literal">LockMixin</tt> to call the
        <tt class="literal">suppressInterflace(Class intf) </tt>method to suppress
        interfaces that should not be exposed. However, no matter how many
        interfaces an <tt class="literal">IntroductionInterceptor</tt> is prepared
        to support, the <tt class="literal">IntroductionAdvisor</tt> used will
        control which interfaces are actually exposed. An introduced interface
        will conceal any implementation of the same interface by the
        target.</p><p>Thus LockMixin subclasses
        <tt class="literal">DelegatingIntroductionInterceptor</tt> and implements
        Lockable itself. The superclass automatically picks up that Lockable
        can be supported for introduction, so we don't need to specify that.
        We could introduce any number of interfaces in this way.</p><p>Note the use of the <tt class="literal">locked</tt> instance variable.
        This effectively adds additional state to that held in the target
        object.</p><pre class="programlisting">public class LockMixin extends DelegatingIntroductionInterceptor 
    implements Lockable {

    private boolean locked;

    public void lock() {
        this.locked = true;
    }

    public void unlock() {
        this.locked = false;
    }

    public boolean locked() {
        return this.locked;
    }

    public Object invoke(MethodInvocation invocation) throws Throwable {
        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0)
            throw new LockedException();
        return super.invoke(invocation);
    }

}</pre><p>Often it isn't necessary to override the <tt class="literal">invoke()
        </tt>method: the
        <tt class="literal">DelegatingIntroductionInterceptor</tt>
        implementation--which calls the delegate method if the method is
        introduced, otherwise proceeds towards the joinpoint--is usually
        sufficient. In the present case, we need to add a check: no setter
        method can be invoked if in locked mode.</p><p>The introduction advisor required is simple. All it needs to do
        is hold a distinct <tt class="literal">LockMixin</tt> instance, and specify
        the introduced interfaces--in this case, just
        <tt class="literal">Lockable</tt>. A more complex example might take a
        reference to the introduction interceptor (which would be defined as a
        prototype): in this case, there's no configuration relevant for a
        <tt class="literal">LockMixin</tt>, so we simply create it using
        <tt class="literal">new</tt>.</p><pre class="programlisting">public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

    public LockMixinAdvisor() {
        super(new LockMixin(), Lockable.class);
    }
}</pre><p>We can apply this advisor very simply: it requires no
        configuration. (However, it <span class="emphasis"><em>is</em></span> necessary: It's
        impossible to use an <tt class="literal">IntroductionInterceptor</tt>
        without an <span class="emphasis"><em>IntroductionAdvisor</em></span>.) As usual with
        introductions, the advisor must be per-instance, as it is stateful. We
        need a different instance of <tt class="literal">LockMixinAdvisor</tt>, and
        hence <tt class="literal">LockMixin</tt>, for each advised object. The
        advisor comprises part of the advised object's state.</p><p>We can apply this advisor programmatically, using the
        <tt class="literal">Advised.addAdvisor() </tt>method, or (the recommended
        way) in XML configuration, like any other advisor. All proxy creation
        choices discussed below, including "auto proxy creators," correctly
        handle introductions and stateful mixins.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3437"></a>5.4.&nbsp;Advisors in Spring</h2></div></div><div></div></div><p>In Spring, an Advisor is a modularization of an aspect. Advisors
    typically incorporate both an advice and a pointcut.</p><p>Apart from the special case of introductions, any advisor can be
    used with any advice.
    <tt class="literal">org.springframework.aop.support.DefaultPointcutAdvisor</tt>
    is the most commonly used advisor class. For example, it can be used with
    a <tt class="literal">MethodInterceptor</tt>, <tt class="literal">BeforeAdvice</tt> or
    <tt class="literal">ThrowsAdvice</tt>.</p><p>It is possible to mix advisor and advice types in Spring in the same
    AOP proxy. For example, you could use a interception around advice, throws
    advice and before advice in one proxy configuration: Spring will
    automatically create the necessary create interceptor chain.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-pfb"></a>5.5.&nbsp;Using the ProxyFactoryBean to create AOP proxies</h2></div></div><div></div></div><p>If you're using the Spring IoC container (an ApplicationContext or
    BeanFactory) for your business objects--and you should be!--you will want
    to use one of Spring's AOP FactoryBeans. (Remember that a factory bean
    introduces a layer of indirection, enabling it to create objects of a
    different type).</p><p>The basic way to create an AOP proxy in Spring is to use the
    <span class="emphasis"><em>org.springframework.aop.framework.ProxyFactoryBean</em></span>.
    This gives complete control over the pointcuts and advice that will apply,
    and their ordering. However, there are simpler options that are preferable
    if you don't need such control.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pfb-1"></a>5.5.1.&nbsp;Basics</h3></div></div><div></div></div><p>The <tt class="literal">ProxyFactoryBean</tt>, like other Spring
      <tt class="literal">FactoryBean</tt> implementations, introduces a level of
      indirection. If you define a <tt class="literal">ProxyFactoryBean</tt> with
      name <tt class="literal">foo</tt>, what objects referencing
      <tt class="literal">foo</tt> see is not the
      <tt class="literal">ProxyFactoryBean</tt> instance itself, but an object
      created by the <tt class="literal">ProxyFactoryBean's</tt> implementation of
      the <tt class="literal">getObject() </tt>method. This method will create an
      AOP proxy wrapping a target object.</p><p>One of the most important benefits of using a
      <tt class="literal">ProxyFactoryBean</tt> or other IoC-aware class to create
      AOP proxies, is that it means that advices and pointcuts can also be
      managed by IoC. This is a powerful feature, enabling certain approaches
      that are hard to achieve with other AOP frameworks. For example, an
      advice may itself reference application objects (besides the target,
      which should be available in any AOP framework), benefiting from all the
      pluggability provided by Dependency Injection.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pfb-2"></a>5.5.2.&nbsp;JavaBean properties</h3></div></div><div></div></div><p>Like most FactoryBean implementations provided with Spring,
      <tt class="literal">ProxyFactoryBean</tt> is itself a JavaBean. Its properties
      are used to:</p><div class="itemizedlist"><ul type="disc"><li><p>Specify the target you want to proxy</p></li><li><p>Specify whether to use CGLIB</p></li></ul></div><p>Some key properties are inherited from
      <tt class="literal">org.springframework.aop.framework.ProxyConfig</tt>: the
      superclass for all AOP proxy factories. These include:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">proxyTargetClass</tt>: true if we should proxy
          the target class, rather than its interfaces. If this is true we
          need to use CGLIB.</p></li><li><p><tt class="literal">optimize</tt>: whether to apply aggressive
          optimization to created proxies. Don't use this setting unless you
          understand how the relevant AOP proxy handles optimization. This is
          currently used only for CGLIB proxies; it has no effect with JDK
          dynamic proxies (the default).</p></li><li><p><tt class="literal">frozen</tt>: whether advice changes should be
          disallowed once the proxy factory has been configured. Default is
          false.</p></li><li><p><tt class="literal">exposeProxy</tt>: whether the current proxy
          should be exposed in a ThreadLocal so that it can be accessed by the
          target. (It's available via the MethodInvocation without the need
          for a ThreadLocal.) If a target needs to obtain the proxy and
          exposeProxy is true, the target can use the
          <tt class="literal">AopContext.currentProxy()</tt> method.</p></li><li><p><tt class="literal">aopProxyFactory</tt>: the implementation of
          AopProxyFactory to use. Offers a way of customizing whether to use
          dynamic proxies, CGLIB or any other proxy strategy. The default
          implementation will choose dynamic proxies or CGLIB appropriately.
          There should be no need to use this property; it's intended to allow
          the addition of new proxy types in Spring 1.1.</p></li></ul></div><p>Other properties specific to <tt class="literal">ProxyFactory</tt>Bean
      include:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">proxyInterfaces</tt>: array of String interface
          names. If this isn't supplied, a CGLIB proxy for the target class
          will be used</p></li><li><p><tt class="literal">interceptorNames</tt>: String array of Advisor,
          interceptor or other advice names to apply. Ordering is significant.
          First come, first serve that is. The first interceptor in the list
          will be the first to be able to interceptor the invocation (of
          course if it concerns a regular <tt class="literal">MethodInterceptor</tt> or
          <tt class="literal">BeforeAdvice</tt>.</p><p>The names are bean names in the current factory, including bean
          names from ancestor factories. You can't mention bean references
          here since doing so would result in the ProxyFactoryBean ignoring
          the singleton setting of the advise.</p><p>You can append an interceptor name with an asterisk (*).
          This will result in the application of all advisor beans with names starting
          with the part before the asterisk to be applied. An example of using
          this feature can be found below.</p></li><li><p>singleton: whether or not the factory should return a single
          object, no matter how often the <tt class="literal">getObject()</tt>
          method is called. Several <tt class="literal">FactoryBean</tt>
          implementations offer such a method. Default value is true. If you
          want to use stateful advice--for example, for stateful mixins--use
          prototype advices along with a singleton value of false.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3586"></a>5.5.3.&nbsp;Proxying interfaces</h3></div></div><div></div></div><p>Let's look at a simple example of ProxyFactoryBean in action. This
      example involves:</p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>target bean</em></span> that will be proxied. This
          is the "personTarget" bean definition in the example below.</p></li><li><p>An Advisor and an Interceptor used to provide advice.</p></li><li><p>An AOP proxy bean definition specifying the target object (the
          personTarget bean) and the interfaces to proxy, along with the
          advices to apply.</p></li></ul></div><pre class="programlisting">&lt;bean id="personTarget" class="com.mycompany.PersonImpl"&gt;
    &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
    &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"&gt;
&lt;/bean&gt;

&lt;bean id="person" 
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;

    &lt;property name="target"&gt;&lt;ref local="personTarget"/&gt;&lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the <tt class="literal">interceptorNames</tt> property takes a
      list of String: the bean names of the interceptor or advisors in the
      current factory. Advisors, interceptors, before, after returning and
      throws advice objects can be used. The ordering of advisors is
      significant.</p><i><span class="remark">You might be wondering why the list doesn't hold bean
      references. The reason for this is that if the ProxyFactoryBean's
      singleton property is set to false, it must be able to return
      independent proxy instances. If any of the advisors is itself a
      prototype, an independent instance would need to be returned, so it's
      necessary to be able to obtain an instance of the prototype from the
      factory; holding a reference isn't sufficient.</span></i><p>The "person" bean definition above can be used in place of a
      Person implementation, as follows:</p><pre class="programlisting">Person person = (Person) factory.getBean("person");</pre><p>Other beans in the same IoC context can express a strongly typed
      dependency on it, as with an ordinary Java object:</p><pre class="programlisting">&lt;bean id="personUser" class="com.mycompany.PersonUser"&gt;
    &lt;property name="person"&gt;&lt;ref local="person" /&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">PersonUser</tt> class in this example would
      expose a property of type Person. As far as it's concerned, the AOP
      proxy can be used transparently in place of a "real" person
      implementation. However, its class would be a dynamic proxy class. It
      would be possible to cast it to the <tt class="literal">Advised</tt> interface
      (discussed below).</p><p>It's possible to conceal the distinction between target and proxy
      using an anonymous <span class="emphasis"><em>inner bean</em></span>, as follows. Only the
      <tt class="literal">ProxyFactoryBean</tt> definition is different; the advice
      is included only for completeness:</p><pre class="programlisting">&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"&gt;
&lt;/bean&gt;

&lt;bean id="person" 
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;

    &lt;!-- Use inner bean, not local reference to target --&gt;
    &lt;property name="target"&gt;
        &lt;bean class="com.mycompany.PersonImpl"&gt;
            &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
            &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
        &lt;/bean&gt;
   &lt;/property&gt;

    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>This has the advantage that there's only one object of type
      <tt class="literal">Person</tt>: useful if we want to prevent users of the
      application context obtaining a reference to the un-advised object, or
      need to avoid any ambiguity with Spring IoC
      <span class="emphasis"><em>autowiring</em></span>. There's also arguably an advantage in
      that the ProxyFactoryBean definition is self-contained. However, there
      are times when being able to obtain the un-advised target from the
      factory might actually be an <span class="emphasis"><em>advantage</em></span>: for
      example, in certain test scenarios.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3653"></a>5.5.4.&nbsp;Proxying classes</h3></div></div><div></div></div><p>What if you need to proxy a class, rather than one or more
      interfaces?</p><p>Imagine that in our example above, there was no
      <tt class="literal">Person</tt> interface: we needed to advise a class called
      <tt class="literal">Person</tt> that didn't implement any business interface.
      In this case, you can configure Spring to use CGLIB proxying, rather
      than dynamic proxies. Simply set the <tt class="literal">proxyTargetClass</tt>
      property on the ProxyFactoryBean above to true. While it's best to
      program to interfaces, rather than classes, the ability to advise
      classes that don't implement interfaces can be useful when working with
      legacy code. (In general, Spring isn't prescriptive. While it makes it
      easy to apply good practices, it avoids forcing a particular
      approach.)</p><p>If you want to you can force the use of CGLIB in any case, even if
      you do have interfaces.</p><p>CGLIB proxying works by generating a subclass of the target class
      at runtime. Spring configures this generated subclass to delegate method
      calls to the original target: the subclass is used to implement the
      <span class="emphasis"><em>Decorator</em></span> pattern, weaving in the advice.</p><p>CGLIB proxying should generally be transparent to users. However,
      there are some issues to consider:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Final</tt> methods can't be advised, as they
          can't be overridden.</p></li><li><p>You'll need the CGLIB 2 binaries on your classpath; dynamic
          proxies are available with the JDK</p></li></ul></div><p>There's little performance difference between CGLIB proxying and
      dynamic proxies. As of Spring 1.0, dynamic proxies are slightly faster.
      However, this may change in the future. Performance should not be a
      decisive consideration in this case.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3689"></a>5.5.5.&nbsp;Using 'global' advisors</h3></div></div><div></div></div><p>
            By appending an asterisk to an interceptor name, all advisors with
            bean names matching the part before the asterisk, will be added
            to the advisor chain. This can come in handy if you need to add a
            standard set of 'global' advisors:
</p><pre class="programlisting">
&lt;bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="target"&gt;&lt;ref bean="service"/&gt;&lt;/property&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;global*&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;
&lt;bean id="global_performance"
  class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/&gt;
</pre><p>
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-tfb"></a>5.6.&nbsp;Convenient proxy creation</h2></div></div><div></div></div><p>Often we don't need the full power of the
    <tt class="literal">ProxyFactoryBean</tt>, because we're only interested in one
    aspect: For example, transaction management.</p><p>There are a number of convenience factories we can use to create AOP
    proxies when we want to focus on a specific aspect. These are discussed in
    other chapters, so we'll just provide a quick survey of some of them
    here.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3707"></a>5.6.1.&nbsp;TransactionProxyFactoryBean</h3></div></div><div></div></div><p>The <span class="bold"><b>jPetStore</b></span> sample application
      shipped with Spring shows the use of the
      TransactionProxyFactoryBean.</p><p>The <tt class="literal">TransactionProxyFactoryBean</tt> is a subclass
      of <tt class="literal">ProxyConfig</tt>, so basic configuration is shared with
      <tt class="literal">ProxyFactoryBean</tt>. (See list of
      <tt class="literal">ProxyConfig</tt> properties above.)</p><p>The following example from the jPetStore illustrates how this
      works. As with a <tt class="literal">ProxyFactoryBean</tt>, there is a target
      bean definition. Dependencies should be expressed on the proxied factory
      bean definition ("petStore" here), rather than the target POJO
      ("petStoreTarget").</p><p>The <tt class="literal">TransactionProxyFactoryBean</tt> requires a
      target, and information about "transaction attributes," specifying which
      methods should be transactional and the required propagation and other
      settings:</p><pre class="programlisting">&lt;bean id="petStoreTarget" class="org.springframework.samples.jpetstore.domain.logic.PetStoreImpl"&gt;
    &lt;property name="accountDao"&gt;&lt;ref bean="accountDao"/&gt;&lt;/property&gt;
    &lt;!-- Other dependencies omitted --&gt;
&lt;/bean&gt;

&lt;bean id="petStore" 
    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
    &lt;property name="target"&gt;&lt;ref local="petStoreTarget"/&gt;&lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
        &lt;props&gt;
            &lt;prop key="insert*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;prop key="update*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;prop key="*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>As with the <tt class="literal">ProxyFactoryBean</tt>, we might choose
      to use an inner bean to set the value of <tt class="literal">target</tt>
      property, instead of a reference to a top-level target bean.</p><p>The <tt class="literal">TransactionProxyFactoryBean</tt> automatically
      creates a transaction advisor, including a pointcut based on the
      transaction attributes, so only transactional methods are
      advised.</p><p>The <tt class="literal">TransactionProxyFactoryBean</tt> allows the
      specification of "pre" and "post" advice, using the preInterceptors and
      postInterceptors properties. These take Object arrays of interceptors,
      other advice or Advisors to place in the interception chain before or
      after the transaction interceptor. These can be populated using a
      &lt;list&gt; element in XML bean definitions, as follows:</p><pre class="programlisting">&lt;property name="preInterceptors"&gt;
    &lt;list&gt;
        &lt;ref local="authorizationInterceptor"/&gt;
        &lt;ref local="notificationBeforeAdvice"/&gt;
    &lt;/list&gt;
&lt;/property&gt;
&lt;property name="postInterceptors"&gt;
    &lt;list&gt;
        &lt;ref local="myAdvisor"/&gt;
    &lt;/list&gt;
&lt;/property&gt;</pre><p>These properties could be added to the "petStore" bean definition
      above. A common usage is to combine transactionality with declarative
      security: a similar approach to that offered by EJB.</p><p>Because of the use of actual instance references, rather than bean
      names as in <tt class="literal">ProxyFactoryBean</tt>, pre and post
      interceptors can be used only for shared-instance advice. Thus they are
      not useful for stateful advice: for example, in mixins. This is
      consistent with the TransactionProxyFactoryBean's purpose. It provides a
      simple way of doing common transaction setup. If you need more complex,
      customized, AOP, consider using the generic
      <tt class="literal">ProxyFactoryBean</tt>, or an auto proxy creator (see
      below).</p><i><span class="remark">Especially if we view Spring AOP as, in many cases, a
      replacement for EJB, we find that most advice is fairly generic and uses
      a shared-instance model. Declarative transaction management and security
      checks are classic examples.</span></i><p>The <tt class="literal">TransactionProxyFactoryBean</tt> depends on a
      <tt class="literal">PlatformTransactionManager</tt> implementation via its
      <tt class="literal">transactionManager</tt> JavaBean property. This allows for
      pluggable transaction implementation, based on JTA, JDBC or other
      strategies. This relates to the Spring transaction abstraction, rather
      than AOP. We'll discuss the transaction infrastructure in the next
      chapter.</p><i><span class="remark">If you're interested only in declarative transaction management,
      the TransactionProxyFactoryBean is a good solution, and simpler than
      using a ProxyFactoryBean.</span></i></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3788"></a>5.6.2.&nbsp;EJB proxies</h3></div></div><div></div></div><p>Other dedicated proxies create proxies for EJBs, enabling the EJB
      "business methods" interface to be used directly by calling code.
      Calling code does not need to perform JNDI lookups or use EJB create
      methods: A significant improvement in readability and architectural
      flexibility.</p><p>See the chapter on Spring EJB services in this manual for further
      information.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-concise-proxy"></a>5.7.&nbsp;Concise proxy definitions</h2></div></div><div></div></div><p>Especially when defining transactional proxies, you may end up with
    many similar proxy definitions. The use of parent and child bean
    definitions, along with inner bean definitions, can result in much cleaner
    and more concise proxy definitions.</p><p>First a parent, <span class="emphasis"><em>template</em></span>, bean definition is
    created for the proxy:</p><pre class="programlisting">&lt;bean id="txProxyTemplate" abstract="true"
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager"&gt;&lt;ref local="transactionManager"/&gt;&lt;/ref&gt;&lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>This will never be instantiated itself, so may actually be
    incomplete. Then each proxy which needs to be created is just a child bean
    definition, which to wraps the target of the proxy as an inner bean
    definition, since the target will never be used on its own
    anyways.</p><pre class="programlisting">&lt;bean id="myService" parent="txProxyTemplate"&gt;
    &lt;property name="target"&gt;
      &lt;bean class="org.springframework.samples.MyServiceImpl"&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>It is of course possible to override properties from the parent
    template, such as in this case, the transaction propagation
    settings:</p><pre class="programlisting">&lt;bean id="mySpecialService" parent="txProxyTemplate"&gt;
    &lt;property name="target"&gt;
      &lt;bean class="org.springframework.samples.MySpecialServiceImpl"&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
        &lt;prop key="find*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
        &lt;prop key="load*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
        &lt;prop key="store*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that in the example above, we have explicitly marked the parent
    bean definition as <span class="emphasis"><em>abstract</em></span> by using the
    <span class="emphasis"><em>abstract</em></span> attribute, as described <a href="#beans-child-bean-definitions" title="3.5.&nbsp;Abstract and child bean definitions">previously</a>, so that it may
	not actually ever be instantiated. Application contexts (but not
    simple bean factories) will by default pre-instantiate all singletons.
    Therefore it is important (at least for singleton beans) that if you have
    a (parent) bean definition which you intend to use only as a template, and
    this definition specifies a class, you must make sure to set the
    <span class="emphasis"><em>abstract</em></span> attribute to <span class="emphasis"><em>true</em></span>,
    otherwise the application context will actually try to pre-instantiate it.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-prog"></a>5.8.&nbsp;Creating AOP proxies programmatically with the ProxyFactory</h2></div></div><div></div></div><p>It's easy to create AOP proxies programmatically using Spring. This
    enables you to use Spring AOP without dependency on Spring IoC.</p><p>The following listing shows creation of a proxy for a target object,
    with one interceptor and one advisor. The interfaces implemented by the
    target object will automatically be proxied:</p><pre class="programlisting">ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addInterceptor(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</pre><p>The first step is to construct a object of type
    <tt class="literal">org.springframework.aop.framework.ProxyFactory</tt>. You can
    create this with a target object, as in the above example, or specify the
    interfaces to be proxied in an alternate constructor.</p><p>You can add interceptors or advisors, and manipulate them for the
    life of the ProxyFactory. If you add an
    IntroductionInterceptionAroundAdvisor you can cause the proxy to implement
    additional interfaces.</p><p>There are also convenience methods on ProxyFactory (inherited from
    AdvisedSupport) allowing you to add other advice types such as before and
    throws advice. AdvisedSupport is the superclass of both ProxyFactory and
    ProxyFactoryBean.</p><i><span class="remark">Integrating AOP proxy creation with the IoC framework is best
    practice in most applications. We recommend that you externalize
    configuration from Java code with AOP, as in general.</span></i></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3854"></a>5.9.&nbsp;Manipulating advised objects</h2></div></div><div></div></div><p>However you create AOP proxies, you can manipulate them using the
    <tt class="literal">org.springframework.aop.framework.Advised</tt> interface.
    Any AOP proxy can be cast to this interface, whatever other interfaces it
    implements. This interface includes the following methods:</p><pre class="programlisting">Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) 
        throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();</pre><p>The <tt class="literal">getAdvisors()</tt> method will return an Advisor
    for every advisor, interceptor or other advice type that has been added to
    the factory. If you added an Advisor, the returned advisor at this index
    will be the object that you added. If you added an interceptor or other
    advice type, Spring will have wrapped this in an advisor with a pointcut
    that always returns true. Thus if you added a
    <tt class="literal">MethodInterceptor</tt>, the advisor returned for this index
    will be an <tt class="literal">DefaultPointcutAdvisor</tt> returning your
    <tt class="literal">MethodInterceptor</tt> and a pointcut that matches all
    classes and methods.</p><p>The <tt class="literal">addAdvisor()</tt> methods can be used to add any
    Advisor. Usually the advisor holding pointcut and advice will be the
    generic <tt class="literal">DefaultPointcutAdvisor</tt>, which can be used with
    any advice or pointcut (but not for introduction).</p><p>By default, it's possible to add or remove advisors or interceptors
    even once a proxy has been created. The only restriction is that it's
    impossible to add or remove an introduction advisor, as existing proxies
    from the factory will not show the interface change. (You can obtain a new
    proxy from the factory to avoid this problem.)</p><p>A simple example of casting an AOP proxy to the
    <tt class="literal">Advised</tt> interface and examining and manipulating its
    advice:</p><pre class="programlisting">Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + " advisors");

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(new DebugInterceptor());

// Add selective advice using a pointcut
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals("Added two advisors",
     oldAdvisorCount + 2, advised.getAdvisors().length);</pre><i><span class="remark">It's questionable whether it's advisable (no pun intended) to
    modify advice on a business object in production, although there are no
    doubt legitimate usage cases. However, it can be very useful in
    development: for example, in tests. I have sometimes found it very useful
    to be able to add test code in the form of an interceptor or other advice,
    getting inside a method invocation I want to test. (For example, the
    advice can get inside a transaction created for that method: for example,
    to run SQL to check that a database was correctly updated, before marking
    the transaction for roll back.)</span></i><p>Depending on how you created the proxy, you can usually set a
    <tt class="literal">frozen</tt> flag, in which case the
    <tt class="literal">Advised</tt> <tt class="literal">isFrozen()</tt> method will
    return true, and any attempts to modify advice through addition or removal
    will result in an <tt class="literal">AopConfigException</tt>. The ability to
    freeze the state of an advised object is useful in some cases: For
    example, to prevent calling code removing a security interceptor. It may
    also be used in Spring 1.1 to allow aggressive optimization if runtime
    advice modification is known not to be required.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-autoproxy"></a>5.10.&nbsp;Using the "autoproxy" facility</h2></div></div><div></div></div><p>So far we've considered explicit creation of AOP proxies using a
    <tt class="literal">ProxyFactoryBean</tt> or similar factory bean.</p><p>Spring also allows us to use "autoproxy" bean definitions, which can
    automatically proxy selected bean definitions. This is built on Spring
    "bean post processor" infrastructure, which enables modification of any
    bean definition as the container loads.</p><p>In this model, you set up some special bean definitions in your XML
    bean definition file configuring the auto proxy infrastructure. This
    allows you just to declare the targets eligible for autoproxying: you
    don't need to use <tt class="literal">ProxyFactoryBean</tt>.</p><p>There are two ways to do this:</p><div class="itemizedlist"><ul type="disc"><li><p>Using an autoproxy creator that refers to specific beans in the
        current context</p></li><li><p>A special case of autoproxy creation that deserves to be
        considered separately; autoproxy creation driven by source-level
        metadata attributes</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-autoproxy-choices"></a>5.10.1.&nbsp;Autoproxy bean definitions</h3></div></div><div></div></div><p>The <tt class="literal">org.springframework.aop.framework.autoproxy</tt>
      package provides the following standard autoproxy creators.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3944"></a>5.10.1.1.&nbsp;BeanNameAutoProxyCreator</h4></div></div><div></div></div><p>The BeanNameAutoProxyCreator automatically creates AOP proxies
        for beans with names matching literal values or wildcards.</p><pre class="programlisting">&lt;bean id="jdkBeanNameProxyCreator" 
    class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
    &lt;property name="beanNames"&gt;&lt;value&gt;jdk*,onlyJdk&lt;/value&gt;&lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>As with <tt class="literal">ProxyFactoryBean</tt>, there is an
        interceptorNames property rather than a list of interceptor, to allow
        correct behavior for prototype advisors. Named "interceptors" can be
        advisors or any advice type.</p><p>As with auto proxying in general, the main point of using
        <tt class="literal">BeanNameAutoProxyCreator</tt> is to apply the same
        configuration consistently to multiple objects, and with minimal
        volume of configuration. It is a popular choice for applying
        declarative transactions to multiple objects.</p><p>Bean definitions whose names match, such as "jdkMyBean" and
        "onlyJdk" in the above example, are plain old bean definitions with
        the target class. An AOP proxy will be created automatically by the
        <tt class="literal">BeanNameAutoProxyCreator</tt>. The same advice will be
        applied to all matching beans. Note that if advisors are used (rather
        than the interceptor in the above example), the pointcuts may apply
        differently to different beans.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3967"></a>5.10.1.2.&nbsp;DefaultAdvisorAutoProxyCreator</h4></div></div><div></div></div><p>A more general and extremely powerful auto proxy creator is
        <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>. This will
        automagically apply eligible advisors in the current context, without
        the need to include specific bean names in the autoproxy advisor's
        bean definition. It offers the same merit of consistent configuration
        and avoidance of duplication as
        <tt class="literal">BeanNameAutoProxyCreator</tt>.</p><p>Using this mechanism involves:</p><div class="itemizedlist"><ul type="disc"><li><p>Specifying a
            <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> bean
            definition</p></li><li><p>Specifying any number of Advisors in the same or related
            contexts. Note that these <span class="emphasis"><em>must</em></span> be Advisors,
            not just interceptors or other advices. This is necessary because
            there must be a pointcut to evaluate, to check the eligibility of
            each advice to candidate bean definitions.</p></li></ul></div><p>The <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> will
        automatically evaluate the pointcut contained in each advisor, to see
        what (if any) advice it should apply to each business object (such as
        "businessObject1" and "businessObject2" in the example).</p><p>This means that any number of advisors can be applied
        automatically to each business object. If no pointcut in any of the
        advisors matches any method in a business object, the object will not
        be proxied. As bean definitions are added for new business objects,
        they will automatically be proxied if necessary.</p><p>Autoproxying in general has the advantage of making it
        impossible for callers or dependencies to obtain an un-advised object.
        Calling getBean("businessObject1") on this ApplicationContext will
        return an AOP proxy, not the target business object. (The "inner bean"
        idiom shown earlier also offers this benefit.)</p><pre class="programlisting">&lt;bean id="autoProxyCreator"
    class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt;
&lt;/bean&gt;

&lt;bean id="txAdvisor"
    autowire="constructor"
    class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
    &lt;property name="order"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="customAdvisor"
    class="com.mycompany.MyAdvisor"&gt;
&lt;/bean&gt;

&lt;bean id="businessObject1"
    class="com.mycompany.BusinessObject1"&gt;
    &lt;!-- Properties omitted --&gt;
&lt;/bean&gt;

&lt;bean id="businessObject2"
    class="com.mycompany.BusinessObject2"&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> is very
        useful if you want to apply the same advice consistently to many
        business objects. Once the infrastructure definitions are in place,
        you can simply add new business objects without including specific
        proxy configuration. You can also drop in additional aspects very
        easily--for example, tracing or performance monitoring aspects--with
        minimal change to configuration.</p><p>The DefaultAdvisorAutoProxyCreator offers support for filtering
        (using a naming convention so that only certain advisors are
        evaluated, allowing use of multiple, differently configured,
        AdvisorAutoProxyCreators in the same factory) and ordering. Advisors
        can implement the <tt class="literal">org.springframework.core.Ordered</tt>
        interface to ensure correct ordering if this is an issue. The
        TransactionAttributeSourceAdvisor used in the above example has a
        configurable order value; default is unordered.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4015"></a>5.10.1.3.&nbsp;AbstractAdvisorAutoProxyCreator</h4></div></div><div></div></div><p>This is the superclass of DefaultAdvisorAutoProxyCreator. You
        can create your own autoproxy creators by subclassing this class, in
        the unlikely event that advisor definitions offer insufficient
        customization to the behavior of the framework
        <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-autoproxy-metadata"></a>5.10.2.&nbsp;Using metadata-driven auto-proxying</h3></div></div><div></div></div><p>A particularly important type of autoproxying is driven by
      metadata. This produces a similar programming model to .NET
      <tt class="literal">ServicedComponents</tt>. Instead of using XML deployment
      descriptors as in EJB, configuration for transaction management and
      other enterprise services is held in source-level attributes.</p><p>In this case, you use the
      <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>, in combination with
      Advisors that understand metadata attributes. The metadata specifics are
      held in the pointcut part of the candidate advisors, rather than in the
      autoproxy creation class itself.</p><p>This is really a special case of the
      <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>, but deserves
      consideration on its own. (The metadata-aware code is in the pointcuts
      contained in the advisors, not the AOP framework itself.)</p><p>The <tt class="literal">/attributes</tt> directory of the jPetStore
      sample application shows the use of attribute-driven autoproxying. In
      this case, there's no need to use the
      <tt class="literal">TransactionProxyFactoryBean</tt>. Simply defining
      transactional attributes on business objects is sufficient, because of
      the use of metadata-aware pointcuts. The bean definitions include the
      following code, in <tt class="literal">/WEB-INF/declarativeServices.xml</tt>.
      Note that this is generic, and can be used outside the jPetStore:</p><pre class="programlisting">&lt;bean id="autoProxyCreator" 
    class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt;
&lt;/bean&gt;

&lt;bean id="transactionAttributeSource"
    class="org.springframework.transaction.interceptor.AttributesTransactionAttributeSource"
    autowire="constructor"&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"
    autowire="byType"&gt;
&lt;/bean&gt;

&lt;bean id="transactionAdvisor"
    class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"
    autowire="constructor" &gt;
&lt;/bean&gt;

&lt;bean id="attributes"
    class="org.springframework.metadata.commons.CommonsAttributes"
/&gt;</pre><p>The <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> bean
      definition--called "autoProxyCreator" in this case, but the name is
      not significant (it could even be omitted)--will pick up all eligible
			pointcuts in the current application context. In this case, the
			"transactionAdvisor" bean definition, of type
      <tt class="literal">TransactionAttributeSourceAdvisor</tt>, will apply to
      classes or methods carrying a transaction attribute. The
      TransactionAttributeSourceAdvisor depends on a TransactionInterceptor,
      via constructor dependency. The example resolves this via autowiring.
      The <tt class="literal">AttributesTransactionAttributeSource</tt> depends on
      an implementation of the
      <tt class="literal">org.springframework.metadata.Attributes</tt> interface. In
      this fragment, the "attributes" bean satisfies this, using the Jakarta
      Commons Attributes API to obtain attribute information. (The application
      code must have been compiled using the Commons Attributes compilation
      task.)</p><p>The <tt class="literal">TransactionInterceptor</tt> defined here depends
      on a <tt class="literal">PlatformTransactionManager</tt> definition, which is
      not included in this generic file (although it could be) because it will
      be specific to the application's transaction requirements (typically
      JTA, as in this example, or Hibernate, JDO or JDBC):</p><pre class="programlisting">&lt;bean id="transactionManager" 
    class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre><i><span class="remark">If you require only declarative transaction management, using
      these generic XML definitions will result in Spring automatically
      proxying all classes or methods with transaction attributes. You won't
      need to work directly with AOP, and the programming model is similar to
      that of .NET ServicedComponents.</span></i><p>This mechanism is extensible. It's possible to do autoproxying
      based on custom attributes. You need to:</p><div class="itemizedlist"><ul type="disc"><li><p>Define your custom attribute.</p></li><li><p>Specify an Advisor with the necessary advice, including a
          pointcut that is triggered by the presence of the custom attribute
          on a class or method. You may be able to use an existing advice,
          merely implementing a static pointcut that picks up the custom
          attribute.</p></li></ul></div><p>It's possible for such advisors to be unique to each advised class
      (for example, mixins): they simply need to be defined as prototype,
      rather than singleton, bean definitions. For example, the
      <tt class="literal">LockMixin</tt> introduction interceptor from the Spring
      test suite, shown above, could be used in conjunction with an
      attribute-driven pointcut to target a mixin, as shown here. We use the
      generic <tt class="literal">DefaultPointcutAdvisor</tt>, configured using
      JavaBean properties:</p><pre class="programlisting">&lt;bean id="lockMixin"
    class="org.springframework.aop.LockMixin"
    singleton="false"
/&gt;

&lt;bean id="lockableAdvisor"
    class="org.springframework.aop.support.DefaultPointcutAdvisor"
    singleton="false"
&gt;
    &lt;property name="pointcut"&gt;
        &lt;ref local="myAttributeAwarePointcut"/&gt;
    &lt;/property&gt;
    &lt;property name="advice"&gt;
        &lt;ref local="lockMixin"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="anyBean" class="anyclass" ...</pre><p>If the attribute aware pointcut matches any methods in the
      <tt class="literal">anyBean</tt> or other bean definitions, the mixin will be
      applied. Note that both <tt class="literal">lockMixin</tt> and
      <tt class="literal">lockableAdvisor</tt> definitions are prototypes. The
      <tt class="literal">myAttributeAwarePointcut</tt> pointcut can be a singleton
      definition, as it doesn't hold state for individual advised
      objects.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-targetsource"></a>5.11.&nbsp;Using TargetSources</h2></div></div><div></div></div><p>Spring offers the concept of a <span class="emphasis"><em>TargetSource</em></span>,
    expressed in the <tt class="literal">org.springframework.aop.TargetSource</tt>
    interface. This interface is responsible for returning the "target object"
    implementing the joinpoint. The <tt class="literal">TargetSource</tt>
    implementation is asked for a target instance each time the AOP proxy
    handles a method invocation.</p><p>Developers using Spring AOP don't normally need to work directly
    with TargetSources, but this provides a powerful means of supporting
    pooling, hot swappable and other sophisticated targets. For example, a
    pooling TargetSource can return a different target instance for each
    invocation, using a pool to manage instances.</p><p>If you do not specify a TargetSource, a default implementation is
    used that wraps a local object. The same target is returned for each
    invocation (as you would expect).</p><p>Let's look at the standard target sources provided with Spring, and
    how you can use them.</p><i><span class="remark">When using a custom target source, your target will usually need
    to be a prototype rather than a singleton bean definition. This allows
    Spring to create a new target instance when required.</span></i><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-swap"></a>5.11.1.&nbsp;Hot swappable target sources</h3></div></div><div></div></div><p>The
      <tt class="literal">org.springframework.aop.target.HotSwappableTargetSource</tt>
      exists to allow the target of an AOP proxy to be switched while allowing
      callers to keep their references to it.</p><p>Changing the target source's target takes effect immediately. The
      <tt class="literal">HotSwappableTargetSource</tt> is threadsafe.</p><p>You can change the target via the <tt class="literal">swap()</tt> method
      on HotSwappableTargetSource as follows:</p><pre class="programlisting">HotSwappableTargetSource swapper = 
    (HotSwappableTargetSource) beanFactory.getBean("swapper");
Object oldTarget = swapper.swap(newTarget);</pre><p>The XML definitions required look as follows:</p><pre class="programlisting">&lt;bean id="initialTarget" class="mycompany.OldTarget"&gt;
&lt;/bean&gt;

&lt;bean id="swapper" 
    class="org.springframework.aop.target.HotSwappableTargetSource"&gt;
    &lt;constructor-arg&gt;&lt;ref local="initialTarget"/&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="swappable" 
    class="org.springframework.aop.framework.ProxyFactoryBean"
&gt;
    &lt;property name="targetSource"&gt;
        &lt;ref local="swapper"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>The above <tt class="literal">swap()</tt> call changes the target of the
      swappable bean. Clients who hold a reference to that bean will be
      unaware of the change, but will immediately start hitting the new
      target.</p><p>Although this example doesn't add any advice--and it's not
      necessary to add advice to use a <tt class="literal">TargetSource</tt>--of
      course any <tt class="literal">TargetSource</tt> can be used in conjunction
      with arbitrary advice.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-pool"></a>5.11.2.&nbsp;Pooling target sources</h3></div></div><div></div></div><p>Using a pooling target source provides a similar programming model
      to stateless session EJBs, in which a pool of identical instances is
      maintained, with method invocations going to free objects in the
      pool.</p><p>A crucial difference between Spring pooling and SLSB pooling is
      that Spring pooling can be applied to any POJO. As with Spring in
      general, this service can be applied in a non-invasive way.</p><p>Spring provides out-of-the-box support for Jakarta Commons Pool
      1.1, which provides a fairly efficient pooling implementation. You'll
      need the commons-pool Jar on your application's classpath to use this
      feature. It's also possible to subclass
      <tt class="literal">org.springframework.aop.target.AbstractPoolingTargetSource</tt>
      to support any other pooling API.</p><p>Sample configuration is shown below:</p><pre class="programlisting">&lt;bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject" 
    singleton="false"&gt;
    ... properties omitted
&lt;/bean&gt;

&lt;bean id="poolTargetSource" 
    class="org.springframework.aop.target.CommonsPoolTargetSource"&gt;
    &lt;property name="targetBeanName"&gt;&lt;value&gt;businessObjectTarget&lt;/value&gt;&lt;/property&gt;
    &lt;property name="maxSize"&gt;&lt;value&gt;25&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="businessObject" 
    class="org.springframework.aop.framework.ProxyFactoryBean"
&gt;
    &lt;property name="targetSource"&gt;&lt;ref local="poolTargetSource"/&gt;&lt;/property&gt;
    &lt;property name="interceptorNames"&gt;&lt;value&gt;myInterceptor&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the target object--"businessObjectTarget" in the
      example--<span class="emphasis"><em>must</em></span> be a prototype. This allows the
      <tt class="literal">PoolingTargetSource</tt> implementation to create new
      instances of the target to grow the pool as necessary. See the Javadoc
      for <tt class="literal">AbstractPoolingTargetSource</tt> and the concrete
      subclass you wish to use for information about it's properties: maxSize
      is the most basic, and always guaranteed to be present.</p><p>In this case, "myInterceptor" is the name of an interceptor that
      would need to be defined in the same IoC context. However, it isn't
      necessary to specify interceptors to use pooling. If you want only
      pooling, and no other advice, don't set the interceptorNames property at
      all.</p><p>It's possible to configure Spring so as to be able to cast any
      pooled object to the
      <tt class="literal">org.springframework.aop.target.PoolingConfig</tt>
      interface, which exposes information about the configuration and current
      size of the pool through an introduction. You'll need to define an
      advisor like this:</p><pre class="programlisting">&lt;bean id="poolConfigAdvisor" 
    class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
    &lt;property name="targetObject"&gt;&lt;ref local="poolTargetSource" /&gt;&lt;/property&gt;
    &lt;property name="targetMethod"&gt;&lt;value&gt;getPoolingConfigMixin&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>This advisor is obtained by calling a convenience method on the
      <tt class="literal">AbstractPoolingTargetSource</tt> class, hence the use of
      MethodInvokingFactoryBean. This advisor's name ("poolConfigAdvisor"
      here) must be in the list of interceptors names in the ProxyFactoryBean
      exposing the pooled object.</p><p>The cast will look as follows:</p><pre class="programlisting">PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
System.out.println("Max pool size is " + conf.getMaxSize());</pre><i><span class="remark">Pooling stateless service objects is not usually necessary. We
      don't believe it should be the default choice, as most stateless objects
      are naturally thread safe, and instance pooling is problematic if
      resources are cached.</span></i><p>Simpler pooling is available using autoproxying. It's possible to
      set the TargetSources used by any autoproxy creator.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-prototype"></a>5.11.3.&nbsp;Prototype target sources</h3></div></div><div></div></div><p>Setting up a "prototype" target source is similar to a pooling
      TargetSource. In this case, a new instance of the target will be created
      on every method invocation. Although the cost of creating a new object
      isn't high in a modern JVM, the cost of wiring up the new object
      (satisfying its IoC dependencies) may be more expensive. Thus you
      shouldn't use this approach without very good reason.</p><p>To do this, you could modify the
      <tt class="literal">poolTargetSource</tt> definition shown above as follows.
      (I've also changed the name, for clarity.)</p><pre class="programlisting">&lt;bean id="prototypeTargetSource" 
    class="org.springframework.aop.target.PrototypeTargetSource"&gt;
    &lt;property name="targetBeanName"&gt;&lt;value&gt;businessObjectTarget&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>There's only one property: the name of the target bean.
      Inheritance is used in the TargetSource implementations to ensure
      consistent naming. As with the pooling target source, the target bean
      must be a prototype bean definition.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-threadlocal"></a>5.11.4.&nbsp;ThreadLocal target sources</h3></div></div><div></div></div><p>
            ThreadLocal target sources are useful if you need an object to be created
            for each incoming request (per thread that is). The concept of a
            <tt class="literal">ThreadLocal</tt> provide a JDK-wide
            facility to transparently store resource alongside a thread. Setting up a ThreadLocalTargetSource
            is pretty much the same as was explained for the other target sources:
        </p><p>
            </p><pre class="programlisting">
&lt;bean id="threadlocalTargetSource"
  class="org.springframework.aop.target.ThreadLocalTargetSource"&gt;
  &lt;property name="targetBeanName"&gt;&lt;value&gt;businessObjectTarget&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
            </pre><p>
        </p><p>
            <span class="emphasis"><em>ThreadLocals come with serious issues (potentially resulting in memory leaks)
            when incorrectly using them in a multi-threaded and multi-classloader environments. One should
            always consider wrapping a threadlocal in some other class and never directly use the ThreadLocal
            itself (except of course in the wrapper class). Also, one should always remember to correctly set and unset (where the
            latter simply involved a call to ThreadLocal.set(null)) the resource local to the thread.
            Unsetting should be done in any case since not unsetting it might result in problematic behavior.
            Spring's ThreadLocal support is doing this for you and should always be considered in favor of
            using ThreadLocals without other proper handling code.</em></span>
                                           </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-extensibility"></a>5.12.&nbsp;Defining new Advice types</h2></div></div><div></div></div><p>Spring AOP is designed to be extensible. While the interception
    implementation strategy is presently used internally, it is possible to
    support arbitrary advice types in addition to interception around advice,
    before, throws advice and after returning advice, which are supported out
    of the box.</p><p>The <tt class="literal">org.springframework.aop.framework.adapter</tt>
    package is an SPI package allowing support for new custom advice types to
    be added without changing the core framework. The only constraint on a
    custom Advice type is that it must implement the
    <tt class="literal">org.aopalliance.aop.Advice</tt> tag interface.</p><p>Please refer to the
    <tt class="literal">org.springframework.aop.framework.adapter</tt> package's
    Javadocs for further information</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4279"></a>5.13.&nbsp;Further reading and resources</h2></div></div><div></div></div><p>I recommend the excellent <span class="emphasis"><em>AspectJ in Action</em></span> by
    Ramnivas Laddad (Manning, 2003) for an introduction to AOP.</p><p>Please refer to the Spring sample applications for further examples
    of Spring AOP:</p><div class="itemizedlist"><ul type="disc"><li><p>The JPetStore's default configuration illustrates the use of the
        TransactionProxyFactoryBean for declarative transaction
        management</p></li><li><p>The <tt class="literal">/attributes</tt> directory of the JPetStore
        illustrates the use of attribute-driven declarative transaction
        management</p></li></ul></div><p>If you are interested in more advanced capabilities of Spring AOP,
    take a look at the test suite. The test coverage is over 90%, and this
    illustrates advanced features not discussed in this document.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4301"></a>5.14.&nbsp;Roadmap</h2></div></div><div></div></div><p>Spring AOP, like the rest of Spring, is actively developed. The core
    API is stable. Like the rest of Spring, the AOP framework is very modular,
    enabling extension while preserving the fundamental design. Several
    improvements are planned in the Spring 1.1 time frame, which will preserve
    backward compatibility. These include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Performance improvements</em></span>: The creation of
        AOP proxies is handled by a factory via a Strategy interface. Thus we
        can support additional AopProxy types without impacting user code or
        the core implementation. Significant performance optimizations for
        CGLIB proxying are scheduled for the 1.0.3 release, with further
        optimizations by Spring 1.1 in cases where advice will not change at
        runtime. This should produce a significant reduction in the overhead
        of the AOP framework. Note, however, that the overhead of the AOP
        framework is not an issue in normal usage.</p></li><li><p><span class="emphasis"><em>More expressive pointcuts</em></span>: Spring presently
        offers an expressive Pointcut interface, but we can add value through
        adding more Pointcut implementations. We are looking at an integration
        with AspectJ that will allow AspectJ pointcut expressions to be used
        in Spring configuration files. And if you wish to contribute a useful
        Pointcut, please do!</p></li></ul></div><p>The most significant enhancements are likely to concern integration
    with AspectJ, which will be done in cooperation with the AspectJ
    community. We believe that this will provide significant benefits for both
    Spring and AspectJ users, in the following areas:</p><div class="itemizedlist"><ul type="disc"><li><p>Allowing AspectJ aspects to be configured using Spring IoC. This
        has the potential to integrate AspectJ aspects into applications where
        appropriate, in the same way as Spring aspects are integrated into
        application IoC contexts.</p></li><li><p>Allowing the use of AspectJ pointcut expressions within Spring
        configuration to target Spring advice. This has significant benefits
        over devising our own pointcut expression language; AspectJ is both
        well thought out and well documented.</p></li></ul></div><p>Both these integrations should be available in Spring 1.1.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e4328"></a>Chapter&nbsp;6.&nbsp;AspectJ Integration</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4331"></a>6.1.&nbsp;Overview</h2></div></div><div></div></div><p>Spring's proxy-based AOP framework is well suited for handling
    many generic middleware and application-specific problems. However, there
    are times when a more powerful AOP solution is required: for example, if
    we need to add additional fields to a class, or advise fine-grained
    objects that aren't created by the Spring IoC container.</p><p>We recommend the use of AspectJ in such cases. Accordingly, as of
    version 1.1, Spring provides a powerful integration with AspectJ.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4338"></a>6.2.&nbsp;Configuring AspectJ aspects using Spring IoC</h2></div></div><div></div></div><p>The most important part of the Spring/AspectJ integration allows
    Spring to configure AspectJ aspects using Dependency Injection. This
    brings similar benefits to aspects as to objects. For example:</p><div class="itemizedlist"><ul type="disc"><li><p>There is no need for aspects to use ad hoc configuration
        mechanisms; they can be configured in the same, consistent, approach
        used for the entire application.</p></li><li><p>Aspects can depend on application objects. For example, a
        security aspect can depend on a security manager, as we'll see in
        an example shortly. </p></li><li><p>It's possible to obtain a reference to an aspect through the
        relevant Spring context. This can allow for dynamic reconfiguration of
        the aspect.</p></li></ul></div><p>AspectJ aspects can expose JavaBean properties for Setter Injection,
    and even implement Spring lifecycle interfaces such as <tt class="literal">BeanFactoryAware</tt>.</p><i><span class="remark">Note that AspectJ aspects cannot use Constructor Injection or
    Method Injection. This limitation is due to the fact that aspects do not
    have constructors that can be invoked like constructors of objects.</span></i><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4360"></a>6.2.1.&nbsp;"Singleton" aspects</h3></div></div><div></div></div><p>In most cases, AspectJ aspects are singletons, with one instance
      per class loader. This single instance is responsible for advising
      multiple object instances.</p><p>A Spring IoC container cannot instantiate an aspect, as aspects
      don't have callable constructors. But it can obtain a reference to
      an aspect using the static <tt class="literal">aspectOf()</tt> method that
      AspectJ defines for all aspects, and it can inject dependencies into
      that aspect.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4370"></a>6.2.1.1.&nbsp;Example</h4></div></div><div></div></div><p>Consider a security aspect, which depends on a security manager.
        This aspects applies to all changes in the value of the
        <tt class="literal">balance</tt> instance variable in the
        <tt class="literal">Account</tt> class. (We couldn't do this in the same
        way using Spring AOP.)</p><p>The AspectJ code for the aspect (one of the Spring/AspectJ
        samples), is shown below. Note that the dependency on the
        <tt class="literal">SecurityManager</tt> interface is expressed in a
        JavaBean property:</p><pre class="programlisting">public aspect BalanceChangeSecurityAspect {

   private SecurityManager securityManager;

   public void setSecurityManager(SecurityManager securityManager) {
      this.securityManager = securityManager;
   }

   private pointcut balanceChanged() : 
      set(int Account.balance);

   before() : balanceChanged() {
      this.securityManager.checkAuthorizedToModify();
   }
}</pre><p>We configure this aspect in the same way as an ordinary class.
        Note that the way in which we set the property reference is identical.
        Note that we must use the <tt class="literal">factory-method</tt> attribute
        to specify that we want the aspect "created" using the
        <tt class="literal">aspectOf()</tt> static method. In fact, this is
        <span class="emphasis"><em>locating</em></span>, rather than, <tt class="literal">creating</tt>,
        the aspect, but the Spring container doesn't care:</p><pre class="programlisting">&lt;bean id="securityAspect" 
   class="org.springframework.samples.aspectj.bank.BalanceChangeSecurityAspect" 
   factory-method="aspectOf"
&gt;
   &lt;property name="securityManager"&gt;
      &lt;ref local="securityManager"/&gt;
   &lt;/property&gt;
&lt;/bean&gt;</pre><p>We don't need to do anything in Spring configuration to
        target this aspect. It contains the pointcut information in AspectJ
        code that controls where it applies. Thus it can apply even to objects
        not managed by the Spring IoC container.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4408"></a>6.2.1.2.&nbsp;Ordering issues</h4></div></div><div></div></div><p>to be completed</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4413"></a>6.2.2.&nbsp;Non-singleton aspects</h3></div></div><div></div></div><p>** Complete material on pertarget etc.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4418"></a>6.2.3.&nbsp;Gotchas</h3></div></div><div></div></div><p>to be completed</p><p>- Singleton issue</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4425"></a>6.3.&nbsp;Using AspectJ pointcuts to target Spring advice</h2></div></div><div></div></div><p>In a future release of Spring, we plan to provide the ability for
    AspectJ pointcut expressions to be used in Spring XML or other bean
    definition files, to target Spring advice. This will allow some of the
    power of the AspectJ pointcut model to be applied to Spring's
    proxy-based AOP framework. This will work in pure Java, and will not
    require the AspectJ compiler. Only the subset of AspectJ pointcuts
    relating to method invocation will be usable.</p><p>This feature is scheduled for Spring 1.2. It depends on AspectJ
    enhancements. </p><p>This feature replaces our previous plan to create a pointcut
    expression language for Spring.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4434"></a>6.4.&nbsp;Spring aspects for AspectJ</h2></div></div><div></div></div><p>In a future release of Spring (probably 1.2), we will package some
    Spring services, such as the declarative transaction management service,
    as AspectJ aspects. This will enable them to be used by AspectJ users
    without dependence on the Spring AOP framework--potentially, even without
    dependence on the Spring IoC container.</p><p>This feature is probably of more interest to AspectJ users than
    Spring users.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transaction"></a>Chapter&nbsp;7.&nbsp;Transaction management</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4444"></a>7.1.&nbsp;The Spring transaction abstraction</h2></div></div><div></div></div><p>Spring provides a consistent abstraction for transaction management.
    This abstraction is one of the most important of Spring's abstractions,
    and delivers the following benefits:</p><div class="itemizedlist"><ul type="disc"><li><p>Provides a consistent programming model across different
          transaction APIs such as JTA, JDBC, Hibernate, iBATIS Database Layer
          and JDO.</p></li><li><p>Provides a simpler, easier to use, API for programmatic
          transaction management than most of these transaction APIs</p></li><li><p>Integrates with the Spring data access abstraction</p></li><li><p>Supports Spring declarative transaction management</p></li></ul></div><p>Traditionally, J2EE developers have had two choices for transaction
    management: to use <span class="emphasis"><em>global</em></span> or
    <span class="emphasis"><em>local</em></span> transactions. Global transactions are managed
    by the application server, using JTA. Local transactions are
    resource-specific: for example, a transaction associated with a JDBC
    connection. This choice had profound implications. Global transactions
    provide the ability to work with multiple transactional resources. (It's
    worth noting that most applications use a single transaction resource)
    With local transactions, the application server is not involved in
    transaction management, and cannot help ensure correctness across multiple
    resources.</p><p>Global transactions have a significant downside. Code needs to use
    JTA: a cumbersome API to use (partly due to its exception model).
    Furthermore, a JTA <tt class="literal">UserTransaction</tt> normally needs to be
    obtained from JNDI: meaning that we need to use <span class="emphasis"><em>both</em></span>
    JNDI and JTA to use JTA. Obviously all use of global transactions limits
    the reusability of application code, as JTA is normally only available in
    an application server environment.</p><p>The preferred way to use global transactions was via EJB
    <span class="emphasis"><em>CMT</em></span> (<span class="emphasis"><em>Container Managed
    Transaction</em></span>): a form of <span class="bold"><b>declarative
    transaction management</b></span> (as distinguished from <span class="bold"><b>programmatic transaction management</b></span>). EJB CMT
    removes the need for transaction-related JNDI lookups--although of course
    the use of EJB itself necessitates the use of JNDI. It removes most--not
    all--need to write Java code to control transactions. The significant
    downside is that CMT is (obviously) tied to JTA and an application server
    environment; and that it's only available if we choose to implement
    business logic in EJBs, or at least behind a transactional EJB facade. The
    negatives around EJB in general are so great that this is not an
    attractive proposition, when there are alternatives for declarative
    transaction management.</p><p>Local transactions may be easier to use, but also have significant
    disadvantages: They cannot work across multiple transactional resources,
    and tend to invade the programming model. For example, code that manages
    transactions using a JDBC connection cannot run within a global JTA
    transaction.</p><p>Spring resolves these problems. It enables application developers to
    use a consistent programming model <span class="emphasis"><em>in any
    environment</em></span>. You write your code once, and it can benefit from
    different transaction management strategies in different environments.
    Spring provides both declarative and programmatic transaction management.
    Declarative transaction management is preferred by most users, and
    recommended in most cases.</p><p>With programmatic transaction management developers work with the
    Spring transaction abstraction, which can run over any underlying
    transaction infrastructure. With the preferred declarative model
    developers typically write little or no code related to transaction
    management, and hence don't depend on Spring's or any other transaction
    API.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4501"></a>7.2.&nbsp;Transaction strategies</h2></div></div><div></div></div><p>The key to the Spring transaction abstraction is the notion of a
    <span class="emphasis"><em>transaction strategy</em></span>.</p><p>This is captured in the
    <tt class="literal">org.springframework.transaction.PlatformTransactionManager</tt>
    interface, shown below:</p><pre class="programlisting">public interface PlatformTransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition)
        throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}</pre><p>This is primarily an SPI interface, although it can be used
    programmatically. Note that in keeping with Spring's philosophy, this is
    an <span class="emphasis"><em>interface</em></span>. Thus it can easily be mocked or stubbed
    if necessary. Nor is it tied to a lookup strategy such as JNDI:
    PlatformTransactionManager implementations are defined like any other
    object in a Spring IoC container. This benefit alone makes this a
    worthwhile abstraction even when working with JTA: transactional code can
    be tested much more easily than if it directly used JTA.</p><p>In keeping with Spring's philosophy,
    <tt class="literal">TransactionException</tt> is unchecked. Failures of the
    transaction infrastructure are almost invariably fatal. In rare cases
    where application code can recover from them, the application developer
    can still choose to catch and handle
    <tt class="literal">TransactionException</tt>.</p><p>The <tt class="literal">getTransaction() </tt>method returns a
    <tt class="literal">TransactionStatus</tt> object, depending on a
    <tt class="literal">TransactionDefinition</tt> parameter. The returned
    <tt class="literal">TransactionStatus</tt> might represent a new or existing
    transaction (if there was a matching transaction in the current call
    stack).</p><p>As with J2EE transaction contexts, a
    <tt class="literal">TransactionStatus</tt> is associated with a <span class="bold"><b>thread</b></span> of execution.</p><p>The <tt class="literal">TransactionDefinition</tt> interface
    specifies:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b>Transaction isolation</b></span>: The
        degree of isolation this transaction has from the work of other
        transactions. For example, can this transaction see uncommitted writes
        from other transactions?</p></li><li><p><span class="bold"><b>Transaction propagation</b></span>:
        Normally all code executed within a transaction scope will run in that
        transaction. However, there are several options specifying behavior
        if a transactional method is executed when a transaction context
        already exists: For example, simply running in the existing
        transaction (the most common case); or suspending the existing
        transaction and creating a new transaction. Spring offers the
        transaction propagation options familiar from EJB CMT.</p></li><li><p><span class="bold"><b>Transaction timeout</b></span>: How long
        this transaction may run before timing out (automatically being rolled
        back by the underlying transaction infrastructure).</p></li><li><p><span class="bold"><b>Read-only status</b></span>: A read-only
        transaction does not modify any data. Read-only transactions can be a
        useful optimization in some cases (such as when using
        Hibernate).</p></li></ul></div><p>These settings reflect standard concepts. If necessary, please refer
    to a resource discussing transaction isolation levels and other core
    transaction concepts: Understanding such core concepts is essential to
    using Spring or any other transaction management solution.</p><p>The <tt class="literal">TransactionStatus</tt> interface provides a simple
    way for transactional code to control transaction execution and query
    transaction status. The concepts should be familiar, as they are common to
    all transaction APIs:</p><pre class="programlisting">public interface TransactionStatus {

    boolean isNewTransaction();

    void setRollbackOnly();

    boolean isRollbackOnly();
}</pre><p>However Spring transaction management is used, defining the
    <tt class="literal">PlatformTransactionManager</tt> implementation is essential.
    In good Spring fashion, this important definition is made using Inversion
    of Control.</p><p>PlatformTransactionManager implementations normally require
    knowledge of the environment in which they work: JDBC, JTA, Hibernate
    etc.</p><p>The following examples from
    <tt class="literal">dataAccessContext-local.xml</tt> from Spring's <span class="bold"><b>jPetStore</b></span> sample application show how a local
    PlatformTransactionManager implementation can be defined. This will work
    with JDBC.</p><p>We must define a JDBC DataSource, and then use the Spring
    DataSourceTransactionManager, giving it a reference to the
    DataSource.</p><pre class="programlisting">&lt;bean id="dataSource" 
    class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName"&gt;&lt;value&gt;${jdbc.driverClassName}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="url"&gt;&lt;value&gt;${jdbc.url}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="username"&gt;&lt;value&gt;${jdbc.username}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="password"&gt;&lt;value&gt;${jdbc.password}&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The PlatformTransactionManager definition will look like
    this:</p><pre class="programlisting">&lt;bean id="transactionManager" 
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource"&gt;&lt;ref local="dataSource"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>If we use JTA, as in the <tt class="literal">dataAccessContext-jta.xml
    </tt>file from the same sample application, we need to use a
    container DataSource, obtained via JNDI, and a JtaTransactionManager
    implementation. The JtaTransactionManager doesn't need to know about the
    DataSource, or any other specific resources, as it will use the
    container's global transaction management.</p><pre class="programlisting">&lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName"&gt;&lt;value&gt;jdbc/jpetstore&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager" 
    class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre><p>We
    can use Hibernate local transactions easily, as shown in the following
    examples from the Spring <span class="bold"><b>PetClinic</b></span> sample
    application.</p><p>In this case, we need to define a Hibernate LocalSessionFactory,
    which application code will use to obtain Hibernate Sessions.</p><p>The DataSource bean definition will be similar to one of the above
    examples, and is not shown. (If it's a container DataSource it should be
    non-transactional as Spring, rather than the container, will manage
    transactions.)</p><p>The "transactionManager" bean in this case is of class
    HibernateTransactionManager. In the same way as the
    DataSourceTransactionManager needs a reference to the DataSource, the
    HibernateTransactionManager needs a reference to the session
    factory.</p><pre class="programlisting">&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource"&gt;&lt;ref local="dataSource"/&gt;&lt;/property&gt;
    &lt;property name="mappingResources"&gt;
        &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;props&gt;
            &lt;prop key="hibernate.dialect"&gt;${hibernate.dialect}&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager" 
    class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory"&gt;&lt;ref local="sessionFactory"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>With Hibernate and JTA transactions we could simply use the
    JtaTransactionManager as with JDBC or any other resource strategy.</p><pre class="programlisting">&lt;bean id="transactionManager" 
    class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre><p>Note that this is identical to JTA configuration for any resource,
    as these are global transactions, which can enlist any transactional
    resource.</p><i><span class="remark">In all these cases, application code won't need to change at all.
    We can change how transactions are managed merely by changing
    configuration, even if that change means moving from local to global
    transactions or vice versa.</span></i><p>When not using global transactions, you do need to follow one
    special coding convention. Fortunately this is very simple. You need to
    obtain connection or session resources in a special way, to allow the
    relevant PlatformTransactionManager implementation to track connection
    usage, and apply transaction management as necessary.</p><p>For example, if using JDBC, you should not call the
    <tt class="literal">getConnection()</tt> method on a DataSource, but must use
    the Spring
    <tt class="literal">org.springframework.jdbc.datasource.DataSourceUtils</tt>
    class as follows:</p><pre class="programlisting">Connection conn = DataSourceUtils.getConnection(dataSource);</pre><p>This has the added advantage that any
    <tt class="literal">SQLException</tt> will be wrapped in a Spring
    <tt class="literal">CannotGetJdbcConnectionException</tt>--one of Spring's
    hierarchy of unchecked DataAccessExceptions. This gives you more
    information than can easily be obtained from the
    <tt class="literal">SQLException</tt>, and ensures portability across databases:
    even across different persistence technologies.</p><p>This will work fine without Spring transaction management, so you
    can use it whether or not you are using Spring for transaction
    management.</p><p>Of course, once you've used Spring's JDBC support or Hibernate
    support, you won't want to use <tt class="literal">DataSourceUtils</tt> or the
    other helper classes, because you'll be much happier working via the
    Spring abstraction than directly with the relevant APIs. For example, if
    you use the Spring JdbcTemplate or jdbc.object package to simplify your
    use of JDBC, correct connection retrieval happens behind the scenes and
    you won't need to write any special code.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4672"></a>7.3.&nbsp;Programmatic transaction management</h2></div></div><div></div></div><p>Spring provides two means of programmatic transaction
    management:</p><div class="itemizedlist"><ul type="disc"><li><p>Using the <tt class="literal">TransactionTemplate</tt></p></li><li><p>Using a <tt class="literal">PlatformTransactionManager</tt>
        implementation directly</p></li></ul></div><p>We generally recommend the first approach.</p><p>The second approach is similar to using the JTA
    <tt class="literal">UserTransaction</tt> API (although exception handling is
    less cumbersome).</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4696"></a>7.3.1.&nbsp;Using the <tt class="literal">TransactionTemplate</tt></h3></div></div><div></div></div><p>The <tt class="literal">TransactionTemplate</tt> adopts the same
      approach as other Spring <span class="emphasis"><em>templates</em></span> such as
      <tt class="literal">JdbcTemplate</tt> and
      <tt class="literal">HibernateTemplate</tt>. It uses a callback approach, to
      free application code from the working of acquiring and releasing
      resources. (No more try/catch/finally.) Like other templates, a
      <tt class="literal">TransactionTemplate</tt> is threadsafe.</p><p>Application code that must execute in a transaction context looks
      like this. Note that the <tt class="literal">TransactionCallback</tt> can be
      used to return a value:</p><pre class="programlisting">Object result = tt.execute(new TransactionCallback() {
    public Object doInTransaction(TransactionStatus status) {
        updateOperation1();
        return resultOfUpdateOperation2();
    }
});</pre><p>If there's no return value, use a
      <tt class="literal">TransactionCallbackWithoutResult</tt> like this:</p><pre class="programlisting">tt.execute(new TransactionCallbackWithoutResult() {
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        updateOperation1();
        updateOperation2();
    }
});</pre><p>Code within the callback can roll the transaction back by calling
      the <tt class="literal">setRollbackOnly()</tt> method on the
      <tt class="literal">TransactionStatus</tt> object.</p><p>Application classes wishing to use the
      <tt class="literal">TransactionTemplate</tt> must have access to a
      PlatformTransactionManager: usually exposed as a JavaBean property or as
      a constructor argument.</p><p>It's easy to unit test such classes with a mock or stub
      <tt class="literal">PlatformTransactionManager</tt>. There's no JNDI lookup or
      static magic here: it's a simple interface. As usual, you can use Spring
      to simplify your unit testing.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4752"></a>7.3.2.&nbsp;Using the <tt class="literal">PlatformTransactionManager</tt></h3></div></div><div></div></div><p>You can also use the
      <tt class="literal">org.springframework.transaction.PlatformTransactionManager</tt>
      directly to manage your transaction. Simply pass the implementation of
      the PlatformTransactionManager you're using to your bean via a bean
      reference. Then, using the <tt class="literal">TransactionDefinition</tt> and
      <tt class="literal">TransactionStatus</tt> objects you can initiate
      transactions, rollback and commit.</p><pre class="programlisting">DefaultTransactionDefinition def = new DefaultTransactionDefinition();
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = transactionManager.getTransaction(def);

try {
    // execute your business logic here
} catch (MyException ex) {
    transactionManager.rollback(status);
    throw ex;
}
transactionManager.commit(status);</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4771"></a>7.4.&nbsp;Declarative transaction management</h2></div></div><div></div></div><p>Spring also offers declarative transaction management. This is
    enabled by Spring AOP.</p><i><span class="remark">Most Spring users choose declarative transaction management. It is
    the option with the least impact on application code, and hence is most
    consistent with the ideals of a n<span class="emphasis"><em>on-invasive
    </em></span>lightweight container.</span></i><p>It may be helpful to begin by considering EJB CMT and explaining the
    similarities and differences with Spring declarative transaction
    management. The basic approach is similar: It's possible to specify
    transaction behavior (or lack of it) down to individual methods. It's
    possible to make a <tt class="literal">setRollbackOnly() </tt>call within a
    transaction context if necessary. The differences are:</p><div class="itemizedlist"><ul type="disc"><li><p>Unlike EJB CMT, which is tied to JTA, Spring declarative
        transaction management works in any environment. It can work with
        JDBC, JDO, Hibernate or other transactions under the covers, with
        configuration changes only.</p></li><li><p>Spring enables declarative transaction management to be applied
        to any POJO, not just special classes such as EJBs.</p></li><li><p>Spring offers declarative <span class="emphasis"><em>rollback rules</em></span>: a
        feature with no EJB equivalent, which we'll discuss below. Rollback
        can be controlled declaratively, not merely programmatically.</p></li><li><p>Spring gives you an opportunity to customize transactional
        behavior, using AOP. For example, if you want to insert custom
        behavior in the case of transaction rollback, you can. You can also
        add arbitrary advice, along with the transactional advice. With EJB
        CMT, you have no way to influence the container's transaction
        management other than <tt class="literal">setRollbackOnly()</tt>.</p></li><li><p>Spring does not support propagation of transaction contexts
        across remote calls, as do high-end application servers. If you need
        this feature, we recommend that you use EJB. However, don't use this
        feature lightly. Normally we don't want transactions to span remote
        calls.</p></li></ul></div><p>The concept of rollback rules is important: they enable us to
    specify which exceptions (and throwables) should cause automatic roll
    back. We specify this declaratively, in configuration, not in Java code.
    So, while we can still call <tt class="literal">setRollbackOnly() </tt>on the
    <tt class="literal">TransactionStatus</tt> object to roll the current
    transaction back programmatically, most often we can specify a rule that
    <tt class="literal">MyApplicationException</tt> should always result in roll
    back. This has the significant advantage that business objects don't need
    to depend on the transaction infrastructure. For example, they typically
    don't need to import any Spring APIs, transaction or other.</p><p>While the EJB default behavior is for the EJB container to
    automatically roll back the transaction on a <span class="emphasis"><em>system
    exception</em></span> (usually a runtime exception), EJB CMT does not roll
    back the transaction automatically on an <span class="emphasis"><em>application
    exception</em></span> (checked exception other than
    <tt class="literal">java.rmi.RemoteException</tt>). While the Spring default
    behavior for declarative transaction management follows EJB convention
    (roll back is automatic only on unchecked exceptions), it's often useful
    to customize this.</p><p>On our benchmarks, the performance of Spring declarative transaction
    management exceeds that of EJB CMT.</p><p>The usual way of setting up transactional proxying in Spring is via
    the TransactionProxyFactoryBean. We need a target object to wrap in a
    transactional proxy. The target object is normally a POJO bean definition.
    When we define the TransactionProxyFactoryBean, we must supply a reference
    to the relevant PlatformTransactionManager, and <span class="bold"><b>transaction attributes</b></span>. Transaction attributes
    contain the transaction definitions, discussed above. Consider the
    following sample:</p><pre class="programlisting">&lt;!-- this example is in verbose form, see note later about concise
     for multiple proxies! --&gt;
&lt;!-- the target bean to wrap transactionally --&gt;
&lt;bean id="petStoreTarget"&gt;
  ...
&lt;/bean&gt;
&lt;bean id="petStore"
    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
    &lt;property name="target"&gt;&lt;ref bean="petStoreTarget"/&gt;&lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
        &lt;props&gt;
            &lt;prop key="insert*"&gt;PROPAGATION_REQUIRED,-MyCheckedException&lt;/prop&gt;
            &lt;prop key="update*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;prop key="*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>The transactional proxy will implement the interfaces of the target:
    in this case, the bean with id petStoreTarget. (Using CGLIB it's possible
    to transactionally proxy a target class. Set the "proxyTargetClass" property
    to true for this. It will happen automatically if the target doesn't
    implement any interfaces. In general, of course, we want to program to
    interfaces rather than classes.) It's possible (and usually a good idea)
    to restrict the transactional proxy to proxying only specific target
    interfaces, using the proxyInterfaces property. It's also possible to
    customize the behavior of a TransactionProxyFactoryBean via several
    properties inherited from
    <tt class="literal">org.springframework.aop.framework.ProxyConfig</tt>, and
    shared with all AOP proxy factories.</p><p>The transactionAttributes here are set using a Properties format
    defined in the
    <tt class="literal">org.springframework.transaction.interceptor.NameMatchTransactionAttributeSource</tt>
    class. The mapping from method name, including wildcards, should be fairly
    intuitive. Note that the value for the insert* mapping contains a rollback
    rule. Adding <tt class="literal">-MyCheckedException</tt> here specifies that if
    the method throws <tt class="literal">MyCheckedException</tt> or any subclasses,
    the transaction will automatically be rolled back. Multiple rollback rules
    can be specified here, comma-separated. A - prefix forces rollback; a +
    prefix specifies commit. (This allows commit even on unchecked exceptions,
    if you really know what you're doing!)</p><p>The <tt class="literal">TransactionProxyFactoryBean</tt> allows you to set
    "pre" and "post" advice, for additional interception behavior, using the
    "preInterceptors" and "postInterceptors" properties. Any number of pre and
    post advices can be set, and their type may be <tt class="literal">Advisor</tt>
    (in which case they can contain a pointcut),
    <tt class="literal">MethodInterceptor</tt> or any advice type supported by the
    current Spring configuration (such as <tt class="literal">ThrowsAdvice</tt>,
    <tt class="literal">AfterReturningtAdvice</tt> or
    <tt class="literal">BeforeAdvice</tt>, which are supported by default.) These
    advices must support a shared-instance model. If you need transactional
    proxying with advanced AOP features such as stateful mixins, it's normally
    best to use the generic
    <tt class="literal">org.springframework.aop.framework.ProxyFactoryBean</tt>,
    rather than the <tt class="literal">TransactionProxyFactoryBean</tt> convenience
    proxy creator.</p><p>It's also possible to set up autoproxying: that is, to configure the
    AOP framework so that classes are automatically proxied without needing
    individual proxy definitions.</p><p>Please see the chapter on AOP for more information and
    examples.</p><p><span class="emphasis"><em>Note</em></span>: Using TransactionProxyFactoryBean
    definitions in the form above can seem overly verbose when many almost
    identical transaction proxies need to be created. You will almost always
    want to take advantage of parent and child bean definitions, along with
    inner bean definitions, to significantly reduce the verbosity of your
    transaction proxy definitions, as described in <a href="#aop-concise-proxy" title="5.7.&nbsp;Concise proxy definitions">Section&nbsp;5.7, &#8220;Concise proxy definitions&#8221;</a>.</p><i><span class="remark">You don't need to be an AOP expert--or indeed, to know much at all
    about AOP--to use Spring's declarative transaction management effectively.
    However, if you do want to become a "power user" of Spring AOP, you will
    find it easy to combine declarative transaction management with powerful
    AOP capabilities.</span></i><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4894"></a>7.4.1.&nbsp;BeanNameAutoProxyCreator,
      another declarative approach</h3></div></div><div></div></div><p><tt class="classname">TransactionProxyFactoryBean</tt> is very useful,
      and gives you full control when wrapping objects with a transactional
      proxy. Used with parent/child bean definitions and inner beans holding
      the target, it is generally the best choice for transactional wrapping.
      In the case that you need to wrap a number of beans in a completely
      identical fashion (for example, a boilerplate, 'make all methods
      transactional', using a <tt class="classname">BeanFactoryPostProcessor</tt>
      called <tt class="classname">BeanNameAutoProxyCreator</tt> can offer an
      alternative approach which can end up being even less verbose for this
      simplified use case.</p><p>To recap, once the ApplicationContext has read its initialization
      information, it instantiates any beans within it which implement the
      <tt class="classname">BeanPostProcessor</tt> interface, and gives them a
      chance to post-process all other beans in the ApplicationContext. So
      using this mechanism, a properly configured
      <tt class="classname">BeanNameAutoProxyCreator</tt> can be used to
      postprocess any other beans in the ApplicationContext (recognizing them
      by name), and wrap them with a transactional proxy. The actual
      transaction proxy produced is essentially identical to that produced by
      the use of <tt class="classname">TransactionProxyFactoryBean</tt>, so will
      not be discussed further.</p><p>Let us consider a sample configuration:</p><pre class="programlisting">  &lt;!-- Transaction Interceptor set up to do PROPAGATION_REQUIRED on all methods --&gt;
  &lt;bean id="matchAllWithPropReq" 
      class="org.springframework.transaction.interceptor.MatchAlwaysTransactionAttributeSource"&gt;
    &lt;property name="transactionAttribute"&gt;&lt;value&gt;PROPAGATION_REQUIRED&lt;/value&gt;&lt;/property&gt;
  &lt;/bean&gt;
  &lt;bean id="matchAllTxInterceptor" 
      class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
    &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
    &lt;property name="transactionAttributeSource"&gt;&lt;ref bean="matchAllWithPropReq"/&gt;&lt;/property&gt;
  &lt;/bean&gt;

  &lt;!-- One BeanNameAutoProxyCreator handles all beans where we want all methods to use 
       PROPAGATION_REQUIRED --&gt;
  &lt;bean id="autoProxyCreator" 
      class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
    &lt;property name="interceptorNames"&gt;
      &lt;list&gt;
        &lt;idref local="matchAllTxInterceptor"/&gt;
        &lt;idref bean="hibInterceptor"/&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="beanNames"&gt;
      &lt;list&gt;
        &lt;idref local="core-services-applicationControllerSevice"/&gt;
        &lt;idref local="core-services-deviceService"/&gt;
        &lt;idref local="core-services-authenticationService"/&gt;
        &lt;idref local="core-services-packagingMessageHandler"/&gt;
        &lt;idref local="core-services-sendEmail"/&gt;
        &lt;idref local="core-services-userService"/&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;</pre><p>Assuming that we already have a
      <tt class="classname">TransactionManager</tt> instance in our
      ApplicationContext, the first thing we need to do is create a
      <tt class="classname">TransactionInterceptor</tt> instance to use. The
      <tt class="classname">TransactionInterceptor</tt> decides which methods to
      intercept based on a <tt class="classname">TransactionAttributeSource</tt>
      implementing object passed to it as a property. In this case, we want to
      handle the very simple case of matching all methods. This is not
      necessarily the most efficient approach, but it's very quick to set up,
      because we can use the special pre-defined
      <tt class="classname">MatchAlwaysTransactionAttributeSource</tt>, which
      simply matches all methods. If we wanted to be more specific, we could
      use other variants such as
      <tt class="classname">MethodMapTransactionAttributeSource</tt>,
      <tt class="classname">NameMatchTransactionAttributeSource</tt>, or
      <tt class="classname">AttributesTransactionAttributeSource</tt>.</p><p>Now that we have the transaction interceptor, we simply feed it to
      a <tt class="classname">BeanNameAutoProxyCreator</tt> instance we define,
      along with the names of 6 beans in the ApplicationContext that we want
      to wrap in an identical fashion. As you can see, the net result is
      significantly less verbose than it would have been to wrap 6 beans
      identically with TransactionProxyFactoryBean. Wrapping a 7th bean would
      add only one more line of config.</p><p>You may notice that we are able to apply multiple interceptors. In
      this case, we are also applying a
      <tt class="classname">HibernateInterceptor</tt> we have previously defined
      (bean id=<span class="emphasis"><em>hibInterceptor</em></span>), which will manage
      Hibernate Sessions for us.</p><p>There is one thing to keep in mind, with regards to bean naming,
      when switching back and forth between the use of
      <tt class="classname">TransactionProxyFactoryBean</tt>, and
      <tt class="classname">BeanNameAutoProxyCreator</tt>. For the former, if the
      target bean is not defined as an inner bean, you normally give the
      target bean you want to wrap an id similar in form to
      <span class="emphasis"><em>myServiceTarget</em></span>, and then give the proxy object an
      id of <span class="emphasis"><em>myService</em></span>; then all users of the wrapped
      object simply refer to the proxy, i.e. <span class="emphasis"><em>myService</em></span>.
      (These are just sample naming conventions, the point is that the target
      object has a different name than the proxy, and both are available from
      the ApplicationContext). However, when using
      <tt class="classname">BeanNameAutoProxyCreator</tt>, you name the target
      object something like <span class="emphasis"><em>myService</em></span>. Then, when
      <tt class="classname">BeanNameAutoProxyCreator</tt> postprocesses the target
      object and create the proxy, it causes the proxy to be inserted into the
      Application context under the name of the original bean. From that point
      on, only the proxy (the wrapped object) is available from the
      ApplicationContext. When using TransactionProxyFactoryBean with the
      target specified as an inner bean, this naming issue is not a concern,
      since the inner bean is not normally given a name.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4988"></a>7.5.&nbsp;Choosing between programmatic and declarative transaction
    management</h2></div></div><div></div></div><p>Programmatic transaction management is usually a good idea only if
    you have a small number of transactional operations. For example, if you
    have a web application that require transactions only for certain update
    operations, you may not want to set up transactional proxies using Spring
    or any other technology. Using the TransactionTemplate may be a good
    approach.</p><p>On the other hand, if your applications has numerous transactional
    operations, declarative transaction management is usually worthwhile. It
    keeps transaction management out of business logic, and is not difficult
    to configure in Spring. Using Spring, rather than EJB CMT, the
    configuration cost of declarative transaction management is greatly
    reduced.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4995"></a>7.6.&nbsp;Do you need an application server for transaction
    management?</h2></div></div><div></div></div><p>Spring's transaction management capabilities--and especially its
    declarative transaction management--significantly changes traditional
    thinking as to when a J2EE application requires an application
    server.</p><p>In particular, you don't need an application server just to have
    declarative transactions via EJB. In fact, even if you have an application
    server with powerful JTA capabilities, you may well decide that Spring
    declarative transactions offer more power and a much more productive
    programming model than EJB CMT.</p><p>You need an application server's JTA capability only if you need to
    enlist multiple transactional resources. Many applications don't face this
    requirement. For example, many high-end applications use a single, highly
    scalable, database such as Oracle 9i RAC.</p><p>Of course you may need other application server capabilities such as
    JMS and JCA. However, if you need only JTA, you could also consider an
    open source JTA add-on such as JOTM. (Spring integrates with JOTM out of
    the box.) However, as of early 2004, high-end application servers provide
    more robust support for XA transactions.</p><p>The most important point is that with Spring <span class="emphasis"><em>you can
    choose when to scale your application up to a full-blown application
    server</em></span>. Gone are the days when the only alternative to using
    EJB CMT or JTA was to write coding using local transactions such as those
    on JDBC connections, and face a hefty rework if you ever needed that code
    to run within global, container-managed transactions. With Spring only
    configuration needs to change: your code doesn't.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5011"></a>7.7.&nbsp;Common problems</h2></div></div><div></div></div><p>Developers should take care to use the correct
    <span class="emphasis"><em><tt class="literal">PlatformTransactionManager</tt></em></span>
    implementation for their requirements.</p><p>It's important to understand how the Spring transaction abstraction
    works with JTA global transactions. Used properly, there is no conflict
    here: Spring merely provides a simplifying, portable abstraction.</p><p>If you are using global transactions, you <span class="emphasis"><em>must</em></span>
    use the Spring
    <tt class="literal">org.springframework.transaction.jta.JtaTransactionManager</tt>
    for all your for all your transactional operations. Otherwise Spring will
    attempt to perform local transactions on resources such as container
    DataSources. Such local transactions don't make sense, and a good
    application server will treat them as errors. <tt class="literal"></tt></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="metadata"></a>Chapter&nbsp;8.&nbsp;Source Level Metadata Support</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-concepts"></a>8.1.&nbsp;Source-level metadata</h2></div></div><div></div></div><p><span class="authorinitials">Source-level metadata</span> is the
    addition of <span class="emphasis"><em>attributes</em></span> or <span class="emphasis"><em>annotations</em></span>
    to program elements: usually, classes and/or methods.</p><p>For example, we might add metadata to a class as follows:</p><pre class="programlisting">/**
 * Normal comments
 * @@org.springframework.transaction.interceptor.DefaultTransactionAttribute()
 */
public class PetStoreImpl implements PetStoreFacade, OrderService {</pre><p>We could add metadata to a method as follows:</p><pre class="programlisting">/**
 * Normal comments
 * @@org.springframework.transaction.interceptor.RuleBasedTransactionAttribute()
 * @@org.springframework.transaction.interceptor.RollbackRuleAttribute(Exception.class)
 * @@org.springframework.transaction.interceptor.NoRollbackRuleAttribute("ServletException")
 */
public void echoException(Exception ex) throws Exception {
    ....
}</pre><p>Both of these examples use Jakarta Commons Attributes syntax.</p><p>Source-level metadata was introduced to the mainstream by XDoclet
    (in the Java world) and by the release of Microsoft's .NET platform,
    which uses source-level attributes to control transactions, pooling and
    other behavior.</p><p>The value in this approach has been recognized in the J2EE
    community. For example, it's much less verbose than the traditional
    XML deployment descriptors exclusively used by EJB. While it is desirable
    to externalize some things from program source code, some important
    enterprise settings--notably transaction characteristics--arguably belong
    in program source. Contrary to the assumptions of the EJB spec, it seldom
    makes sense to modify the transactional characteristics of a method
    (although parameters like transaction timeouts might change!).</p><p>Although metadata attributes are typically used mainly by framework
    infrastructure to describe the services application classes require, it
    should also be possible for metadata attributes to be queried at runtime.
    This is a key distinction from solutions such as XDoclet, which primarily
    view metadata as a way of generating code such as EJB artefacts.</p><p>There are a number of solutions in this space, including:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b>JSR-175</b></span>: the standard Java
        metadata implementation, available in Java 1.5. But we need a solution
        for Java 1.4 and even 1.3 too.</p></li><li><p><span class="bold"><b>XDoclet</b></span>: well-established
        solution, primarily intended for code generation</p></li><li><p>Various <span class="bold"><b>open source attribute
        implementations</b></span>, for Java 1.3 and 1.4, of which
        Commons Attributes appears to be the most promising. All these
        require a special pre- or post-compilation step.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-spring"></a>8.2.&nbsp;Spring's metadata support</h2></div></div><div></div></div><p>In keeping with its provision of abstractions over important
    concepts, Spring provides a facade to metadata implementations, in the
    form of the <tt class="literal">org.springframework.metadata.Attributes</tt>
    interface.</p><p>Such a facade adds value for several reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>There
    is currently no standard metadata solution. Java 1.5 will provide one, but
    it is still in beta as of Spring 1.0. Furthermore, there will be a need
    for metadata support in 1.3 and 1.4 applications for at least two years.
    Spring aims to provide working solutions <span class="emphasis"><em>now</em></span>; waiting
    for 1.5 is not an option in such an important area.</p></li><li><p>Current
    metadata APIs, such as Commons Attributes (used by Spring 1.0) are hard to
    test. Spring provides a simple metadata interface that is much easier to
    mock.</p></li><li><p>Even when Java 1.5 provides
    metadata support at language level, there will still be value in providing
    such an abstraction:</p><div class="itemizedlist"><ul type="circle"><li><p>JSR-175 metadata
    is static. It is associated with a class at compile time, and cannot be
    changed in a deployed environment. There is a need for hierarchical
    metadata, providing the ability to override certain attribute values in
    deployment--for example, in an XML file.</p></li><li><p>JSR-175
    metadata is returned through the Java reflection API. This makes it
    impossible to mock during test time. Spring provides a simple interface to
    allow this.</p></li></ul></div></li></ul></div><p>The Spring <tt class="literal">Attributes</tt> interface looks like this:</p><pre class="programlisting">public interface Attributes {

    Collection getAttributes(Class targetClass);

    Collection getAttributes(Class targetClass, Class filter);

    Collection getAttributes(Method targetMethod);

    Collection getAttributes(Method targetMethod, Class filter);

    Collection getAttributes(Field targetField);

    Collection getAttributes(Field targetField, Class filter);
}</pre><p>This is a lowest common denominator interface. JSR-175 offers more
    capabilities than this, such as attributes on method arguments. As of
    Spring 1.0, Spring aims to provide the subset of metadata required to
    provide effective declarative enterprise services a la EJB or .NET,
    on Java 1.3+. As of Spring 1.2, analogous JSR-175 annotations are
    supported on JDK 1.5, as direct alternative to Commons Attributes.</p><p>Note that this interface offers <tt class="literal">Object</tt>
    attributes, like .NET. This distinguishes it from attribute systems such
    as that of Nanning Aspects and JBoss 4 (as of DR2), which offer only
    <tt class="literal">String</tt> attributes. There is a significant advantage in
    supporting <tt class="literal">Object</tt> attributes. It enables attributes to
    participate in class hierarchies and enables attributes to react
    intelligently to their configuration parameters.</p><p>In most attribute providers, attribute classes will be configured
    via constructor arguments or JavaBean properties. Commons Attributes
    supports both.</p><p>As with all Spring abstraction APIs, <tt class="literal">Attributes</tt>
    is an interface. This makes it easy to mock attribute implementations for
    unit tests.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-commons"></a>8.3.&nbsp;Integration with Jakarta Commons Attributes</h2></div></div><div></div></div><p>Presently Spring supports only Jakarta Commons Attributes out of the
    box, although it is easy to provide implementations of the
    <tt class="literal">org.springframework.metadata.Attributes</tt> interface for
    other metadata providers.</p><p><span class="bold"><b>Commons Attributes 2.1</b></span> (<a href="http://jakarta.apache.org/commons/attributes/" target="_top">http://jakarta.apache.org/commons/attributes/</a>)
    is a capable attributes solution. It supports attribute configuration via
    constructor arguments and JavaBean properties, which offers better
    self-documentation in attribute definitions. (Support for JavaBean
    properties was added at the request of the Spring team.)</p><p>We've already seen two examples of Commons Attributes attributes
    definitions. In general, we will need to express:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>The name of the attribute class</em></span>. This can
        be an FQN, as shown above. If the relevant attribute class has already
        been imported, the FQN isn't required. It's also possible to
        specify "attribute packages" in attribute compiler
        configuration.</p></li><li><p><span class="emphasis"><em>Any necessary parameterization,</em></span> via
        constructor arguments or JavaBean properties</p></li></ul></div><p>Bean properties look as follows:</p><pre class="programlisting">/**
 * @@MyAttribute(myBooleanJavaBeanProperty=true)
 */</pre><p>It's possible to combine constructor arguments and JavaBean
    properties (as in Spring IoC).</p><p>Because, unlike Java 1.5 attributes, Commons Attributes is not
    integrated with the Java language, it is necessary to run a special
    <span class="emphasis"><em>attribute compilation</em></span> step as part of the build
    process.</p><p>To run Commons Attributes as part of the build process, you will
    need to do the following.</p><p>1. Copy the necessary library Jars to <tt class="literal">$ANT_HOME/lib</tt>.
    Four Jars are required, and all are distributed with Spring:</p><div class="itemizedlist"><ul type="disc"><li><p>The Commons Attributes compiler Jar and API Jar</p></li><li><p>xjavadoc.jar, from XDoclet</p></li><li><p>commons-collections.jar, from Jakarta Commons</p></li></ul></div><p>2. Import the Commons Attributes ant tasks into your project build
    script, as follows:</p><pre class="programlisting">&lt;taskdef resource="org/apache/commons/attributes/anttasks.properties"/&gt;</pre><p>3. Next, define an attribute compilation task, which will use the
    Commons Attributes attribute-compiler task to "compile" the
    attributes in the source. This process results in the generation of
    additional sources, to a location specified by the destdir attribute. Here
    we show the use of a temporary directory:</p><pre class="programlisting">&lt;target name="compileAttributes" &gt;

    &lt;attribute-compiler 
        destdir="${commons.attributes.tempdir}" 
    &gt;
        &lt;fileset dir="${src.dir}" includes="**/*.java"/&gt;
    &lt;/attribute-compiler&gt;

&lt;/target&gt;</pre><p>The compile target that runs Javac over the sources should depend on
    this attribute compilation task, and must also compile the generated
    sources, which we output to our destination temporary directory. If there
    are syntax errors in your attribute definitions, they will normally be
    caught by the attribute compiler. However, if the attribute definitions
    are syntactically plausible, but specify invalid types or class names, the
    compilation of the generated attribute classes may fail. In this case, you
    can look at the generated classes to establish the cause of the problem.</p><i><span class="remark">Commons Attributes also provides Maven support. Please refer to
    Commons Attributes documentation for further information.</span></i><p>While this attribute compilation process may look complex, in fact
    it's a one-off cost. Once set up, attribute compilation is
    incremental, so it doesn't usually noticeably slow the build process.
    And once the compilation process is set up, you may find that use of
    attributes as described in this chapter can save you a lot of time in
    other areas. </p><p>If you require attribute indexing support (only currently required
    by Spring for attribute-targeted web controllers, discussed below), you
    will need an additional step, which must be performed on a Jar file of
    your compiled classes. In this, optional, step, Commons Attributes will
    create an index of all the attributes defined on your sources, for
    efficient lookup at runtime. This step looks as follows:</p><pre class="programlisting">&lt;attribute-indexer jarFile="myCompiledSources.jar"&gt;
    
    &lt;classpath refid="master-classpath"/&gt;

&lt;/attribute-indexer&gt;</pre><i><span class="remark">See the /attributes directory of the Spring jPetStore sample
    application for an example of this build process. You can take the build
    script it contains and modify it for your own projects.</span></i><p>If your unit tests depend on attributes, try to express the
    dependency on the Spring Attributes abstraction, rather than Commons
    Attributes. Not only is this more portable--for example, your tests will
    still work if you switch to Java 1.5 attributes in future--it simplifies
    testing. Commons Attributes is a static API, while Spring provides a
    metadata interface that you can easily mock.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-uses"></a>8.4.&nbsp;Metadata and Spring AOP autoproxying</h2></div></div><div></div></div><p>The most important uses of metadata attributes are in conjunction
    with Spring AOP. This provides a .NET-like programming model, where
    declarative services are automatically provided to application objects
    that declare metadata attributes. Such metadata attributes can be
    supported out of the box by the framework, as in the case of declarative
    transaction management, or can be custom.</p><p>There is widely held to be a synergy between AOP and metadata
    attributes.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5230"></a>8.4.1.&nbsp;Fundamentals</h3></div></div><div></div></div><p>This builds on the Spring AOP autoproxy functionality.
      Configuration might look like this:</p><pre class="programlisting">&lt;bean id="autoproxy" 
    class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt;
&lt;/bean&gt;

&lt;bean id="transactionAttributeSource"
    class="org.springframework.transaction.interceptor.AttributesTransactionAttributeSource"
    autowire="constructor"&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"
    autowire="byType"&gt;
&lt;/bean&gt;

&lt;bean id="transactionAdvisor"
    class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"
    autowire="constructor" &gt;
&lt;/bean&gt;

&lt;bean id="attributes"
    class="org.springframework.metadata.commons.CommonsAttributes"
/&gt;</pre><p>The basic concepts here should be familiar from the discussion of
      autoproxying in the AOP chapter. </p><p>The most important bean definitions are those named <span class="bold"><b>autoproxy</b></span> and <span class="bold"><b>transactionAdvisor</b></span>.
      Note that the actual bean names are not important; what matters is their
      class.</p><p>The autoproxy bean definition of class <tt class="literal">org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</tt>
      will automatically advise ("autoproxy") all bean instances in
      the current factory based on matching Advisor implementations. This
      class knows nothing about attributes, but relies on Advisors'
      pointcuts matching. The pointcuts do know about attributes.</p><p>Thus we simply need an AOP advisor that will provide declarative
      transaction management based on attributes.</p><p>It's possible to add arbitrary custom Advisor implementations
      as well, and they will also be evaluated and applied automatically. (You
      can use Advisors whose pointcuts match on criteria besides attributes in
      the same autoproxy configuration, if necessary.)</p><p>Finally, the <tt class="literal">attributes</tt> bean is the Commons
      Attributes Attributes implementation. Replace with another
      implementation of <tt class="literal">org.springframework.metadata.Attributes
      </tt>to source attributes from a different source.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-tx"></a>8.4.2.&nbsp;Declarative transaction management</h3></div></div><div></div></div><p>The commonest use of source-level attributes it to provide
      declarative transaction management a la .NET. Once the bean definitions
      shown above are in place, you can define any number of application
      objects requiring declarative transactions. Only those classes or
      methods with transaction attributes will be given transaction advice.
      You need to do nothing except define the required transaction
      attributes.</p><p><span class="emphasis"><em>Unlike</em></span> in .NET, you can specify transaction
      attributes at either class or method level. Class-level attributes, if
      specified, will be "inherited" by all methods. Method attributes
      will wholly override any class-level attributes.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-pool"></a>8.4.3.&nbsp;Pooling</h3></div></div><div></div></div><p>Again, as with .NET, you can enable pooling behavior via
      class-level attributes. Spring can apply this behavior to any POJO. You
      simply need to specify a pooling attribute, as follows, in the business
      object to be pooled:</p><pre class="programlisting"> /** 
 * @@org.springframework.aop.framework.autoproxy.target.PoolingAttribute (10)
 * 
 * @author Rod Johnson
 */
public class MyClass {</pre><p>You'll need the usual autoproxy
      infrastructure configuration. You then need to specify a pooling
      <tt class="literal">TargetSourceCreator</tt>, as follows. Because pooling
      affects the creation of the target, we can't use a regular advice.
      Note that pooling will apply even if there are no advisors applicable to
      the class, if that class has a pooling attribute.</p><pre class="programlisting">&lt;bean id="poolingTargetSourceCreator"
    class="org.springframework.aop.framework.autoproxy.metadata.AttributesPoolingTargetSourceCreator"
    autowire="constructor" &gt;
&lt;/bean&gt;</pre><p>The relevant autoproxy bean definition needs to specify a list of
      "custom target source creators", including the Pooling target
      source creator. We could modify the example shown above to include this
      property as follows:</p><pre class="programlisting">&lt;bean id="autoproxy" 
    class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt;
&gt;
    &lt;property name="customTargetSourceCreators"&gt;
        &lt;list&gt;
            &lt;ref local="poolingTargetSourceCreator" /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>As with the use of metadata in Spring in general, this is a
      one-off cost: once setup is out of the way, it's very easy to use
      pooling for additional business objects. </p><i><span class="remark">It's arguable that the need for pooling is rare, so
      there's seldom a need to apply pooling to a large number of business
      objects. Hence this feature does not appear to be used often.</span></i><p>Please see the Javadoc for the <tt class="literal">org.springframework.aop.framework.autoproxy</tt>
      package for more details. It's possible to use a different pooling
      implementation than Commons Pool with minimal custom coding.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-arbitrary"></a>8.4.4.&nbsp;Custom metadata</h3></div></div><div></div></div><p>We can even go beyond the capabilities of .NET metadata
      attributes, because of the flexibility of the underlying autoproxying
      infrastructure.</p><p>We can define custom attributes, to provide any kind of
      declarative behavior. To do this, you need to:</p><div class="itemizedlist"><ul type="disc"><li><p>Define your custom attribute class</p></li><li><p>Define a Spring AOP Advisor with a pointcut that fires on the
          presence of this custom attribute.</p></li><li><p>Add that Advisor as a bean definition to an application
          context with the generic autoproxy infrastructure in place.</p></li><li><p>Add attributes to your POJOs.</p></li></ul></div><p>There are several potential areas you might want to do this, such
      as custom declarative security, or possibly caching.</p><i><span class="remark">This is a powerful mechanism which can significantly reduce
      configuration effort in some projects. However, remember that it does
      rely on AOP under the covers. The more Advisors you have in play, the
      more complex your runtime configuration will be.</span></i><i><span class="remark">(If you want to see what advice applies to any object, try
      casting a reference to org.springframework.aop.framework.Advised. This
      will enable you to examine the Advisors.)</span></i></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5329"></a>8.5.&nbsp;Using attributes to minimize MVC web tier configuration</h2></div></div><div></div></div><p>The other main use of Spring metadata as of 1.0 is to provide an
    option to simplify Spring MVC web configuration.</p><p>Spring MVC offers flexible <span class="emphasis"><em>handler mappings</em></span>:
    mappings from incoming request to controller (or other handler) instance.
    Normally handler mappings are configured in the <tt class="literal">xxxx-servlet.xml</tt>
    file for the relevant Spring DispatcherServlet.</p><p>Holding these mappings in the DispatcherServlet configuration file
    is normally A Good Thing. It provides maximum flexibility. In particular:</p><div class="itemizedlist"><ul type="disc"><li><p>The
    controller instance is explicitly managed by Spring IoC, through an XML
    bean definition</p></li><li><p>The mapping is external
    to the controller, so the same controller instance could be given multiple
    mappings in the same DispatcherServlet context or reused in a different
    configuration.</p></li><li><p>Spring MVC is able to
    support mappings based on any criteria, rather than merely the request
    URL-to-controller mappings available in most other frameworks.</p></li></ul></div><p>However, this does mean that for each controller we typically need
    both a handler mapping (normally in a handler mapping XML bean definition)
    and an XML mapping for the controller itself.</p><p>Spring offers a simpler approach based on source-level attributes,
    which is an attractive option in simpler scenarios.</p><i><span class="remark">The approach described in this section is best suited to
    relatively simple MVC scenarios. It sacrifices some of the power of Spring
    MVC, such as the ability to use the same controller with different
    mappings, and the ability to base mappings on something other than request
    URL.</span></i><p>In this approach, controllers are marked with one or more
    class-level metadata attributes, each specifying one URL they should be
    mapped to.</p><p>The following examples show the approach. In each case, we have a
    controller that depends on a business object of type Cruncher. As usual,
    this dependency will be resolved by Dependency Injection. The Cruncher
    must be available through a bean definition in the relevant
    DispatcherServlet XML file, or a parent context.</p><p>We attach an attribute to the controller class specifying the URL
    that should map to it. We can express the dependency through a JavaBean
    property or a constructor argument. This dependency must be resolvable by
    autowiring: that is, there must be exactly one business object of type
    Cruncher available in the context.</p><pre class="programlisting">/**
 * Normal comments here
 * @author Rod Johnson
 * @@org.springframework.web.servlet.handler.metadata.PathMap("/bar.cgi")
 */
public class BarController extends AbstractController {

    private Cruncher cruncher;

    public void setCruncher(Cruncher cruncher) {
        this.cruncher = cruncher;
    }

    protected ModelAndView handleRequestInternal(
            HttpServletRequest arg0, HttpServletResponse arg1) 
            throws Exception {
        System.out.println("Bar Crunching c and d =" + 
            cruncher.concatenate("c", "d"));
        return new ModelAndView("test");
    }

}</pre><p>For this auto-mapping to work, we need to add the following to the
    relevant <tt class="literal">xxxx-servlet.xml</tt> file, specifying the
    attributes handler mapping. This special handler mapping can handle any
    number of controllers with attributes as shown above. The bean id
    ("commonsAttributesHandlerMapping") is not important. The type is
    what matters:</p><pre class="programlisting">&lt;bean id="commonsAttributesHandlerMapping"      
    class="org.springframework.web.servlet.handler.metadata.CommonsPathMapHandlerMapping"
/&gt;</pre><p>We <span class="emphasis"><em>do not </em></span>currently need an Attributes bean
    definition, as in the above example, because this class works directly
    with the Commons Attributes API, not via the Spring metadata abstraction.</p><p>We now need no XML configuration for each controller. Controllers
    are automatically mapped to the specified URL(s). Controllers benefit from
    IoC, using Spring's autowiring capability. For example, the dependency
    expressed in the "cruncher" bean property of the simple controller
    shown above is automatically resolved in the current web application
    context. Both Setter and Constructor Dependency Injection are available,
    each with zero configuration.</p><p>An example of Constructor Injection, also showing multiple URL
    paths:</p><pre class="programlisting">/**
* Normal comments here
* @author Rod Johnson
* 
* @@org.springframework.web.servlet.handler.metadata.PathMap("/foo.cgi")
* @@org.springframework.web.servlet.handler.metadata.PathMap("/baz.cgi")
*/
public class FooController extends AbstractController {

    private Cruncher cruncher;

    public FooController(Cruncher cruncher) {
        this.cruncher = cruncher;
    }

    protected ModelAndView handleRequestInternal(
            HttpServletRequest arg0, HttpServletResponse arg1) 
            throws Exception {
        return new ModelAndView("test");
    }

}</pre><p>This approach has the following benefits:</p><div class="itemizedlist"><ul type="disc"><li><p>Significantly reduced volume of configuration. Each time we add
        a controller we need add <span class="emphasis"><em>no</em></span> XML configuration. As
        with attribute-driven transaction management, once the basic
        infrastructure is in place, it is very easy to add more application
        classes.</p></li><li><p>We retain much of the power of Spring IoC to configure
        controllers.</p></li></ul></div><p>This approach has the following limitations:</p><div class="itemizedlist"><ul type="disc"><li><p>One-off cost in more complex build process. We need an attribute
        compilation step and an attribute indexing step. However, once in
        place, this should not be an issue.</p></li><li><p>Currently Commons Attributes only, although support for other
        attribute providers may be added in future.</p></li><li><p>Only "autowiring by type" dependency injection is
        supported for such controllers. However, this still leaves them far in
        advance of Struts Actions (with no IoC support from the framework)
        and, arguably, WebWork Actions (with only rudimentary IoC support)
        where IoC is concerned.</p></li><li><p>Reliance on automagical IoC resolution may be confusing.</p></li></ul></div><p>Because autowiring by type means there must be exactly one
    dependency of the specified type, we need to be careful if we use AOP. In
    the common case using TransactionProxyFactoryBean, for example, we end up
    with <span class="emphasis"><em>two</em></span> implementations of a business interface such
    as Cruncher: the original POJO definition, and the transactional AOP
    proxy. This won't work, as the owning application context can't
    resolve the type dependency unambiguously. The solution is to use AOP
    autoproxying, setting up the autoproxy infrastructure so that there is
    only one implementation of Cruncher defined, and that implementation is
    automatically advised. Thus this approach works well with
    attribute-targeted declarative services as described above. As the
    attributes compilation process must be in place to handle the web
    controller targeting, this is easy to set up.</p><p>Unlike other metadata functionality, there is currently only a
    Commons Attributes implementation available:
    org.springframework.web.servlet.handler.metadata.CommonsPathMapHandlerMapping.
    This limitation is due to the fact that not only do we need attribute
    compilation, we need attribute <span class="emphasis"><em>indexing</em></span>: the ability
    to ask the attributes API for all classes with the PathMap attribute.
    Indexing is not currently offered on the <tt class="literal">org.springframework.metadata.Attributes</tt>
    abstraction interface, although it may be in future. (If you want to add
    support for another attributes implementation--which must support
    indexing--you can easily extend the <tt class="literal">AbstractPathMapHandlerMapping</tt>
    superclass of <tt class="literal">CommonsPathMapHandlerMapping</tt>,
    implementing the two protected abstract methods to use your preferred
    attributes API.)</p><p>Thus we need two additional steps in the build process: attribute
    compilation and attribute indexing. Use of the attribute indexer task was
    shown above. Note that Commons Attributes presently requires a Jar file as
    input to indexing.</p><i><span class="remark">If you begin with a handler metadata mapping approach, it is
    possible to switch at any point to a classic Spring XML mapping approach.
    So you don't close off this option. For this reason, I find that I
    often start a web application using metadata mapping.</span></i></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5439"></a>8.6.&nbsp;Other uses of metadata attributes</h2></div></div><div></div></div><p>Other uses of metadata attributes appear to be growing in
    popularity. As of Spring 1.2, metadata attributes for JMX exposure
    are supported, through both Commons Attributes (on JDK 1.3+) and
    JSR-175 annotations (on JDK 1.5).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5444"></a>8.7.&nbsp;Adding support for additional metadata APIs</h2></div></div><div></div></div><p>Should you wish to provide support for another metadata API it is
    easy to do so.</p><p>Simply implement the <tt class="literal">org.springframework.metadata.Attributes</tt>
    interface as a facade for your metadata API. You can then include this
    object in your bean definitions as shown above.</p><p>All framework services that use metadata, such as AOP
    metadata-driven autoproxying, will then automatically be able to use your
    new metadata provider.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="dao"></a>Chapter&nbsp;9.&nbsp;DAO support</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dao-introduction"></a>9.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The DAO (Data Access Object) support in Spring is primarily aimed at
    making it easy to work with data access technologies like JDBC, Hibernate
    or JDO in a standardized way. This allows you to switch between them
    fairly easily and it also allows you to code without worrying about
    catching exceptions that are specific to each technology.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dao-exceptions"></a>9.2.&nbsp;Consistent Exception Hierarchy</h2></div></div><div></div></div><p>Spring provides a convenient translation from technology specific
    exceptions like <tt class="literal">SQLException</tt> to its own exception
    hierarchy with the <tt class="literal">DataAccessException</tt> as the root
    exception. These exceptions wrap the original exception so there is never
    any risk that you would lose any information as to what might have gone
    wrong.</p><p>In addition to JDBC exceptions, Spring can also wrap Hibernate
    exceptions, converting them from proprietary, checked exceptions, to a set
    of abstracted runtime exceptions. The same is true for JDO exceptions.
    This allows you to handle most persistence exceptions, which are
    non-recoverable, only in the appropriate layers, without annoying
    boilerplate catches/throws, and exception declarations. You can still trap
    and handle exceptions anywhere you need to. As we mentioned above, JDBC
    exceptions (including DB specific dialects) are also converted to the same
    hierarchy, meaning that you can perform some operations with JDBC within a
    consistent programming model.</p><p>The above is true for the Template versions of the ORM access
    framework. If you use the Interceptor based classes then the application
    must care about handling HibernateExceptions and JDOExceptions itself,
    preferably via delegating to <tt class="literal">SessionFactoryUtils</tt>'
    <tt class="literal">convertHibernateAccessException</tt> or
    <tt class="literal">convertJdoAccessException</tt> methods respectively. These
    methods converts the exceptions to ones that are compatible with the
    org.springframework.dao exception hierarchy. As JDOExceptions are
    unchecked, they can simply get thrown too, sacrificing generic DAO
    abstraction in terms of exceptions though.</p><p>The exception hierarchy that Spring uses is outlined in the
    following graph:</p><div class="mediaobject"><img src="images/DataAccessException.gif"></div><p></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5494"></a>9.3.&nbsp;Consistent Abstract Classes for DAO Support</h2></div></div><div></div></div><p>To make it easier to work with a variety of data access technologies
    like JDBC, JDO and Hibernate in a consistent way, Spring provides a set of
    abstract DAO classes that you can extend. These abstract classes has
    methods for setting the data source and any other configuration settings
    that are specific to the technology you currently are using.</p><p>Dao Support classes:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">JdbcDaoSupport</tt> - super class for JDBC data
        access objects. Requires a DataSource to be set, providing a
        JdbcTemplate based on it to subclasses.</p></li><li><p><tt class="literal">HibernateDaoSupport</tt> - super class for
        Hibernate data access objects. Requires a SessionFactory to be set,
        providing a HibernateTemplate based on it to subclasses. Can
        alternatively be initialized directly via a HibernateTemplate, to
        reuse the latter's settings like SessionFactory, flush mode, exception
        translator, etc.</p></li><li><p><tt class="literal">JdoDaoSupport</tt> - super class for JDO data
        access objects. Requires a PersistenceManagerFactory to be set,
        providing a JdoTemplate based on it to subclasses.</p></li></ul></div><p></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jdbc"></a>Chapter&nbsp;10.&nbsp;Data Access using JDBC</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-introduction"></a>10.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The JDBC abstraction framework provided by Spring consists of four
    different packages <tt class="literal">core</tt>, <tt class="literal">datasource</tt>,
		<tt class="literal">object</tt>, and <tt class="literal">support</tt>.</p><p>The <tt class="literal">org.springframework.jdbc.core</tt> package contains
		the JdbcTemplate class and its various callback interfaces, plus a variety
		of related classes.</p><p>The <tt class="literal">org.springframework.jdbc.datasource</tt> package
    contains a utility class for easy DataSource access, and various simple
    DataSource implementations that can be used for testing and running
    unmodified JDBC code outside of a J2EE container. The utility class
    provides static methods to obtain connections from JNDI and to close
    connections if necessary. It has support for thread-bound connections,
    e.g. for use with DataSourceTransactionManager.</p><p>Next, the <tt class="literal">org.springframework.jdbc.object</tt> package
    contains classes that represent RDBMS queries, updates, and stored
    procedures as thread safe, reusable objects. This approach is modeled by
    JDO, although of course objects returned by queries are
    &#8220;<span class="quote">disconnected</span>&#8221; from the database. This higher level of JDBC
    abstraction depends on the lower-level abstraction in the
    <tt class="literal">org.springframework.jdbc.core</tt> package.</p><p>Finally the <tt class="literal">org.springframework.jdbc.support</tt>
    package is where you find the <tt class="literal">SQLException</tt> translation
    functionality and some utility classes.</p><p>Exceptions thrown during JDBC processing are translated to
    exceptions defined in the <tt class="literal">org.springframework.dao</tt>
    package. This means that code using the Spring JDBC abstraction layer does
    not need to implement JDBC or RDBMS-specific error handling. All
    translated exceptions are unchecked giving you the option of catching the
    exceptions that you can recover from while allowing other exceptions to be
    propagated to the caller.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-core"></a>10.2.&nbsp;Using the JDBC Core classes to control basic JDBC processing and
    error handling</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-JdbcTemplate"></a>10.2.1.&nbsp;JdbcTemplate</h3></div></div><div></div></div><p>This is the central class in the JDBC core package. It simplifies
      the use of JDBC since it handles the creation and release of resources.
      This helps to avoid common errors like forgetting to always close the
      connection. It executes the core JDBC workflow like statement creation
      and execution, leaving application code to provide SQL and extract
      results. This class executes SQL queries, update statements or stored
      procedure calls, imitating iteration over ResultSets and extraction of
      returned parameter values. It also catches JDBC exceptions and
      translates them to the generic, more informative, exception hierarchy
      defined in the <tt class="literal">org.springframework.dao</tt>
      package.</p><p>Code using this class only need to implement callback interfaces,
      giving them a clearly defined contract. The
      <tt class="literal">PreparedStatementCreator</tt> callback interface creates a
      prepared statement given a Connection provided by this class, providing
      SQL and any necessary parameters. The same is true for the
      <tt class="literal">CallableStatementCreateor</tt> interface which creates
      callable statement. The <tt class="literal">RowCallbackHandler</tt> interface
      extracts values from each row of a ResultSet.</p><p>This class can be used within a service implementation via direct
      instantiation with a DataSource reference, or get prepared in an
      application context and given to services as bean reference. Note: The
      DataSource should always be configured as a bean in the application
      context, in the first case given to the service directly, in the second
      case to the prepared template. Because this class is parameterizable by
      the callback interfaces and the SQLExceptionTranslator interface, it
      isn't necessary to subclass it. All SQL issued by this class is
      logged.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5596"></a>10.2.2.&nbsp;DataSource</h3></div></div><div></div></div><p>In order to work with data from a database, we need to obtain a
      connection to the database. The way Spring does this is through a
      <tt class="literal">DataSource</tt>. A <tt class="literal">DataSource</tt> is part
      of the JDBC specification and can be seen as a generalized connection
      factory. It allows a container or a framework to hide connection pooling
      and transaction management issues from the application code. As a
      developer, you don't need to know any details about how to connect to
      the database, that is the responsibility for the administrator that sets
      up the datasource. You will most likely have to fulfill both roles while
      you are developing and testing you code though, but you will not
      necessarily have to know how the production data source is
      configured.</p><p>When using Spring's JDBC layer, you can either obtain a data
      source from JNDI or you can configure your own, using an implementation
      that is provided in the Spring distribution. The latter comes in handy
      for unit testing outside of a web container. We will use the
      <tt class="literal">DriverManagerDataSource</tt> implementation for this
      section but there are several additional implementations that will be
      covered later on. The <tt class="literal">DriverManagerDataSource</tt> works
      the same way that you probably are used to work when you obtain a JDBC
      connection. You have to specify the fully qualified class name of the
      JDBC driver that you are using so that the
      <tt class="literal">DriverManager</tt> can load the driver class. Then you
      have to provide a url that varies between JDBC drivers. You have to
      consult the documentation for your driver for the correct value to use
      here. Finally you must provide a username and a password that will be
      used to connect to the database. Here is an example of how to configure
      a <tt class="literal">DriverManagerDataSource:</tt></p><pre class="programlisting">DriverManagerDataSource dataSource = new DriverManagerDataSource();
dataSource.setDriverClassName( "org.hsqldb.jdbcDriver");
dataSource.setUrl( "jdbc:hsqldb:hsql://localhost:");
dataSource.setUsername( "sa");
dataSource.setPassword( ""); </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SQLExceptionTranslator"></a>10.2.3.&nbsp;SQLExceptionTranslator</h3></div></div><div></div></div><p><tt class="literal">SQLExceptionTranslator</tt> is an interface to be
      implemented by classes that can translate between SQLExceptions and our
      data access strategy-agnostic
      <tt class="literal">org.springframework.dao.DataAccessException</tt>.</p><p>Implementations can be generic (for example, using SQLState codes
      for JDBC) or proprietary (for example, using Oracle error codes) for
      greater precision.</p><p><tt class="literal">SQLErrorCodeSQLExceptionTranslator</tt> is the
      implementation of SQLExceptionTranslator that is used by default. This
      implementation uses specific vendor codes. More precise than
      <tt class="literal">SQLState</tt> implementation, but vendor specific. The
      error code translations are based on codes held in a JavaBean type class
      named <tt class="literal">SQLErrorCodes</tt>. This class is created and
      populated by an <tt class="literal">SQLErrorCodesFactory</tt> which as the
      name suggests is a factory for creating <tt class="literal">SQLErrorCodes</tt>
      based on the contents of a configuration file named
      "sql-error-codes.xml". This file is populated with vendor codes and
      based on the DatabaseProductName taken from the DatabaseMetaData, the
      codes for the current database are used.</p><p>The <tt class="literal">SQLErrorCodeSQLExceptionTranslator</tt> applies
      the following matching rules:</p><div class="itemizedlist"><ul type="disc" compact><li><p>Try custom translation implemented by any subclass. Note
            that this class is concrete and is typically used itself, in which
            case this rule doesn't apply.</p></li><li><p>Apply error code matching. Error codes are obtained from the
            SQLErrorCodesFactory by default. This looks up error codes from
            the classpath and keys into them from the database name from the
            database metadata.</p></li><li><p>Use the fallback translator. SQLStateSQLExceptionTranslator
            is the default fallback translator.</p></li></ul></div><p><tt class="literal">SQLErrorCodeSQLExceptionTranslator</tt> can be
      extended the following way: </p><pre class="programlisting">public class MySQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {
    protected DataAccessException customTranslate(String task, String sql, SQLException sqlex) {
        if (sqlex.getErrorCode() == -12345)
            return new DeadlockLoserDataAccessException(task, sqlex);
        return null;
    }
}</pre><p>In this example the specific error code '-12345' is
      translated and any other errors are simply left to be translated by the
      default translator implementation. To use this custom translator, it is
      necessary to pass it to the <tt class="literal">JdbcTemplate</tt> using the
      method <tt class="literal">setExceptionTranslator</tt> and to use this
      <tt class="literal">JdbcTemplate</tt> for all of the data access processing
      where this translator is needed. Here is an example of how this custom
      translator can be used: </p><pre class="programlisting">// create a JdbcTemplate and set data source 
JdbcTemplate jt = new JdbcTemplate(); 
jt.setDataSource(dataSource); 
// create a custom translator and set the datasource for the default translation lookup 
MySQLErrorCodesTransalator tr = new MySQLErrorCodesTransalator(); 
tr.setDataSource(dataSource); 
jt.setExceptionTranslator(tr); 
// use the JdbcTemplate for this SqlUpdate 
SqlUpdate su = new SqlUpdate(); 
su.setJdbcTemplate(jt); 
su.setSql("update orders set shipping_charge = shipping_charge * 1.05"); 
su.compile(); 
su.update();</pre><p>The custom translator is passed a data source
      because we still want the default translation to look up the error codes
      in <tt class="literal">sql-error-codes.xml</tt>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5687"></a>10.2.4.&nbsp;Executing Statements</h3></div></div><div></div></div><p>To execute an SQL statement, there is very little code needed. All
      you need is a <tt class="literal">DataSource</tt> and a
      <tt class="literal">JdbcTemplate</tt>. Once you have that, you can use a
      number of convenience methods that are provided with the
      <tt class="literal">JdbcTemplate</tt>. Here is a short example showing what
      you need to include for a minimal but fully functional class that
      creates a new table.</p><pre class="programlisting">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAStatement {
    private JdbcTemplate jt;
    private DataSource dataSource;

    public void doExecute() {
        jt = new JdbcTemplate(dataSource);
        jt.execute("create table mytable (id integer, name varchar(100))"); 
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5703"></a>10.2.5.&nbsp;Running Queries</h3></div></div><div></div></div><p>In addition to the execute methods, there is a large number of
      query methods. Some of these methods are intended to be used for queries
      that return a single value. Maybe you want to retrieve a count or a
      specific value from one row. If that is the case then you can use
      <tt class="literal">queryForInt</tt>,<tt class="literal">queryForLong</tt> or
      <tt class="literal">queryForObject</tt>. The latter will convert the returned
      JDBC Type to the Java class that is passed in as an argument. If the
      type conversion is invalid, then an
      <tt class="literal">InvalidDataAccessApiUsageException</tt> will be thrown.
      Here is an example that contains two query methods, one for an
      <tt class="literal">int</tt> and one that queries for a
      <tt class="literal">String</tt>.</p><pre class="programlisting">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class RunAQuery {
    private JdbcTemplate jt;
    private DataSource dataSource;
  
    public int getCount() {
        jt = new JdbcTemplate(dataSource);
        int count = jt.queryForInt("select count(*) from mytable");
        return count;
    }

    public String getName() {
        jt = new JdbcTemplate(dataSource);
        String name = (String) jt.queryForObject("select name from mytable", java.lang.String.class);
        return name;
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}</pre><p>In addition to the singe results query methods there are several
      methods that return a List with an entry for each row that the query
      returned. The most generic one is <tt class="literal">queryForList</tt> which
      returns a <tt class="literal">List</tt> where each entry is a
      <tt class="literal">Map</tt> with each entry in the map representing the
      column value for that row. If we add a method to the above example to
      retrieve a list of all the rows, it would look like this:</p><pre class="programlisting">    public List getList() {
        jt = new JdbcTemplate(dataSource);
        List rows = jt.queryForList("select * from mytable");
        return rows;
    }</pre><p>The list returned would look something like this:
      <tt class="literal">[{name=Bob, id=1}, {name=Mary, id=2}].</tt></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5745"></a>10.2.6.&nbsp;Updating the database</h3></div></div><div></div></div><p>There are also a number of update methods that you can use. I will
      show an example where we update a column for a certain primary key. In
      this example I am using an SQL statement that has place holders for row
      parameters. Most of the query and update methods have this functionality.
			The parameter values are passed in as an array of objects.</p><pre class="programlisting">import javax.sql.DataSource;

import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAnUpdate {
    private JdbcTemplate jt;
    private DataSource dataSource;

    public void setName(int id, String name) {
        jt = new JdbcTemplate(dataSource);
        jt.update("update mytable set name = ? where id = ?", new Object[] {name, new Integer(id)});
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}</pre><p></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-datasource"></a>10.3.&nbsp;Controlling how we connect to the database</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-DataSourceUtils"></a>10.3.1.&nbsp;DataSourceUtils</h3></div></div><div></div></div><p>Helper class that provides static methods to obtain connections
      from JNDI and close connections if necessary. Has support for
      thread-bound connections, e.g. for use with
      DataSourceTransactionManager.</p><p>Note: The getDataSourceFromJndi methods are targeted at
      applications that do not use a BeanFactory resp. an ApplicationContext.
      With the latter, it is preferable to preconfigure your beans or even
      <tt class="literal"><tt class="literal">JdbcTemplate</tt></tt> instances in the
      factory: <tt class="literal">JndiObjectFactoryBean</tt> can be used to fetch a
      <tt class="literal"><tt class="literal">DataSource</tt></tt> from JNDI and give the
      <tt class="literal"><tt class="literal">DataSource</tt></tt> bean reference to other
      beans. Switching to another
      <tt class="literal"><tt class="literal">DataSource</tt></tt> is just a matter of
      configuration then: You can even replace the definition of the
      <tt class="literal">FactoryBean</tt> with a non-JNDI
      <tt class="literal"><tt class="literal">DataSource</tt></tt>!</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SmartDataSource"></a>10.3.2.&nbsp;SmartDataSource</h3></div></div><div></div></div><p>Interface to be implemented by classes that can provide a
      connection to a relational database. Extends the
      <tt class="literal">javax.sql.DataSource</tt> interface to allow classes using
      it to query whether or not the connection should be closed after a given
      operation. This can sometimes be useful for efficiency, if we know that
      we want to reuse a connection.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-AbstractDataSource"></a>10.3.3.&nbsp;AbstractDataSource</h3></div></div><div></div></div><p>Abstract base class for Spring's <tt class="literal">DataSource</tt>
      implementations, taking care of the "uninteresting" glue. This is the
      class you would extend if you are writing your own
      <tt class="literal">DataSource</tt> implementation.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SingleConnectionDataSource"></a>10.3.4.&nbsp;SingleConnectionDataSource</h3></div></div><div></div></div><p>Implementation of <tt class="literal">SmartDataSource</tt> that wraps a
      single connection which is not closed after use. Obviously, this is not
      multi-threading capable.</p><p>If client code will call close in the assumption of a pooled
      connection, like when using persistence tools, set
      <tt class="literal">suppressClose</tt> to true. This will return a
      close-suppressing proxy instead of the physical connection. Be aware
      that you will not be able to cast this to a native Oracle Connection or
      the like anymore.</p><p>This is primarily a test class. For example, it enables easy
      testing of code outside an application server, in conjunction with a
      simple JNDI environment. In contrast to
      <tt class="literal">DriverManagerDataSource</tt>, it reuses the same
      connection all the time, avoiding excessive creation of physical
      connections.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-DriverManagerDataSource"></a>10.3.5.&nbsp;DriverManagerDataSource</h3></div></div><div></div></div><p>Implementation of <tt class="literal">SmartDataSource</tt> that
      configures a plain old JDBC Driver via bean properties, and returns a
      new connection every time.</p><p>Useful for test or standalone environments outside of a J2EE
      container, either as a <tt class="literal">DataSource</tt> bean in a
      respective ApplicationContext, or in conjunction with a simple JNDI
      environment. Pool-assuming <tt class="literal">Connection.close()</tt> calls
      will simply close the connection, so any DataSource-aware persistence
      code should work.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-DataSourceTransactionManager"></a>10.3.6.&nbsp;DataSourceTransactionManager</h3></div></div><div></div></div><p>PlatformTransactionManager implementation for single JDBC data
      sources. Binds a JDBC connection from the specified data source to the
      thread, potentially allowing for one thread connection per data
      source.</p><p>Application code is required to retrieve the JDBC connection via
      <tt class="literal">DataSourceUtils.getConnection(DataSource)</tt> instead of
      J2EE's standard <tt class="literal">DataSource.getConnection</tt>. This is
      recommended anyway, as it throws unchecked
      <tt class="literal">org.springframework.dao</tt> exceptions instead of checked
      <tt class="literal">SQLException</tt>. All framework classes like
      <tt class="literal">JdbcTemplate</tt> use this strategy implicitly. If not
      used with this transaction manager, the lookup strategy behaves exactly
      like the common one - it can thus be used in any case.</p><p>Supports custom isolation levels, and timeouts that get applied as
      appropriate JDBC statement query timeouts. To support the latter,
      application code must either use <tt class="literal">JdbcTemplate</tt> or call
      <tt class="literal">DataSourceUtils.applyTransactionTimeout</tt> method for
			each created statement.</p><p>This implementation can be used instead of
      <tt class="literal">JtaTransactionManager</tt> in the single resource case, as
      it does not require the container to support JTA. Switching between both
      is just a matter of configuration, if you stick to the required
      connection lookup pattern. Note that JTA does not support custom
      isolation levels!</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-object"></a>10.4.&nbsp;Modeling JDBC operations as Java objects</h2></div></div><div></div></div><p>The <tt class="literal">org.springframework.jdbc.object</tt> package
    contains the classes that allow you to access the database in a more
    object oriented manner. You can execute queries and get the results back
    as a list containing business objects with the relational column data
    mapped to the properties of the business object. You can also execute
    stored procedures and run update, delete and insert statements.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SqlQuery"></a>10.4.1.&nbsp;SqlQuery</h3></div></div><div></div></div><p>Reusable thread safe object to represent an SQL query. Subclasses
      must implement the newResultReader() method to provide an object that
      can save the results while iterating over the ResultSet. This class is
      rarely used directly since the <tt class="literal">MappingSqlQuery</tt>, that
      extends this class, provides a much more convenient implementation for
      mapping rows to Java classes. Other implementations that extend
      <tt class="literal">SqlQuery</tt> are
      <tt class="literal">MappingSqlQueryWithParameters</tt> and
      <tt class="literal">UpdatableSqlQuery</tt>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-MappingSqlQuery"></a>10.4.2.&nbsp;MappingSqlQuery</h3></div></div><div></div></div><p><tt class="literal">MappingSqlQuery</tt> is a reusable query in which
      concrete subclasses must implement the abstract
      <tt class="literal">mapRow(ResultSet, int)</tt> method to convert each row of
      the JDBC <tt class="literal">ResultSet</tt> into an object.</p><p>Of all the <tt class="literal">SqlQuery</tt> implementations, this is
      the one used most often and it is also the one that is the easiest to
      use.</p><p>Here is a brief example of a custom query that maps the data from
      the customer table to a Java object called Customer.</p><pre class="programlisting">  private class CustomerMappingQuery extends MappingSqlQuery {
    public CustomerMappingQuery(DataSource ds) {
      super(ds, "SELECT id, name FROM customer WHERE id = ?");
      super.declareParameter(new SqlParameter("id", Types.INTEGER));
      compile();
    }
    public Object mapRow(ResultSet rs, int rowNumber) throws SQLException {
      Customer cust = new Customer();
      cust.setId((Integer) rs.getObject("id"));
      cust.setName(rs.getString("name"));
      return cust;
    } 
  }</pre><p>We provide a constructor for this customer query that takes the
      <tt class="literal">DataSource</tt> as the only parameter. In this constructor
      we call the constructor on the superclass with the
      <tt class="literal">DataSource</tt> and the SQL that should be executed to
      retrieve the rows for this query. This SQL will be used to create a
      <tt class="literal">PreparedStatement</tt> so it may contain place holders for
      any parameters to be passed in during execution. Each parameter must be
      declared using the <tt class="literal">declareParameter</tt> method passing in
      an <tt class="literal">SqlParameter</tt>. The <tt class="literal">SqlParameter</tt>
      takes a name and the JDBC type as defined in
      <tt class="literal">java.sql.Types</tt>. After all parameters have been
      defined we call the <tt class="literal">compile</tt> method so the statement
      can be prepared and later be executed.</p><p>Let's take a look at the code where this custom query is
      instantiated and executed:</p><pre class="programlisting">    public Customer getCustomer(Integer id) {
        CustomerMappingQuery custQry = new CustomerMappingQuery(dataSource); 
        Object[] parms = new Object[1];
        parms[0] = id;
        List customers = custQry.execute(parms);
        if (customers.size() &gt; 0)
            return (Customer) customers.get(0);
        else
            return null;
    }</pre><p>The method in this example retrieves the customer with the id that
      is passed in as the only parameter. After creating an instance of the
      <tt class="literal">CustomerMappingQuery</tt> class we create an array of
      objects that will contain all parameters that are passed in. In this
      case there is only one parameter and it is passed in as an
      <tt class="literal">Integer</tt>. Now we are ready to execute the query using
      this array of parameters and we get a <tt class="literal">List</tt> that
      contains a <tt class="literal">Customer</tt> object for each row that was
      returned for our query. In this case it will only be one entry if there
      was a match.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SqlUpdate"></a>10.4.3.&nbsp;SqlUpdate</h3></div></div><div></div></div><p>RdbmsOperation subclass representing a SQL update. Like a query,
      an update object is reusable. Like all RdbmsOperation objects, an update
      can have parameters and is defined in SQL.</p><p>This class provides a number of update() methods analogous to the
      execute() methods of query objects.</p><p>This class is concrete. Although it can be subclassed (for example
      to add a custom update method) it can easily be parameterized by setting
      SQL and declaring parameters.</p><pre class="programlisting">import java.sql.Types;

import javax.sql.DataSource;

import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.SqlUpdate;

public class UpdateCreditRating  extends SqlUpdate {
    public UpdateCreditRating(DataSource ds) {
        setDataSource(ds);
        setSql("update customer set credit_rating = ? where id = ?");
        declareParameter(new SqlParameter(Types.NUMERIC));
        declareParameter(new SqlParameter(Types.NUMERIC));
        compile();
    }

    /**
     * @param id for the Customer to be updated
     * @param rating the new value for credit rating
     * @return number of rows updated
     */
    public int run(int id, int rating) {
        Object[] params =
            new Object[] {
                new Integer(rating),
                new Integer(id)};
        return update(params);
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-StoredProcedure"></a>10.4.4.&nbsp;StoredProcedure</h3></div></div><div></div></div><p>Superclass for object abstractions of RDBMS stored procedures.
      This class is abstract and its execute methods are protected, preventing
      use other than through a subclass that offers tighter typing.</p><p>The inherited sql property is the name of the stored procedure in
      the RDBMS. Note that JDBC 3.0 introduces named parameters, although the
      other features provided by this class are still necessary in JDBC
      3.0.</p><p>Here is an example of a program that calls a function sysdate()
      that comes with any Oracle database. To use the stored procedure
      functionality you have to create a class that extends
      <tt class="literal">StoredProcedure</tt>. There are no input parameters, but
      there is an output parameter that is declared as a date using the class
      <tt class="literal">SqlOutParameter</tt>. The <tt class="literal">execute()</tt>
      method returns a map with an entry for each declared output parameter
      using the parameter name as the key.</p><pre class="programlisting">import java.sql.Types;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.datasource.*;
import org.springframework.jdbc.object.StoredProcedure;

public class TestStoredProcedure {

    public static void main(String[] args)  {
        TestStoredProcedure t = new TestStoredProcedure();
        t.test();
        System.out.println("Done!");
    }
    
    void test() {
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName("oracle.jdbc.driver.OracleDriver");
        ds.setUrl("jdbc:oracle:thin:@localhost:1521:mydb");
        ds.setUsername("scott");
        ds.setPassword("tiger");

        MyStoredProcedure sproc = new MyStoredProcedure(ds);
        Map res = sproc.execute();
        printMap(res);
    }

    private class MyStoredProcedure extends StoredProcedure {
        public static final String SQL = "sysdate";

        public MyStoredProcedure(DataSource ds) {
            setDataSource(ds);
            setFunction(true);
            setSql(SQL);
            declareParameter(new SqlOutParameter("date", Types.DATE));
            compile();
        }

        public Map execute() {
            Map out = execute(new HashMap());
            return out;
        }

    }

    private static void printMap(Map r) {
        Iterator i = r.entrySet().iterator();
        while (i.hasNext()) {
            System.out.println((String) i.next().toString());  
        }
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SqlFunction"></a>10.4.5.&nbsp;SqlFunction</h3></div></div><div></div></div><p>SQL "function" wrapper for a query that returns a single row of
      results. The default behavior is to return an int, but that can be
      overridden by using the methods with an extra return type parameter.
      This is similar to using the <tt class="literal">queryForXxx</tt> methods of
      the <tt class="literal">JdbcTemplate</tt>. The advantage with
      <tt class="literal">SqlFunction</tt> is that you don't have to create the
      <tt class="literal">JdbcTemplate</tt>, it is done behind the scenes.</p><p>This class is intended to use to call SQL functions that return a
      single result using a query like "select user()" or "select sysdate from
      dual". It is not intended for calling more complex stored functions or
      for using a <tt class="literal">CallableStatement</tt> to invoke a stored
      procedure or stored function. Use <tt class="literal">StoredProcedure</tt> or
      <tt class="literal">SqlCall</tt> for this type of processing.</p><p>This is a concrete class, which there is normally no need to
      subclass. Code using this package can create an object of this type,
      declaring SQL and parameters, and then invoke the appropriate run method
      repeatedly to execute the function. Here is an example of retrieving the
      count of rows from a table:</p><pre class="programlisting">    public int countRows() {
        SqlFunction sf = new SqlFunction(dataSource, "select count(*) from mytable");
        sf.compile();
        return sf.run();
    }</pre><p></p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="orm"></a>Chapter&nbsp;11.&nbsp;Data Access using O/R Mappers</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-introduction"></a>11.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring provides integration with Hibernate, JDO, and iBATIS SQL Maps
    in terms of resource management, DAO implementation support, and
    transaction strategies. For Hibernate there is first-class support with
    lots of IoC convenience features, addressing many typical Hibernate
    integration issues. All of these comply with Spring's generic transaction
    and DAO exception hierarchies.</p><p>Spring's adds significant support when using the O/R mapping layer
    of your choice to create data-access applications. First of all you should
    know that once you started using Spring's support for O/R mapping, you
    don't have to go all the way. No matter to what extent, you're invited to
    review and leverage the Spring approach, before deciding to take the
    effort and risk of building a similar infrastructure in-house. Much of the
    O/R mapping support, no matter what technology you're using may be used in
    a library style, as everything is designed as a set of reusable JavaBeans.
    Usage inside an ApplicationContext or BeanFactory does provide additional
    benefits in terms of ease of configuration and deployment; as such, most
    examples in this section show configuration inside an
    ApplicationContext.</p><p>Some of the the benefits of using Spring to create your O/R mapping
    applications include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>To avoid vendor lock-in, and allow mix-and-match
        implementation strategies.</em></span> While Hibernate is powerful,
        flexible, open source and free, it still uses a proprietary API.
        Furthermore one could argue that iBatis is a bit lightweight, although
        it's excellent for use in application that don't require complex O/R
        mapping strategies. Given the choice, it's usually desirable to
        implement major application functionality using standard or abstracted
        APIs, in case you need to switch to another implementation for reasons
        of functionality, performance, or any other concerns. For example,
        Spring's abstraction of Hibernate Transactions and Exceptions, along
        with its IoC approach which allows you to easily swap in mapper/DAO
        objects implementing data-access functionality, makes it easy to
        isolate all Hibernate-specific code in one area of your application,
        without sacrificing any of the power of Hibernate. Higher level
        service code dealing with the DAOs has no need to know anything about
        their implementation. This approach has the additional benefit of
        making it easy to intentionally implement data-access with a
        mix-and-match approach (i.e. some data-access performed using
        Hibernate, and some using JDBC, others using iBatis) in a
        non-intrusive fashion, potentially providing great benefits in terms
        of continuing to use legacy code or leveraging the strength of each
        technology.</p></li><li><p><span class="emphasis"><em>Ease of testing</em></span>. Spring's inversion of
        control approach makes it easy to swap the implementations and
        locations of Hibernate session factories, datasources, transaction
        managers, and mapper object implementations (if needed). This makes it
        much easier to isolate and test each piece of persistence-related code
        in isolation.</p></li><li><p><span class="emphasis"><em>General resource management.</em></span> Spring
        application contexts can handle the location and configuration of
        Hibernate SessionFactories, JDBC datasources, iBatis SQLMaps
        configuration objects, and other related resources. This makes these
        values easy to manage and change. Spring offers efficient, easy and
        safe handling of Hibernate Sessions. Related code using Hibernate
        generally needs to use the same Hibernate Session object for
        efficiency and proper transaction handling. Spring makes it easy to
        transparently create and bind a session to the current thread, using
        either a declarative, AOP method interceptor approach, or by using an
        explicit, template wrapper class at the Java code level. Thus Spring
        solves many of the usage issues that repeatedly arise on the Hibernate
        forums.</p></li><li><p><span class="emphasis"><em>Exception wrapping.</em></span> Spring can wrap
        exceptions from you O/R mapping tool of choice, converting them from
        proprietary, checked exceptions, to a set of abstracted runtime
        exceptions. This allows you to handle most persistence exceptions,
        which are non-recoverable, only in the appropriate layers, without
        annoying boilerplate catches/throws, and exception declarations. You
        can still trap and handle exceptions anywhere you need to. Remember
        that JDBC exceptions (including DB specific dialects) are also
        converted to the same hierarchy, meaning that you can perform some
        operations with JDBC within a consistent programming model.</p></li><li><p><span class="emphasis"><em>Integrated transaction management.</em></span> Spring
        allows you to wrap your O/R mapping code with either a declarative,
        AOP style method interceptor, or an explicit 'template' wrapper class
        at the Java code level. In either case, transaction semantics are
        handled for you, and proper transaction handling (rollback, etc.) in
        case of exceptions is taken care of. As discussed below, you also get
        the benefit of being able to use and swap various transaction
        managers, without your Hibernate related code being affected. As an
        added benefit, JDBC-related code can fully integrate transactionally
        with the code you use to do O/R mapping. This is useful for handling
        functionality not implemented in, for example, Hibernate or iBatis.
				</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-hibernate"></a>11.2.&nbsp;Hibernate</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6074"></a>11.2.1.&nbsp;Resource Management</h3></div></div><div></div></div><p>Typical business applications are often cluttered with repetitive
      resource management code. Many projects try to invent their own
      solutions for this issue, sometimes sacrificing proper handling of
      failures for programming convenience. Spring advocates strikingly simple
      solutions for proper resource handling: Inversion of control via
      templating, i.e. infrastructure classes with callback interfaces, or
      applying AOP interceptors. The infrastructure cares for proper resource
      handling, and for appropriate conversion of specific API exceptions to
      an unchecked infrastructure exception hierarchy. Spring introduces a DAO
      exception hierarchy, applicable to any data access strategy. For direct
      JDBC, the <tt class="classname">JdbcTemplate</tt> class mentioned in a
      previous section cares for connection handling, and for proper
      conversion of <tt class="classname">SQLException</tt> to the
      <tt class="classname">DataAccessException</tt> hierarchy, including
      translation of database-specific SQL error codes to meaningful exception
      classes. It supports both JTA and JDBC transactions, via respective
      Spring transaction managers. Spring also offers Hibernate and JDO
      support, consisting of a <tt class="classname">HibernateTemplate</tt> /
      <tt class="classname">JdoTemplate</tt> analogous to
      <tt class="classname">JdbcTemplate</tt>, a
      <tt class="classname">HibernateInterceptor</tt> /
      <tt class="classname">JdoInterceptor</tt>, and a Hibernate / JDO transaction
      manager. The major goal is to allow for clear application layering, with
      any data access and transaction technology, and for loose coupling of
      application objects. No more business object dependencies on the data
      access or transaction strategy, no more hard-coded resource lookups, no
      more hard-to-replace singletons, no more custom service registries. One
      simple and consistent approach to wiring up application objects, keeping
      them as reusable and free from container dependencies as possible. All
      the individual data access features are usable on their own but
      integrate nicely with Spring's application context concept, providing
      XML-based configuration and cross-referencing of plain JavaBean
      instances that don't need to be Spring-aware. In a typical Spring app,
      many important objects are JavaBeans: data access templates, data access
      objects (that use the templates), transaction managers, business objects
      (that use the data access objects and transaction managers), web view
      resolvers, web controllers (that use the business objects), etc.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6103"></a>11.2.2.&nbsp;Resource Definitions in an Application Context</h3></div></div><div></div></div><p>To avoid tying application objects to hard-coded resource lookups,
      Spring allows you to define resources like a JDBC DataSource or a
      Hibernate SessionFactory as beans in an application context. Application
      objects that need to access resources just receive references to such
      pre-defined instances via bean references (the DAO definition in the
      next section illustrates this). The following excerpt from an XML
      application context definition shows how to set up a JDBC
      <tt class="classname">DataSource</tt> and a Hibernate
      <tt class="classname">SessionFactory</tt> on top of it:</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="myDataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;
            &lt;value&gt;java:comp/env/jdbc/myds&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

   &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
       &lt;property name="mappingResources"&gt;
           &lt;list&gt;
               &lt;value&gt;product.hbm.xml&lt;/value&gt;
           &lt;/list&gt;
       &lt;/property&gt;
       &lt;property name="hibernateProperties"&gt;
           &lt;props&gt;
               &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
           &lt;/props&gt;
       &lt;/property&gt;
       &lt;property name="dataSource"&gt;
           &lt;ref bean="myDataSource"/&gt;
       &lt;/property&gt;
   &lt;/bean&gt;

   ...

&lt;/beans&gt;</pre><p>Note that switching from a JNDI-located
      <tt class="classname">DataSource</tt> to a locally defined one like a
      Jakarta Commons DBCP <tt class="classname">BasicDataSource</tt> is just a
      matter of configuration:</p><pre class="programlisting">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName"&gt;
        &lt;value&gt;org.hsqldb.jdbcDriver&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="url"&gt;
        &lt;value&gt;jdbc:hsqldb:hsql://localhost:9001&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="username"&gt;
        &lt;value&gt;sa&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="password"&gt;
        &lt;value&gt;&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>You can also use a JNDI-located
      <tt class="classname">SessionFactory</tt>, but that's typically not
      necessary outside an EJB context (see the "container resources vs local
      resources" section for a discussion).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6131"></a>11.2.3.&nbsp;Inversion of Control: Template and Callback</h3></div></div><div></div></div><p>The basic programming model for templating looks as follows, for
      methods that can be part of any custom data access object or business
      object. There are no restrictions on the implementation of the
      surrounding object at all, it just needs to provide a Hibernate
      <tt class="classname">SessionFactory</tt>. It can get the latter from
      anywhere, but preferably as bean reference from a Spring application
      context - via a simple <tt class="literal">setSessionFactory</tt> bean
      property setter. The following snippets show a DAO definition in a
      Spring application context, referencing the above defined
      <tt class="classname">SessionFactory,</tt> and an example for a DAO method
      implementation.</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    ...

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public List loadProductsByCategory(final String category) {
        HibernateTemplate hibernateTemplate =
            new HibernateTemplate(this.sessionFactory);

        return (List) hibernateTemplate.execute(
            new HibernateCallback() {
                public Object doInHibernate(Session session) throws HibernateException {
                    List result = session.find(
                        "from test.Product product where product.category=?",
                        category, Hibernate.STRING);
                    // do some further stuff with the result list
                    return result;
                }
            }
        );
    }
}</pre><p>A callback implementation can effectively be used for any
      Hibernate data access. <tt class="classname">HibernateTemplate</tt> will
      ensure that <tt class="classname">Session</tt>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single step
      actions like a single find, load, saveOrUpdate, or delete call,
      <tt class="classname">HibernateTemplate</tt> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <tt class="classname">HibernateDaoSupport</tt> base class that provides a
      <tt class="literal">setSessionFactory</tt> method for receiving a
      SessionFactory, and <tt class="literal">getSessionFactory</tt> and
      <tt class="literal">getHibernateTemplate</tt> for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public List loadProductsByCategory(String category) {
        return getHibernateTemplate().find(
            "from test.Product product where product.category=?", category,
            Hibernate.STRING);
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6174"></a>11.2.4.&nbsp;Applying an AOP Interceptor Instead of a Template</h3></div></div><div></div></div><p>An alternative to using a <tt class="classname">HibernateTemplate</tt>
      is Spring's AOP <tt class="classname">HibernateInterceptor</tt>, replacing
      the callback implementation with straight Hibernate code within a
      delegating try/catch block, and a respective interceptor configuration
      in the application context. The following snippets show respective DAO,
      interceptor, and proxy definitions in a Spring application context, and
      an example for a DAO method implementation.</p><pre class="programlisting">&lt;beans&gt;

    ...

    &lt;bean id="myHibernateInterceptor" 
        class="org.springframework.orm.hibernate.HibernateInterceptor"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductDaoTarget" class="product.ProductDaoImpl"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductDao" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces"&gt;
            &lt;value&gt;product.ProductDao&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myHibernateInterceptor&lt;/value&gt;
                &lt;value&gt;myProductDaoTarget&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    ...

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public List loadProductsByCategory(final String category) throws MyException {
        Session session = SessionFactoryUtils.getSession(getSessionFactory(), false);
        try {
            List result = session.find(
                "from test.Product product where product.category=?",
                category, Hibernate.STRING);
            if (result == null) {
                throw new MyException("invalid search result");
            }
            return result;
        }
        catch (HibernateException ex) {
            throw SessionFactoryUtils.convertHibernateAccessException(ex);
        }
    }
}</pre><p>This method will only work with a
      <tt class="classname">HibernateInterceptor</tt> for it, caring for opening a
      thread-bound Session before and closing it after the method call. The
      "false" flag on getSession makes sure that the Session must already
      exist; otherwise <tt class="classname">SessionFactoryUtils</tt> would create
      a new one if none was found. If there is already a
      <tt class="classname">SessionHolder</tt> bound to the thread, e.g. by a
      <tt class="classname">HibernateTransactionManager</tt> transaction,
      <tt class="classname">SessionFactoryUtils</tt> automatically takes part in
      it in any case. <tt class="classname">HibernateTemplate</tt> uses
      <tt class="classname">SessionFactoryUtils</tt> internally - it's all the
      same infrastructure. The major advantage of
      <tt class="classname">HibernateInterceptor</tt> is that it allows any
      checked application exception to be thrown within the data access code,
      while HibernateTemplate is restricted to unchecked exceptions within the
      callback. Note that one can often defer the respective checks and
      throwing of application exceptions to after the callback, though. The
      interceptor's major drawback is that it requires special setup in the
      context. <tt class="classname">HibernateTemplate</tt>'s convenience methods
      offers simpler means for many scenarios.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6218"></a>11.2.5.&nbsp;Programmatic Transaction Demarcation</h3></div></div><div></div></div><p>On top of such lower-level data access services, transactions can
      be demarcated in a higher level of the application, spanning any number
      of operations. There are no restrictions on the implementation of the
      surrounding business object here too, it just needs a Spring
      <tt class="classname">PlatformTransactionManager</tt>. Again, the latter can
      come from anywhere, but preferably as bean reference via a
      <tt class="methodname">setTransactionManager</tt> method - just like the
      <tt class="classname">productDAO</tt> should be set via a
      <tt class="methodname">setProductDao</tt> method. The following snippets
      show a transaction manager and a business object definition in a Spring
      application context, and an example for a business method
      implementation.</p><pre class="programlisting">&lt;beans&gt;

    ...

    &lt;bean id="myTransactionManager" 
        class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
        &lt;property name="transactionManager"&gt;
            &lt;ref bean="myTransactionManager"/&gt;
        &lt;/property&gt;
        &lt;property name="productDao"&gt;
            &lt;ref bean="myProductDao"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private PlatformTransactionManager transactionManager;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        TransactionTemplate transactionTemplate = new TransactionTemplate(this.transactionManager);
        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        transactionTemplate.execute(
            new TransactionCallbackWithoutResult() {
                public void doInTransactionWithoutResult(TransactionStatus status) {
                    List productsToChange = productDAO.loadProductsByCategory(category);
                    ...
                }
            }
        );
    }
}</pre><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6240"></a>11.2.6.&nbsp;Declarative Transaction Demarcation</h3></div></div><div></div></div><p>Alternatively, one can use Spring's AOP TransactionInterceptor,
      replacing the transaction demarcation code with an interceptor
      configuration in the application context. This allows you to keep
      business objects free of repetitive transaction demarcation code in each
      business method. Furthermore, transaction semantics like propagation
      behavior and isolation level can be changed in a configuration file and
      do not affect the business object implementations.</p><pre class="programlisting">&lt;beans&gt;

    ...

    &lt;bean id="myTransactionManager" 
        class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myTransactionInterceptor" 
        class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
        &lt;property name="transactionManager"&gt;
            &lt;ref bean="myTransactionManager"/&gt;
        &lt;/property&gt;
        &lt;property name="transactionAttributeSource"&gt;
            &lt;value&gt;
                product.ProductService.increasePrice*=PROPAGATION_REQUIRED
                product.ProductService.someOtherBusinessMethod=PROPAGATION_MANDATORY
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
        &lt;property name="productDao"&gt;
            &lt;ref bean="myProductDao"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces"&gt;
            &lt;value&gt;product.ProductService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myTransactionInterceptor&lt;/value&gt;
                &lt;value&gt;myProductServiceTarget&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDAO.loadProductsByCategory(category);
        ...
    }

    ...

}</pre><p>As with <tt class="classname">HibernateInterceptor</tt>,
      <tt class="classname">TransactionInterceptor</tt> allows any checked
      application exception to be thrown with the callback code, while
      <tt class="classname">TransactionTemplate</tt> is restricted to unchecked
      exceptions within the callback.
      <tt class="classname">TransactionTemplate</tt> will trigger a rollback in
      case of an unchecked application exception, or if the transaction has
      been marked rollback-only by the application (via
      <tt class="classname">TransactionStatus</tt>).
      <tt class="classname">TransactionInterceptor</tt> behaves the same way by
      default but allows configurable rollback policies per method. A
      convenient alternative way of setting up declarative transactions is
      <tt class="classname">TransactionProxyFactoryBean</tt>, particularly if
      there are no other AOP interceptors involved.
      <tt class="classname">TransactionProxyFactoryBean</tt> combines the proxy
      definition itself with transaction configuration for a particular target
      bean. This reduces the configuration effort to one target bean plus one
      proxy bean. Furthermore, you do not need to specify which interfaces or
      classes the transactional methods are defined in.</p><pre class="programlisting">&lt;beans&gt;

    ...

    &lt;bean id="myTransactionManager" 
        class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
        &lt;property name="productDao"&gt;
            &lt;ref bean="myProductDao"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;
            &lt;ref bean="myTransactionManager"/&gt;
        &lt;/property&gt;
        &lt;property name="target"&gt;
            &lt;ref bean="myProductServiceTarget"/&gt;
        &lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
                &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_MANDATORY&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6277"></a>11.2.7.&nbsp;Transaction Management Strategies</h3></div></div><div></div></div><p>Both <tt class="classname">TransactionTemplate</tt> and
      <tt class="classname">TransactionInterceptor</tt> delegate the actual
      transaction handling to a
      <tt class="classname">PlatformTransactionManager</tt> instance, which can be
      a <tt class="classname">HibernateTransactionManager</tt> (for a single
      Hibernate SessionFactory, using a ThreadLocal Session under the hood) or
      a <tt class="classname">JtaTransactionManager</tt> (delegating to the JTA
      subsystem of the container) for Hibernate applications. You could even
      use a custom <tt class="classname">PlatformTransactionManager</tt>
      implementation. So switching from native Hibernate transaction
      management to JTA, i.e. when facing distributed transaction requirements
      for certain deployments of your application, is just a matter of
      configuration. Simply replace the Hibernate transaction manager with
      Spring's JTA transaction implementation. Both transaction demarcation
      and data access code will work without changes, as they just use the
      generic transaction management APIs. For distributed transactions across
      multiple Hibernate session factories, simply combine
      <tt class="classname">JtaTransactionManager</tt> as a transaction strategy
      with multiple <tt class="classname">LocalSessionFactoryBean</tt>
      definitions. Each of your DAOs then gets one specific SessionFactory
      reference passed into its respective bean property. If all underlying
      JDBC data sources are transactional container ones, a business object
      can demarcate transactions across any number of DAOs and any number of
      session factories without special regard, as long as it is using
      <tt class="classname">JtaTransactionManager</tt> as the strategy.</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="myDataSource1" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;
            &lt;value&gt;java:comp/env/jdbc/myds1&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myDataSource2" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;
            &lt;value&gt;java:comp/env/jdbc/myds2&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="mySessionFactory1" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
        &lt;property name="mappingResources"&gt;
            &lt;list&gt;
                &lt;value&gt;product.hbm.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name="dataSource"&gt;
            &lt;ref bean="myDataSource1"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="mySessionFactory2" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
        &lt;property name="mappingResources"&gt;
            &lt;list&gt;
                &lt;value&gt;inventory.hbm.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.OracleDialect&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name="dataSource"&gt;
            &lt;ref bean="myDataSource2"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myTransactionManager" 
        class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory1"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory2"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
        &lt;property name="productDao"&gt;
            &lt;ref bean="myProductDao"/&gt;
        &lt;/property&gt;
        &lt;property name="inventoryDao"&gt;
            &lt;ref bean="myInventoryDao"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;
            &lt;ref bean="myTransactionManager"/&gt;
        &lt;/property&gt;
        &lt;property name="target"&gt;
            &lt;ref bean="myProductServiceTarget"/&gt;
        &lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
                &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_MANDATORY&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Both <tt class="classname">HibernateTransactionManager</tt> and
      <tt class="classname">JtaTransactionManager</tt> allow for proper JVM-level
      cache handling with Hibernate - without container-specific transaction
      manager lookup or JCA connector (as long as not using EJB to initiate
      transactions). Additionally,
      <tt class="classname">HibernateTransactionManager</tt> can export the JDBC
      Connection used by Hibernate to plain JDBC access code. This allows for
      high level transaction demarcation with mixed Hibernate/JDBC data access
      completely without JTA, as long as just accessing one database!</p><p>Note, for an alternative approach to using
      <tt class="classname">TransactionProxyFactoryBean</tt> to declaratively
      demarcate transactions, please see <a href="#beannameautoproxycreator-for-transactions">Section&nbsp;7.4.1, &#8220;BeanNameAutoProxyCreator,
      another declarative approach&#8221;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6329"></a>11.2.8.&nbsp;Container Resources versus Local Resources</h3></div></div><div></div></div><p>Spring's resource management allows for simple switching between a
      JNDI SessionFactory and a local one, same for a JNDI DataSource, without
      having to change a single line of application code. Whether to keep the
      resource definitions in the container or locally within the application,
      is mainly a matter of the transaction strategy being used. Compared to a
      Spring-defined local SessionFactory, a manually registered JNDI
      SessionFactory does not provide any benefits. If registered via
      Hibernate's JCA connector, there is the added value of transparently
      taking part in JTA transactions, especially within EJBs. An important
      benefit of Spring's transaction support is that it isn't bound to a
      container at all. Configured to any other strategy than JTA, it will
      work in a standalone or test environment too. Especially for the typical
      case of single-database transactions, this is a very lightweight and
      powerful alternative to JTA. When using local EJB Stateless Session
      Beans to drive transactions, you depend both on an EJB container and JTA
      - even if you just access a single database anyway, and just use SLSBs
      for declarative transactions via CMT. The alternative of using JTA
      programmatically requires a J2EE environment too. JTA does not just
      involve container dependencies in terms of JTA itself and of JNDI
      DataSources. For non-Spring JTA-driven Hibernate transactions, you have
      to use the Hibernate JCA connector, or extra Hibernate transaction code
      with JTATransaction being configured, for proper JVM-level caching.
      Spring-driven transactions can work with a locally defined Hibernate
      SessionFactory nicely, just like with a local JDBC DataSource - if
      accessing a single database, of course. Therefore you just have to fall
      back to Spring's JTA transaction strategy when actually facing
      distributed transaction requirements. Note that a JCA connector needs
      container-specific deployment steps, and obviously JCA support in the
      first place. This is far more hassle than deploying a simple web app
      with local resource definitions and Spring-driven transactions. And you
      often need the Enterprise Edition of your container, as e.g. WebLogic
      Express does not provide JCA. A Spring app with local resources and
      transactions spanning one single database will work in any J2EE web
      container (without JTA, JCA, or EJB) - like Tomcat, Resin, or even plain
      Jetty. Additionally, such a middle tier can be reused in desktop
      applications or test suites easily. All things considered: If you do not
      use EJB, stick with local SessionFactory setup and Spring's
      <tt class="classname">HibernateTransactionManager</tt> or
      <tt class="classname">JtaTransactionManager</tt>. You will get all benefits
      including proper transactional JVM-level caching and distributed
      transactions, without any container deployment hassle. JNDI registration
      of a Hibernate SessionFactory via the JCA connector only adds value for
      use within EJBs.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6340"></a>11.2.9.&nbsp;Samples</h3></div></div><div></div></div><p>The Petclinic sample in the Spring distribution offers alternative
			DAO implementations and application context configurations for Hibernate,
			JDBC, and Apache OJB. Petclinic can therefore serve as working sample
      app that illustrates the use of Hibernate in a Spring web app. It also
      leverages declarative transaction demarcation with different transaction
      strategies.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6345"></a>11.3.&nbsp;JDO</h2></div></div><div></div></div><p>ToDo</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6350"></a>11.4.&nbsp;iBATIS</h2></div></div><div></div></div><p>Through the <tt class="literal">org.springframework.orm.ibatis</tt>
    package, Spring supports iBATIS SqlMaps 1.3.x and 2.0.x. The iBATIS
    support much resembles Hibernate support in that it supports the same
    template style programming and just as with Hibernate, iBatis support
    works with Spring's exception hierarchy and let's you enjoy the all IoC
    features Spring has.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6358"></a>11.4.1.&nbsp;Overview and differences between 1.3.x and 2.0</h3></div></div><div></div></div><p>Spring supports both iBATIS SqlMaps 1.3 and 2.0. First let's have
      a look at the differences between the two. </p><p>The xml config files have changed a bit, node and attribute names.
      Also the Spring clases you need to extend are different, as some method
      names.</p><div class="table"><a name="d0e6365"></a><p class="title"><b>Table&nbsp;11.1.&nbsp;iBATIS SqlMaps supporting classes for 1.3 and 2.0</b></p><table summary="iBATIS SqlMaps supporting classes for 1.3 and 2.0" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Feature</th><th>1.3.x</th><th>2.0</th></tr></thead><tbody><tr><td>Creation of SqlMap</td><td><tt class="literal">SqlMapFactoryBean</tt></td><td><tt class="literal">SqlMapClientFactoryBean</tt></td></tr><tr><td>Template-style helper class</td><td><tt class="literal">SqlMapTemplate</tt></td><td><tt class="literal">SqlMapClientTemplate</tt></td></tr><tr><td>Callback to use MappedStatement</td><td><tt class="literal">SqlMapCallback</tt></td><td><tt class="literal">SqlMapClientCallback</tt></td></tr><tr><td>Super class for DAOs</td><td><tt class="literal">SqlMapDaoSupport</tt></td><td><tt class="literal">SqlMapClientDaoSupport</tt></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6417"></a>11.4.2.&nbsp;iBATIS 1.3.x</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6420"></a>11.4.2.1.&nbsp;Setting up the SqlMap</h4></div></div><div></div></div><p>Using iBATIS SqlMaps involves creating SqlMap configuration
        files containing statements and result maps. Spring takes care of
        loading those using the <tt class="literal">SqlMapFactoryBean</tt>.</p><pre class="programlisting">		
public class Account {
	private String name;
	private String email;
	
	public String getName() {
		return this.name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public String getEmail() {
		return this.email;
	}
	
	public void setEmail(String email) {
		this.email = email;
	}
}</pre><p>Suppose we would want to map this class. We'd have to create
        the following SqlMap. Using the query, we can later on retrieve users
        through their email addresses. <tt class="literal">Account.xml</tt>:
        </p><pre class="programlisting">
&lt;sql-map name="Account"&gt;
	&lt;result-map name="result" class="examples.Account"&gt;
		&lt;property name="name" column="NAME" columnIndex="1"/&gt;
		&lt;property name="email" column="EMAIL" columnIndex="2"/&gt;
	&lt;/result-map&gt;
	
	&lt;mapped-statement name="getAccountByEmail" result-map="result"&gt;
		select
			  ACCOUNT.NAME,
			  ACCOUNT.EMAIL
		from ACCOUNT
		where ACCOUNT.EMAIL = #value#
	&lt;/mapped-statement&gt;
	
	&lt;mapped-statement name="insertAccount"&gt;
		insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
	&lt;/mapped-statement&gt;
&lt;/sql-map&gt;
</pre><p> After having defined the Sql Map, we have to create a
        configuration file for iBATIS (<tt class="literal">sqlmap-config.xml</tt>):
        </p><pre class="programlisting">
&lt;sql-map-config&gt;

	&lt;sql-map resource="example/Account.xml"/&gt;

&lt;/sql-map-config&gt;
</pre><p> iBATIS loads resources from the classpath so be sure to add
        the Account.xml file to the classpath somewhere.</p><p>Using Spring, we can now very easily set up the SqlMap, using
        the <tt class="literal">SqlMapFactoryBean</tt>: </p><pre class="programlisting">
&lt;bean id="sqlMap" class="org.springframework.orm.ibatis.SqlMapFactoryBean"&gt;
	&lt;property name="configLocation"&gt;&lt;value&gt;WEB-INF/sqlmap-config.xml&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6451"></a>11.4.2.2.&nbsp;Using <tt class="literal">SqlMapDaoSupport</tt></h4></div></div><div></div></div><p>The <tt class="literal">SqlMapDaoSupport</tt> class offers a
        supporting class similar to the <tt class="literal">HibernateDaoSupport</tt>
        and the <tt class="literal">JdbcDaoSupport</tt> types. Let's implement a
        DAO: </p><pre class="programlisting">
public class SqlMapAccountDao extends SqlMapDaoSupport implements AccountDao {

	public Account getAccount(String email) throws DataAccessException {
		return (Account) getSqlMapTemplate().executeQueryForObject("getAccountByEmail", email);
	}

	public void insertAccount(Account account) throws DataAccessException {
		getSqlMapTemplate().executeUpdate("insertAccount", account);
	}
}
</pre><p> As you can see, we're using the SqlMapTemplate to execute
        the query. Spring has initialized the SqlMap for us using the
        SqlMapFactoryBean and when setting up the SqlMapAccountDao as follows,
        you're all set to go: </p><pre class="programlisting">
&lt;!-- for more information about using datasource, have a look at the JDBC chapter --&gt;
&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
	&lt;property name="driverClassName"&gt;&lt;value&gt;${jdbc.driverClassName}&lt;/value&gt;&lt;/property&gt;
	&lt;property name="url"&gt;&lt;value&gt;${jdbc.url}&lt;/value&gt;&lt;/property&gt;
	&lt;property name="username"&gt;&lt;value&gt;${jdbc.username}&lt;/value&gt;&lt;/property&gt;
	&lt;property name="password"&gt;&lt;value&gt;${jdbc.password}&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
	&lt;property name="dataSource"&gt;&lt;ref local="dataSource"/&gt;&lt;/property&gt;
	&lt;property name="sqlMap"&gt;&lt;ref local="sqlMap"/&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6472"></a>11.4.2.3.&nbsp;Transaction management</h4></div></div><div></div></div><p>It's pretty easy to add declarative transaction management to
        applications using iBATIS. Basically the only thing you need to do is
        adding a transaction manager to you application context and
        declaratively set your transaction boundaries using for example the
        <tt class="literal">TransactionProxyFactoryBean</tt>. More on this can be
        found in <a href="#transaction" title="Chapter&nbsp;7.&nbsp;Transaction management">Chapter&nbsp;7, <i>Transaction management</i></a></p><p>TODO elaborate!</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6483"></a>11.4.3.&nbsp;iBATIS 2</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6486"></a>11.4.3.1.&nbsp;Setting up the SqlMap</h4></div></div><div></div></div><p>If we want to map the previous Account class with iBATIS 2 we
        need to create the following SqlMap <tt class="literal">Account.xml</tt>:
        </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE sqlMap PUBLIC
  "-//iBATIS.com//DTD SQL Map 2.0//EN"
  "http://www.ibatis.com/dtd/sql-map-2.dtd"&gt;

&lt;sqlMap namespace="Account"&gt;

	&lt;resultMap id="result" class="examples.Account"&gt;
		&lt;result property="name" column="NAME" columnIndex="1"/&gt;
		&lt;result property="email" column="EMAIL" columnIndex="2"/&gt;
	&lt;/resultMap&gt;

	&lt;select id="getAccountByEmail" resultMap="result"&gt;
		select
			  ACCOUNT.NAME,
			  ACCOUNT.EMAIL
		from ACCOUNT
		where ACCOUNT.EMAIL = #value#
	&lt;/select&gt;

	&lt;insert id="insertAccount"&gt;
		insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
	&lt;/insert&gt;

&lt;/sqlMap&gt;
</pre><p>The configuration file for iBATIS 2 changes a bit
        (<tt class="literal">sqlmap-config.xml</tt>): </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE sqlMapConfig PUBLIC
  "-//iBATIS.com//DTD SQL Map Config 2.0//EN"
  "http://www.ibatis.com/dtd/sql-map-config-2.dtd"&gt;

&lt;sqlMapConfig&gt;

	&lt;sqlMap resource="example/Account.xml"/&gt;

&lt;/sqlMapConfig&gt;
</pre><p>Remember that iBATIS loads resources from the classpath so be
        sure to add the Account.xml file to the classpath somewhere.</p><p>We can use the <tt class="literal">SqlMapClientFactoryBean</tt> in the
        Spring application context :</p><pre class="programlisting">
&lt;bean id="sqlMapClient" class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
	&lt;property name="configLocation"&gt;&lt;value&gt;WEB-INF/sqlmap-config.xml&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6510"></a>11.4.3.2.&nbsp;Using <tt class="literal">SqlMapClientDaoSupport</tt></h4></div></div><div></div></div><p>The <tt class="literal">SqlMapClientDaoSupport</tt> class offers a
        supporting class similar to the <tt class="literal">SqlMapDaoSupport</tt>.
        We extend it to implement our DAO: </p><pre class="programlisting">
public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {

	public Account getAccount(String email) throws DataAccessException {
		Account acc = new Account();
		acc.setEmail();
		return (Account)getSqlMapClientTemplate().queryForObject("getAccountByEmail", email);
	}

	public void insertAccount(Account account) throws DataAccessException {
		getSqlMapClientTemplate().update("insertAccount", account);
	}
}
</pre><p>In the DAO we use the SqlMapClientTemplate to execute the
        queries, after setting up the SqlMapAccountDao in the application
        context:</p><pre class="programlisting">
&lt;!-- for more information about using datasource, have a look at the JDBC chapter --&gt;
&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
	&lt;property name="driverClassName"&gt;&lt;value&gt;${jdbc.driverClassName}&lt;/value&gt;&lt;/property&gt;
	&lt;property name="url"&gt;&lt;value&gt;${jdbc.url}&lt;/value&gt;&lt;/property&gt;
	&lt;property name="username"&gt;&lt;value&gt;${jdbc.username}&lt;/value&gt;&lt;/property&gt;
	&lt;property name="password"&gt;&lt;value&gt;${jdbc.password}&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
	&lt;property name="dataSource"&gt;&lt;ref local="dataSource"/&gt;&lt;/property&gt;
	&lt;property name="sqlMapClient"&gt;&lt;ref local="sqlMapClient"/&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mvc"></a>Chapter&nbsp;12.&nbsp;Web MVC framework</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-introduction"></a>12.1.&nbsp;Introduction to the web MVC framework</h2></div></div><div></div></div><p>Spring's web MVC framework is designed around a DispatcherServlet that
    dispatches requests to handlers, with configurable handler mappings, view
    resolution, locale and theme resolution as well as support for upload files.
    The default handler is a very simple Controller interface, just offering a
    <tt class="literal">ModelAndView handleRequest(request,response)</tt> method.
    This can already be used for application controllers, but you will prefer
    the included implementation hierarchy, consisting of, for example
    <tt class="literal">AbstractController</tt>,
    <tt class="literal">AbstractCommandController</tt> and
    <tt class="literal">SimpleFormController</tt>. Application controllers will
    typically be subclasses of those. Note that you can choose an appropriate
    base class: If you don't have a form, you don't need a FormController.
    This is a major difference to Struts.</p><p>You can use any object as a command or form object - there's no need
    to implement an interface or derive from a base class. Spring's data binding
    is highly flexible, for example, it treats type mismatches as validation
    errors that can be evaluated by the application, not as system errors. So
    you don't need to duplicate your business objects' properties as Strings
    in your form objects, just to be able to handle invalid submissions, or to
    convert the Strings properly. Instead, it is often preferable to bind
    directly to your business objects. This is another major difference to
    Struts which is built around required base classes like
    <tt class="literal">Action</tt> and <tt class="literal">ActionForm</tt> - for every
    type of action.</p><p>Compared to WebWork, Spring has more differentiated object roles. It
    supports the notion of a Controller, an optional command or form object,
    and a model that gets passed to the view. The model will normally include
    the command or form object but also arbitrary reference data. Instead, a
    WebWork Action combines all those roles into one single object. WebWork
    does allow you to use existing business objects as part of your form, but
    only by making them bean properties of the respective Action class.
    Finally, the same Action instance that handles the request is used for
    evaluation and form population in the view. Thus, reference data needs to
    be modeled as bean properties of the Action too. These are arguably too
    many roles for one object.</p><p>Spring's view resolution is extremely flexible. A
    Controller implementation can even write a view directly to the response,
    returning null as ModelAndView. In the normal case, a ModelAndView
    instance consists of a view name and a model Map, containing bean names
    and corresponding objects (like a command or form, containing reference data).
    View name resolution is highly configurable, either via bean names, via a
    properties file, or via your own ViewResolver implementation. The abstract
    model Map allows for complete abstraction of the view technology, without
    any hassle. Any renderer can be integrated directly, whether JSP, Velocity,
    or any other rendering technology. The model Map is simply transformed into an
    appropriate format, such as JSP request attributes or a Velocity template
    model.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-introduction-pluggability"></a>12.1.1.&nbsp;Pluggability of other MVC implementations</h3></div></div><div></div></div><p>There are several reasons why some projects will prefer to use other
      MVC implementations. Many teams expect to leverage their existing
      investment in skills and tools. In addition, there is a large body of
      knowledge and experience avalailable for the Struts framework. Thus,
      if you can live with Struts' architectural flaws, it can still be a
      viable choice for the web layer. The same applies to WebWork and other
      web MVC frameworks.</p><p>If you don't want to use Spring's web MVC, but intend to leverage
      other solutions that Spring offers, you can integrate the web MVC framework
      of your choice with Spring easily. Simply start up a Spring root
      application context via its ContextLoaderListener, and access it via its
      ServletContext attribute (or Spring's respective helper method) from
      within a Struts or WebWork action. Note that there aren't any "plugins"
      involved, so no dedicated integration is necessary. From the web layer's
      point of view, you'll simply use Spring as a library, with the root
      application context instance as the entry point.</p><p>All your registered beans and all of Spring's services can be at
      your fingertips even without Spring's web MVC. Spring doesn't compete
      with Struts or WebWork in this scenario, it just addresses the many areas
      that the pure web MVC frameworks don't, from bean configuration to data
      access and transaction handling. So you are able to enrich your
      application with a Spring middle tier and/or data access tier, even if
      you just want to use, for example, the transaction abstraction with JDBC or
      Hibernate.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-features"></a>12.1.2.&nbsp;Features of Spring MVC</h3></div></div><div></div></div><p>Spring's web module provides a wealth of unique web support
      features, including:</p><div class="itemizedlist"><ul type="disc" compact><li><p>Clear separation of roles - controller, validator, command
          object, form object, model object, DispatcherServlet, handler
          mapping, view resolver, etc. Each role can be fulfilled by a
          specialized object.</p></li><li><p>Powerful and straightforward configuration of both framework
          and application classes as JavaBeans, including easy referencing across
          contexts, such as from web controllers to business objects and
          validators.</p></li><li><p>Adaptability, non-intrusiveness. Use whatever controller
          subclass you need (plain, command, form, wizard, multi-action, or a
          custom one) for a given scenario instead of deriving from
          a single controller for everything.</p></li><li><p>Reusable business code - no need for duplication. You can use
          existing business objects as command or form objects instead of
          mirroring them in order to extend a particular framework base class.</p></li><li><p>Customizable binding and validation - type mismatches as
          application-level validation errors that keep the offending value,
          localized date and number binding, etc instead of String-only form
          objects with manual parsing and conversion to business
          objects.</p></li><li><p>Customizable handler mapping and view resolution - handler
          mapping and view resolution strategies range from simple URL-based
          configuration, to sophisticated, purpose-built resolution strategies.
          This is more flexible than some web MVC frameworks which mandate a
          particular technique.</p></li><li><p>Flexible model transfer - model transfer via a name/value Map
          supports easy integration with any view technology.</p></li><li><p>Customizable locale and theme resolution, support for JSPs
          with or without Spring tag library, support for JSTL, support for
          Velocity without the need for extra bridges, etc.</p></li><li><p>A simple but powerful tag library that avoids HTML generation at
          any cost, allowing for maximum flexibility in terms of markup
          code.</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-servlet"></a>12.2.&nbsp;The <tt class="literal">DispatcherServlet</tt></h2></div></div><div></div></div><p>Spring's web MVC framework is, like many other web MVC frameworks, a
    request-driven web MVC framework, designed around a servlet that dispatches
    requests to controllers and offers other functionality facilitating the
    development of web applications. Spring's
    <tt class="literal">DispatcherServlet</tt> however, does more than just that. It
    is completely integrated with the Spring ApplicationContext and allows you
    to use every other feature Spring has.</p><p>Like ordinary servlets, the DispatcherServlet is declared in the
    <tt class="literal">web.xml</tt> of your web application. Requests that you want the
    DispatcherServlet to handle, will have to be mapped, using a URL mapping
    in the same <tt class="literal">web.xml</tt> file.</p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>In the example above, all requests ending with
    <tt class="literal">.form</tt> will be handled by the DispatcherServlet. The
    DispatcherServlet now needs to be configured. As illustrated in <a href="#context-introduction" title="3.11.&nbsp;Introduction to the ApplicationContext">Section&nbsp;3.11, &#8220;Introduction to the ApplicationContext&#8221;</a>, ApplicationContexts in Spring can be
    scoped. In the web MVC framework, each DispatcherServlet has its own
    <tt class="literal">WebApplicationContext</tt>, which contains the
    DispatcherServlet configuration beans. The default BeanFactory used by the
    DispatcherServlet is the <tt class="literal">XmlBeanFactory</tt> and the
    DispatcherServlet will on initialization <span class="emphasis"><em>look for a file named
    <tt class="literal">[servlet-name]-servlet.xml</tt></em></span> in the
    <tt class="literal">WEB-INF</tt> directory of your web application. The default
    values used by the DispatcherServlet can be modified by using the servlet
    initialization parameters (see below for more information).</p><p>The <tt class="literal">WebApplicationContext</tt> is just an ordinary
    ApplicationContext that has some extra features necessary for
    web applications. It differs from a normal ApplicationContext in that it is
    capable of resolving themes (see <a href="#mvc-themeresolver" title="12.7.&nbsp;Using themes">Section&nbsp;12.7, &#8220;Using themes&#8221;</a>),
    and that is knows which servlet it is associated with (by having a link to
    the <tt class="literal">ServletContext</tt>). The WebApplicationContext is bound
    in the ServletContext, and using <tt class="literal">RequestContextUtils</tt>
    you can always lookup the WebApplicationContext in case you need
    it.</p><p>The Spring DispatcherServlet has a couple of special beans it uses,
    in order to be able to process requests and render the appropriate views.
    These beans are included in the Spring framework and can
    be configured in the WebApplicationContext, just as any other bean would
    be configured. Each of those beans, is described in more detail
    below. Right now, we'll just mention them, just to let you know they exist
    and to enable us to go on talking about the DispatcherServlet. For most of
    the beans, defaults are provided so you don't have to worry about
    configuring them.</p><div class="table"><a name="d0e6658"></a><p class="title"><b>Table&nbsp;12.1.&nbsp;Special beans in the WebApplicationContext</b></p><table summary="Special beans in the WebApplicationContext" border="1"><colgroup><col><col></colgroup><thead><tr><th>Expression</th><th>Explanation</th></tr></thead><tbody><tr><td>handler mapping(s)</td><td>(<a href="#mvc-handlermapping" title="12.4.&nbsp;Handler mappings">Section&nbsp;12.4, &#8220;Handler mappings&#8221;</a>) a list of pre- and
            postprocessors and controllers that will be executed if they match
            certain criteria (for instance a matching URL specified with the
            controller)</td></tr><tr><td>controller(s)</td><td>(<a href="#mvc-controller" title="12.3.&nbsp;Controllers">Section&nbsp;12.3, &#8220;Controllers&#8221;</a>) the beans providing the
            actual functionality (or at least, access to the functionality) as
            part of the MVC triad</td></tr><tr><td>view resolver</td><td>(<a href="#mvc-viewresolver" title="12.5.&nbsp;Views and resolving them">Section&nbsp;12.5, &#8220;Views and resolving them&#8221;</a>) capable of resolving
            view names to views, used by the DispatcherServlet</td></tr><tr><td>locale resolver</td><td>(<a href="#mvc-localeresolver" title="12.6.&nbsp;Using locales">Section&nbsp;12.6, &#8220;Using locales&#8221;</a>) capable of resolving
            the locale a client is using, in order to be able to offer
            internationalized views</td></tr><tr><td>theme resolver</td><td>(<a href="#mvc-themeresolver" title="12.7.&nbsp;Using themes">Section&nbsp;12.7, &#8220;Using themes&#8221;</a>) capable of resolving
            themes your web application can use, for example, to offer
            personalized layouts</td></tr><tr><td>multipart resolver</td><td>(<a href="#mvc-multipart" title="12.8.&nbsp;Spring's multipart (fileupload) support">Section&nbsp;12.8, &#8220;Spring's multipart (fileupload) support&#8221;</a>) offers functionality to
            process file uploads from HTML forms</td></tr><tr><td>handlerexception resolver</td><td>(<a href="#mvc-exceptionhandlers" title="12.9.&nbsp;Handling exceptions">Section&nbsp;12.9, &#8220;Handling exceptions&#8221;</a>) offers
            functionality to map exceptions to views or implement other more
            complex exception handling code</td></tr></tbody></table></div><p>When a DispatcherServlet is setup for use and a request comes in for
    that specific DispatcherServlet it starts processing it. The list below
    describes the complete process a request goes through if handled by a
    DispatcherServlet: </p><div class="orderedlist"><ol type="1" compact><li><p>The WebApplicationContext is searched for and bound in the
          request as an attribute in order for the controller and other elements
          in the process to use. It is bound by default under the key
          <tt class="literal">DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</tt>.</p></li><li><p>The locale resolver is bound to the request to let elements in
          the process resolve the locale to use when processing the request
          (rendering the view, preparing data, etc.) If you don't use the
          resolver, it won't affect anything, so if you don't need locale
          resolving, you don't have to use it.</p></li><li><p>The theme resolver is bound to the request to let elements such
          as views determine which theme to use. The theme resolver does not
          affect anything if you don't use it, so if you don't need themes you
          can just ignore it.</p></li><li><p>If a multipart resolver is specified, the request is inspected
          for multiparts and if they are found, it is wrapped in a
          <tt class="literal">MultipartHttpServletRequest</tt> for further
          processing by other elements in the process. (See
          <a href="#mvc-multipart-resolver" title="12.8.2.&nbsp;Using the MultipartResolver">Section&nbsp;12.8.2, &#8220;Using the MultipartResolver&#8221;</a> for further information about
          multipart handling).</p></li><li><p>An appropriate handler is searched for. If a handler is found,
          the execution chain associated with the handler (preprocessors,
          postprocessors, controllers) will be executed in order to prepare a
          model.</p></li><li><p>If a model is returned, the view is rendered, using the view
          resolver that has been configured with the WebApplicationContext. If
          no model is returned (which could be due to a pre- or
          postprocessor intercepting the request, for example, for security
          reasons), no view is rendered, since the request could already have
          been fulfilled.</p></li></ol></div><p>Exceptions that might be thrown during processing of the request get
    picked up by any of the handlerexception resolvers that are declared in
    the WebApplicationContext. Using these exception resolvers you can define
    custom behavior in case such exceptions get thrown.</p><p>The Spring DispatcherServlet also has support for returning the
    <span class="emphasis"><em>last-modification-date</em></span>, as specified by the Servlet
    API. The process of determining the last modification date for a specific
    request, is simple. The DispatcherServlet will first lookup an
    appropriate handler mapping and test if the handler that is found
    <span class="emphasis"><em>implements the interface
    <tt class="literal">LastModified</tt></em></span> and if so, the value of
    <tt class="literal">long getLastModified(request)</tt> is returned to the
    client.</p><p>You can customize Spring's DispatcherServlet by adding context
    parameters in the <tt class="literal">web.xml</tt> file or servlet init
    parameters. The possibilities are listed below.</p><div class="table"><a name="d0e6769"></a><p class="title"><b>Table&nbsp;12.2.&nbsp;DispatcherServlet initialization parameters</b></p><table summary="DispatcherServlet initialization parameters" border="1"><colgroup><col><col></colgroup><thead><tr><th>Parameter</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">contextClass</tt></td><td>Class that implements
            <tt class="literal">WebApplicationContext</tt>, which will be used to
            instantiate the context used by this servlet. If this parameter
            isn't specified, the <tt class="literal">XmlWebApplicationContext</tt>
            will be used.</td></tr><tr><td><tt class="literal">contextConfigLocation</tt></td><td>String which is passed to the context instance (specified
            by <tt class="literal">contextClass</tt>) to indicate where context(s)
            can be found. The String is potentially split up into multiple
            strings (using a comma as a delimiter) to support multiple
            contexts (in case of multiple context locations, of beans that are
            defined twice, the latest takes precedence).</td></tr><tr><td>namespace</td><td>the namespace of the
            <tt class="literal">WebApplicationContext</tt>. Defaults to
            <tt class="literal">[server-name]-servlet</tt>.</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-controller"></a>12.3.&nbsp;Controllers</h2></div></div><div></div></div><p>The notion of a controller is part of the MVC design pattern.
    Controllers define application behavior, or at least provide
    access to the application behavior. Controllers interpret user input and
    transform the user input into a sensible model which will be represented
    to the user by the view. Spring has implemented the notion of a controller
    in a very abstract way enabling a wide variety of different kinds of
    controllers to be created. Spring contains formcontroller,
    commandcontroller, controllers that execute wizard-style logic, and
    more.</p><p>Spring's basis for the controller architecture is the
    <tt class="literal">org.springframework.web.servlet.mvc.Controller</tt> interface,
		which is listed below. </p><pre class="programlisting">public interface Controller {

    /**
     * Process the request and return a ModelAndView object which the DispatcherServlet
     * will render.
     */
    ModelAndView handleRequest(
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception;
}</pre><p> As you can see, the <tt class="literal">Controller</tt> interface
    requires a single method that should be capable of handling a request and
    returning an appropriate model and view. These three concepts are the basis
    for the Spring MVC implementation - <span class="emphasis"><em>ModelAndView</em></span> and
    <span class="emphasis"><em>Controller</em></span>. While the <tt class="literal">Controller</tt>
    interface is quite abstract, Spring offers a lot of controllers that already
    contain a lot of the functionality you might need. The
    <tt class="literal">Controller</tt> interface just defines the most common
    functionality required of every controller - handling a request and
    returning a model and a view.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-abstractcontroller"></a>12.3.1.&nbsp;AbstractController and WebContentGenerator</h3></div></div><div></div></div><p>Of course, just a controller interface isn't enough. To provide a
      basic infrastructure, all of Spring's Controllers inherit from
      AbstractController, a class offering caching support and, for example,
      the setting of the mimetype.</p><div class="table"><a name="mvc-controller-abstract-features"></a><p class="title"><b>Table&nbsp;12.3.&nbsp;Features offered by the
        <tt class="literal">AbstractController</tt></b></p><table summary="Features offered by the&#xA;        AbstractController" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">supportedMethods</tt></td><td>indicates what methods this controller should accept.
              Usually this is set to both <tt class="literal">GET</tt> and
              <tt class="literal">POST</tt>, but you can modify this to reflect the
              method you want to support. If a request is received with a
              method that is not supported by the controller, the client will
              be informed of this (using a
              <tt class="literal">ServletException)</tt>).</td></tr><tr><td><tt class="literal">requiresSession</tt></td><td>indicates whether or not this controller requires a
              session to do its work. This feature is offered to all
              controllers. If a session is not present when such a controller
              receives a request, the user is informed using a
              <tt class="literal">ServletException</tt>.</td></tr><tr><td><tt class="literal">synchronizeSession</tt></td><td>use this if you want handling by this controller to be
              synchronized on the user's session. To be more specific,
              extending controller will override the
              <tt class="literal">handleRequestInternal</tt> method, which will be
              synchronized if you specify this variable.</td></tr><tr><td><tt class="literal">cacheSeconds</tt></td><td>when you want a controller to generate a caching directive
              in the HTTP response, specify a positive integer here. By
              default it is set to <span class="emphasis"><em>-1</em></span> so no caching
              directives will be included.</td></tr><tr><td><tt class="literal">useExpiresHeader</tt></td><td>tweaks your controllers to specify the HTTP 1.0
              compatible <span class="emphasis"><em>"Expires"</em></span> header. By default
              it's set to true, so you won't have to change it.</td></tr><tr><td><tt class="literal">useCacheHeader</tt></td><td>tweaks your controllers to specify the HTTP 1.1
              compatible <span class="emphasis"><em>"Cache-Control"</em></span> header. By
              default this is set to true so you won't have to change
              it.</td></tr></tbody></table></div><p><span class="emphasis"><em>The last two properties are actually part of the
      <tt class="literal">WebContentGenerator</tt> which is the superclass of
      <tt class="literal">AbstractController</tt> but are included here for
      completeness.</em></span></p><p>When using the AbstractController as a baseclass for your
      controllers (which is <span class="emphasis"><em>not</em></span> recommended since there
      are a lot of other controllers that might already do the job for you)
      you only have to override the
      <tt class="literal">handleRequestInternal(HttpServletRequest,
      HttpServletResponse)</tt> method, implement your logic, and
      return a <tt class="literal">ModelAndView</tt> object. Here is short example
      consisting of a class and a declaration in the web application context.
      </p><pre class="programlisting">package samples;

public class SampleController extends AbstractController {

    public ModelAndView handleRequestInternal(
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception {
        ModelAndView mav = new ModelAndView("foo", new HashMap());
    }
}</pre><p> </p><pre class="programlisting">&lt;bean id="sampleController" class="samples.SampleController"&gt;
    &lt;property name="cacheSeconds"&gt;&lt;value&gt;120&lt;/value&lt;/property&gt;
&lt;/bean&gt;</pre><p> The class above and the declaration in the
      web application context is all you need besides setting up a handler
      mapping (see <a href="#mvc-handlermapping" title="12.4.&nbsp;Handler mappings">Section&nbsp;12.4, &#8220;Handler mappings&#8221;</a>) to get this very
      simple controller working. This controller will generate caching
      directives telling the client to cache things for 2 minutes before
      rechecking. This controller returns an hard-coded view (hmm,
      not so nice), named index (see <a href="#mvc-viewresolver" title="12.5.&nbsp;Views and resolving them">Section&nbsp;12.5, &#8220;Views and resolving them&#8221;</a> for
      more information about views).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-othersimplecontrollers"></a>12.3.2.&nbsp;Other simple controllers</h3></div></div><div></div></div><p>Although you can extend AbstractController, Spring provides a number
      of concrete implementations which offer functionality that is commonly
      used in simple MVC applications. The
      <tt class="literal">ParameterizableViewController</tt> is basically the same
      as the example above, except for the fact that you can specify the view
      name that it will return in the web application context (ahhh, no need to
      hard-code the viewname).</p><p>The <tt class="literal">FileNameViewController</tt> inspects the URL and
      retrieves the filename of the file request (the filename of
      <tt class="literal">http://www.springframework.org/index.html</tt> is
      <tt class="literal">index</tt>) and uses that as a viewname. Nothing more to
      it.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-multiaction"></a>12.3.3.&nbsp;The <tt class="literal">MultiActionController</tt></h3></div></div><div></div></div><p>Spring offers a multi-action controller with which you aggregate
      multiple actions into one controller, grouping functionality together.
      The multi-action controller lives in a separate package -
      <tt class="literal">org.springframework.web.servlet.mvc.multiaction</tt> - and is
      capable of mapping requests to method names and then invoking the right
      method name. Using the multi-action controller is especially handy when
      you have a lot of common functionality in one controller, but want
      to have multiple entry points to the controller, for example, to tweak
      behavior.</p><div class="table"><a name="mvc-controller-multiaction-features"></a><p class="title"><b>Table&nbsp;12.4.&nbsp;Features offered by the
        <tt class="literal">MultiActionController</tt></b></p><table summary="Features offered by the&#xA;        MultiActionController" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">delegate</tt></td><td>there are two usage-scenarios for the
              MultiActionController. Either you subclass the
              MultiActionController and specify the methods that will be
              resolved by the MethodNameResolver on the subclass (in which case
              you don't need to set the delegate), or you define a
              delegate object, on which methods resolved by the Resolver will
              be invoked. If you choose this scenario, you will have
              to define the delegate using this configuration parameter as a
              collaborator.</td></tr><tr><td><tt class="literal">methodNameResolver</tt></td><td>somehow the MultiActionController will need to resolve
              the method it has to invoke, based on the request that came in.
              You can define a resolver that is capable of doing that using
              this configuration parameter.</td></tr></tbody></table></div><p>Methods defined for a multi-action controller need to conform
      to the following signature: </p><pre class="programlisting">// actionName can be replaced by any methodname
ModelAndView actionName(HttpServletRequest, HttpServletResponse);</pre><p>
      Method overloading is not allowed since it would confuse the
      MultiActionController. Furthermore, you can define <span class="emphasis"><em>exception
      handlers</em></span> capable of handling exceptions that are thrown
      by the methods you specify. Exception handler methods need to return a
      ModelAndView object, just as any other action method and need to
      conform to the following signature: </p><pre class="programlisting">// anyMeaningfulName can be replaced by any methodname
ModelAndView anyMeaningfulName(HttpServletRequest, HttpServletResponse, ExceptionClass);</pre><p>
      The <tt class="literal">ExceptionClass</tt> can be <span class="emphasis"><em>any</em></span>
      exception, as long as it's a subclass of
      <tt class="literal">java.lang.Exception</tt> or
      <tt class="literal">java.lang.RuntimeException</tt>.</p><p>The <tt class="literal">MethodNameResolver</tt> is supposed to resolve
      method names based on the request coming in. There are three resolvers at
      your disposal, but of course you can implement more of them yourself if
      you want to. </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">ParameterMethodNameResolver</tt> - capable of
            resolving a request parameter and using that as the method name
            (<tt class="literal">http://www.sf.net/index.view?testParam=testIt</tt>
            will result in a method <tt class="literal">testIt(HttpServletRequest,
            HttpServletResponse)</tt> being called). The
            <tt class="literal">paramName</tt> configuration parameter specifies the
            parameter that is inspected).</p></li><li><p><tt class="literal">InternalPathMethodNameResolver</tt> -
            retrieves the filename from the path and uses that as the method
            name (<tt class="literal">http://www.sf.net/testing.view</tt> will
            result in a method <tt class="literal">testing(HttpServletRequest,
            HttpServletResponse)</tt> being called).</p></li><li><p><tt class="literal">PropertiesMethodNameResolver</tt> - uses a
            user-defined properties object with request URLs mapped to
            methodnames. When the properties contain
            <tt class="literal">/index/welcome.html=doIt</tt> and a request to
            <tt class="literal">/index/welcome.html</tt> comes in, the
            <tt class="literal">doIt(HttpServletRequest, HttpServletResponse)</tt>
            method is called. This method name resolver works with the
            <tt class="literal">PathMatcher</tt> (see ???) so if the properties
            contained <tt class="literal">/**/welcom?.html</tt> it would also have
            worked!</p></li></ul></div><p>Here are a couple of examples. First, an example showing the
      <tt class="literal">ParameterMethodNameResolver</tt> and the delegate
      property, which will accept requests to urls with the parameter method
      included and set to <tt class="literal">retrieveIndex</tt>: </p><pre class="programlisting">&lt;bean id="paramResolver" class="org....mvc.multiaction.ParameterMethodNameResolver"&gt;
    &lt;property name="paramName"&gt;&lt;value&gt;method&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController"&gt;
    &lt;property name="methodNameResolver"&gt;&lt;ref bean="paramResolver"/&gt;&lt;/property&gt;
    &lt;property name="delegate"&gt;&lt;ref bean="sampleDelegate"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="sampleDelegate" class="samples.SampleDelegate"/&gt;

## together with

public class SampleDelegate {

    public ModelAndView retrieveIndex(
        HttpServletRequest req,
        HttpServletResponse resp) {

        return new ModelAndView("index", "date", new Long(System.currentTimeMillis()));
    }
}</pre><p> When using the delegates shown above, we could also use the
      <tt class="literal">PropertiesMethodNameResolver</tt> to match a couple of
      URLs to the method we defined: </p><pre class="programlisting">&lt;bean id="propsResolver" class="org....mvc.multiaction.PropertiesMethodNameResolver"&gt;
    &lt;property name="mappings"&gt;
        &lt;props&gt;
            &lt;prop key="/index/welcome.html"&gt;retrieveIndex&lt;/prop&gt;
            &lt;prop key="/**/notwelcome.html"&gt;retrieveIndex&lt;/prop&gt;
            &lt;prop key="/*/user?.html"&gt;retrieveIndex&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController"&gt;
    &lt;property name="methodNameResolver"&gt;&lt;ref bean="propsResolver"/&gt;&lt;/property&gt;
    &lt;property name="delegate"&gt;&lt;ref bean="sampleDelegate"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-command"></a>12.3.4.&nbsp;CommandControllers</h3></div></div><div></div></div><p>Spring's <span class="emphasis"><em>CommandControllers</em></span> are a fundamental
      part of the Spring MVC package. Command controllers provide a way to
      interact with data objects and dynamically bind parameters from the
      <tt class="literal">HttpServletRequest</tt> to the data object specified.
      They perform a similar role to Struts' ActionForm, but in Spring, your
      data objects don't have to implement a framework-specific interface.
      First, let's examine what command controllers available, to get
      overview of what you can do with them: </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">AbstractCommandController</tt> - a command
            controller you can use to create your own command controller,
            capable of binding request parameters to a data object you
            specify. This class does not offer form functionality, it does
            however, offer validation features and lets you specify in the
            controller itself what to do with the command object that has been
            filled with the parameters from the request.</p></li><li><p><tt class="literal">AbstractFormController</tt> - an abstract
            controller offering form submission support. Using this controller
            you can model forms and populate them using a command object you
            retrieve in the controller. After a user has filled the form,
            the AbstractFormController binds the fields, validates, and hands
            the object back to the controller to take appropriate
            action. Supported features are: invalid form submission
            (resubmission), validation, and normal form workflow. You implement
            methods to determine which views are used for form presentation and
            success. Use this controller if you need forms, but don't want to
            specify what views you're going to show the user in the
            application context.</p></li><li><p><tt class="literal">SimpleFormController</tt> - a concrete
            FormController that provides even more support when creating a form
            with a corresponding command object. The SimpleFormController
            let's you specify a command object, a viewname for the form, a
            viewname for page you want to show the user when form submission
            has succeeded, and more.</p></li><li><p><tt class="literal">AbstractWizardFormController</tt> - as the
            class name suggests, this is an abstract class--your
            WizardController should extend it. This means you have to
            implement the <tt class="literal">validatePage()</tt>,
            <tt class="literal">processFinish</tt> and
            <tt class="literal">processCancel</tt> methods.</p><p>You probably also want to write a contractor, which should
            at the very least call <tt class="literal">setPages()</tt> and
            <tt class="literal">setCommandName()</tt>. The former takes as its
            argument an array of type String. This array is the list of views
            which comprise your wizard. The latter takes as its argument a
            String, which will be used to refer to your command object from
            within your views.</p><p>As with any instance of AbstractFormController, you are
            required to use a command object - a JavaBean which will be
            populated with the data from your forms. You can do this in one of
            two ways: either call <tt class="literal">setCommandClass()</tt> from
            the constructor with the class of your command object, or
            implement the <tt class="literal">formBackingObject()</tt>
            method.</p><p>AbstractWizardFormController has a number of concrete
            methods that you may wish to override. Of these, the ones you are
            likely to find most useful are: <tt class="literal">referenceData</tt>
            which you can use to pass model data to your view in the form of a
            Map; <tt class="literal">getTargetPage</tt> if your wizard needs to
            change page order or omit pages dynamically; and
            <tt class="literal">onBindAndValidate</tt> if you want to override the
            built-in binding and validation workflow.</p><p>Finally, it is worth pointing out the
            <tt class="literal">setAllowDirtyBack</tt> and
            <tt class="literal">setAllowDirtyForward</tt>, which you can call from
            <tt class="literal">getTargetPage</tt> to allow users to move backwards
            and forwards in the wizard even if validation fails for the
            current page.</p><p>For a full list of methods, see the JavaDoc for
            AbstractWizardFormController. There is an implemented example of
            this wizard in the jPetStore included in the Spring distribution:
            org.springframework.samples.jpetstore.web.spring.OrderFormController</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-handlermapping"></a>12.4.&nbsp;Handler mappings</h2></div></div><div></div></div><p>Using a handler mapping you can map incoming web requests to
    appropriate handlers. There are some handler mappings you can use out of the
    box, for example, the <tt class="literal">SimpleUrlHandlerMapping</tt> or the
    <tt class="literal">BeanNameUrlHandlerMapping</tt>, but let's first examine the
    general concept of a <tt class="literal">HandlerMapping</tt>.</p><p>The functionality a basic <tt class="literal">HandlerMapping</tt> provides
    is the delivering of a <tt class="literal">HandlerExecutionChain</tt>, which must
    contain the handler that matches the incoming request, and may also contain
    a list of handler interceptors that are applied to the request. When a
    request comes in, the <tt class="literal">DispatcherServlet</tt> will hand it over
    to the handler mapping to let it inspect the request and come up with an
    appropriate HandlerExecutionChain. Then the DispatcherServlet will
    execute the handler and interceptors in the chain (if any).</p><p>The concept of configurable handler mappings that can optionally
    contain interceptors (executed before or after the actual handler was
    executed, or both) is extremely powerful. A lot of supporting
    functionality can be built into custom
    <tt class="literal">HandlerMapping</tt>s. Think of a custom handler mapping that
    chooses a handler not only based on the URL of the request coming in, but
    also on a specific state of the session associated with the
    request.</p><p>This section describes two of Spring's most commonly used handler mappings.
	They both extend the <tt class="literal">AbstractHandlerMapping</tt> and share the following
	properties:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">interceptors</tt>: the list of interceptors to use.
				<tt class="literal">HandlerInterceptor</tt>s are discussed in
				<a href="#mvc-handlermapping-interceptor" title="12.4.3.&nbsp;Adding HandlerInterceptors">Section&nbsp;12.4.3, &#8220;Adding HandlerInterceptors&#8221;</a>.</p></li><li><p><tt class="literal">defaultHandler</tt>: the default handler to use,
					when this handler mapping does not result in a matching handler.</p></li><li><p><tt class="literal">order</tt>: based on the value of the order property (see
					the <tt class="literal">org.springframework.core.Ordered</tt> interface),
					Spring will sort all handler mappings available in the context and
					apply the first matching handler.</p></li><li><p><tt class="literal">alwaysUseFullPath</tt>: if this property is set to
          <tt class="literal">true</tt>, Spring will use the full path within the
          current servlet context to find an appropriate handler. If this
          property is set to <tt class="literal">false</tt> (the default), the path
          within the current servlet mapping will be used. For example, if a
          servlet is mapped using <tt class="literal">/testing/*</tt> and the
          <tt class="literal">alwaysUseFullPath</tt> property is set to true,
          <tt class="literal">/testing/viewPage.html</tt> would be used, whereas if
          the property is set to false, <tt class="literal">/viewPage.html</tt> would
          be used.</p></li><li><p><tt class="literal">urlPathHelper</tt>: using this property, you can
				tweak the UrlPathHelper used when inspecting URLs. Normally,
        you shouldn't have to change the default value.</p></li><li><p><tt class="literal">urlDecode</tt>: the default value for this property
          is <tt class="literal">false</tt>. The <tt class="literal">HttpServletRequest</tt>
          returns request URLs and URIs that are <span class="emphasis"><em>not</em></span>
          decoded. If you do want them to be decoded before a
          <tt class="literal">HandlerMapping</tt> uses them to find an appropriate
          handler, you have to set this to <tt class="literal">true</tt> (note that
          this requires JDK 1.4). The decoding method uses either the encoding
          specified by the request or the default ISO-8859-1 encoding scheme.</p></li><li><p><tt class="literal">lazyInitHandlers</tt>: allows for lazy
          initialization of <span class="emphasis"><em>singleton</em></span> handlers (prototype
          handlers are always lazily initialized). Default value is
          <tt class="literal">false</tt>.</p></li></ul></div><p>
   (<span class="emphasis"><em>Note: the last four properties are only available to subclasses of
    <tt class="literal">org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</tt></em></span>).
	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-beanname"></a>12.4.1.&nbsp;<tt class="literal">BeanNameUrlHandlerMapping</tt></h3></div></div><div></div></div><p>A very simple, but very powerful handler mapping is the
      <tt class="literal">BeanNameUrlHandlerMapping</tt>, which maps incoming HTTP
      requests to names of beans, defined in the web application context. Let's
      say we want to enable a user to insert an account and we've already
      provided an appropriate FormController (see <a href="#mvc-controller-command" title="12.3.4.&nbsp;CommandControllers">Section&nbsp;12.3.4, &#8220;CommandControllers&#8221;</a> for more information on Command- and
      FormControllers) and a JSP view (or Velocity template) that renders the
      form. When using the BeanNameUrlHandlerMapping, we could map the HTTP
      request with URL <tt class="literal">http://samples.com/editaccount.form</tt>
      to the appropriate FormController as follows: </p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;

    &lt;bean name="/editaccount.form"
          class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
        &lt;property name="formView"&gt;&lt;value&gt;account&lt;/value&gt;&lt;/property&gt;
        &lt;property name="successView"&gt;&lt;value&gt;account-created&lt;/value&gt;&lt;/property&gt;
        &lt;property name="commandName"&gt;&lt;value&gt;Account&lt;/value&gt;&lt;/property&gt;
        &lt;property name="commandClass"&gt;&lt;value&gt;samples.Account&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;    </pre><p> All incoming requests for the URL
      <tt class="literal">/editaccount.form</tt> will now be handled by the
      FormController in the source listing above. Of course we have to define
      a servlet-mapping in web.xml as well, to let through all the requests
      ending with .form. </p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

   &lt;!-- Maps the sample dispatcher to /*.form --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre><p><span class="emphasis"><em>NOTE: if you want to use the
      <tt class="literal">BeanNameUrlHandlerMapping</tt>, you don't necessarily have
      to define it in the web application context (as indicated above). By
      default, if no handler mapping can be found in the context, the
      DispatcherServlet creates a <tt class="literal">BeanNameUrlHandlerMapping</tt>
      for you! </em></span></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-urlhandlermapping"></a>12.4.2.&nbsp;<tt class="literal">SimpleUrlHandlerMapping</tt></h3></div></div><div></div></div><p>A further - and much more powerful handler mapping - is the
      <tt class="literal">SimpleUrlHandlerMapping</tt>. This mapping is configurable
      in the application context and has Ant-style path matching capabilities
      (see the JavaDoc for
      <tt class="literal">org.springframework.util.PathMatcher</tt>). Here is an
      example: </p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!-- Maps the sample dispatcher to /*.form --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre><p> Allows all requests ending with .html and
      .form to be handled by the sample dispatcher servlet. </p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="/*/account.form"&gt;editAccountFormController&lt;/prop&gt;
                &lt;prop key="/*/editaccount.form"&gt;editAccountFormController&lt;/prop&gt;
                &lt;prop key="/ex/view*.html"&gt;someViewController&lt;/prop&gt;
                &lt;prop key="/**/help.html"&gt;helpController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="someViewController"
          class="org.springframework.web.servlet.mvc.UrlFilenameViewController"/&gt;

    &lt;bean id="editAccountFormController"
          class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
        &lt;property name="formView"&gt;&lt;value&gt;account&lt;/value&gt;&lt;/property&gt;
        &lt;property name="successView"&gt;&lt;value&gt;account-created&lt;/value&gt;&lt;/property&gt;
        &lt;property name="commandName"&gt;&lt;value&gt;Account&lt;/value&gt;&lt;/property&gt;
        &lt;property name="commandClass"&gt;&lt;value&gt;samples.Account&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;</pre><p> This handler mapping routes requests for
      <tt class="literal">help.html</tt> in any directory to the
      <tt class="literal">helpController</tt>, which is a
      UrlFilenameViewController (more about controllers can be found in <a href="#mvc-controller" title="12.3.&nbsp;Controllers">Section&nbsp;12.3, &#8220;Controllers&#8221;</a>). Requests for a resource beginning with
      <tt class="literal">view</tt>, and ending with <tt class="literal">.html</tt> in the
      directory <tt class="literal">ex</tt>, will be routed to the
      <tt class="literal">someViewController</tt>. Two further mappings are defined
      for <tt class="literal">editAccountFormController</tt>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-interceptor"></a>12.4.3.&nbsp;Adding <tt class="literal">HandlerInterceptors</tt></h3></div></div><div></div></div><p>Spring's handler mapping mechanism has a notion of handler
      interceptors, that can be extremely useful when you want to apply specific
      functionality to certain requests, for example, checking for a principal.</p><p>Interceptors located in the handler mapping must implement
      <tt class="literal">HandlerInterceptor</tt> from the
      <tt class="literal">org.springframework.web.servlet</tt> package. This
      interface defines three methods, one that will be called
      <span class="emphasis"><em>before</em></span> the actual handler will be executed, one
      that will be called <span class="emphasis"><em>after</em></span> the handler is executed,
      and one that is called <span class="emphasis"><em>after the complete request has
      finished</em></span>. These three methods should provide enough
      flexibility to do all kinds of pre- and post-processing.</p><p>The <tt class="literal">preHandle</tt> method returns a boolean value.
      You can use this method to break or continue the processing of the
      execution chain. When this method returns <tt class="literal">true</tt>, the
      handler execution chain will continue, when it returns false, the
      DispatcherServlet assumes the interceptor itself has taken care of
      requests (and, for example, rendered an appropriate view) and does not
      continue executing the other interceptors and the actual handler in the
      execution chain.</p><p>The following example provides an interceptor that intercepts all
      requests and reroutes the user to a specific page if the time is not
      between 9 a.m. and 6 p.m. </p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="interceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="officeHoursInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="/*.form"&gt;editAccountFormController&lt;/prop&gt;
                &lt;prop key="/*.view"&gt;editAccountFormController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="officeHoursInterceptor"
          class="samples.TimeBasedAccessInterceptor"&gt;
        &lt;property name="openingTime"&gt;&lt;value&gt;9&lt;/value&gt;&lt;/property&gt;
        &lt;property name="closingTime"&gt;&lt;value&gt;18&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;</pre><p> </p><pre class="programlisting">package samples;

public class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {

    private int openingTime;
    private int closingTime;
    public void setOpeningTime(int openingTime) {
        this.openingTime = openingTime;
    }
    public void setClosingTime(int closingTime) {
        this.closingTime = closingTime;
    }
    public boolean preHandle(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler)
    throws Exception {
        Calendar cal = Calendar.getInstance();
        int hour = cal.get(HOUR_OF_DAY);
        if (openingTime &lt;= hour &lt; closingTime) {
            return true;
        } else {
            response.sendRedirect("http://host.com/outsideOfficeHours.html");
            return false;
        }
    }
}</pre><p> Any request coming in, will be intercepted by the
      <tt class="literal">TimeBasedAccessInterceptor</tt>, and if the current time
      is outside office hours, the user will be redirected to a static html
      file, saying, for example, he can only access the website during office
      hours.</p><p>As you can see, Spring has an adapter to make it easy for you to
      extend the <tt class="literal">HandlerInterceptor</tt>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-viewresolver"></a>12.5.&nbsp;Views and resolving them</h2></div></div><div></div></div><p>All MVC frameworks for web applications provide a way to address
    views. Spring provides view resolvers, which enable you to render models
    in a browser without tying you to a specific view technology.
    Out of the box, Spring enables you to use Java Server Pages, Velocity
    templates and XSLT views, for example. <a href="#view" title="Chapter&nbsp;13.&nbsp;Integrating view technologies">Chapter&nbsp;13, <i>Integrating view technologies</i></a> has details
    of integrating various view technologies.</p><p>The two interfaces which are important to the way Spring handles views
    are <tt class="literal">ViewResolver</tt> and <tt class="literal">View</tt>. The
    <tt class="literal">ViewResolver</tt> provides a mapping between view names and
    actual views. The <tt class="literal">View</tt> interface addresses the
    preparation of the request and hands the request over to one of the view
    technologies.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-viewresolver-resolver"></a>12.5.1.&nbsp;ViewResolvers</h3></div></div><div></div></div><p>As discussed in <a href="#mvc-controller" title="12.3.&nbsp;Controllers">Section&nbsp;12.3, &#8220;Controllers&#8221;</a>, all
      controllers in the Spring web MVC framework, return a
      <tt class="literal">ModelAndView</tt> instance. Views in Spring are addressed by
      a view name and are resolved by a view resolver. Spring comes with quite
      a few view resolvers. We'll list most of them and then provide a couple
      of examples.</p><div class="table"><a name="d0e7456"></a><p class="title"><b>Table&nbsp;12.5.&nbsp;View resolvers</b></p><table summary="View resolvers" border="1"><colgroup><col><col></colgroup><thead><tr><th>ViewResolver</th><th>Description</th></tr></thead><tbody><tr><td>AbstractCachingViewResolver</td><td>An abstract view resolver which takes care of caching
              views. Often views need preparation before they can be used,
              extending this view resolver provides caching of views.</td></tr><tr><td>XmlViewResolver</td><td>An implementation of ViewResolver that accepts a
              configuration file written in XML with the same DTD as Spring's
              bean factories. The default configuration file is
              <tt class="literal">/WEB-INF/views.xml</tt>.</td></tr><tr><td>ResourceBundleViewResolver</td><td>An implementation of ViewResolver that uses bean
              definitions in a ResourceBundle, specified by the bundle basename.
              The bundle is typically defined in a properties file, located in
              the classpath. The default file name is
              <tt class="literal">views.properties</tt>.</td></tr><tr><td>UrlBasedViewResolver</td><td>A simple implementation of ViewResolver that allows for
              direct resolution of symbolic view names to URLs, without an
              explicit mapping definition. This is appropriate if your
              symbolic names match the names of your view resources in a
              straightforward manner, without the need for arbitrary
              mappings.</td></tr><tr><td>InternalResourceViewResolver</td><td>A convenience subclass of UrlBasedViewResolver that
              supports InternalResourceView (i.e. Servlets and JSPs), and
              subclasses like JstlView and TilesView. The view class for all
              views generated by this resolver can be specified via
              setViewClass. See UrlBasedViewResolver's javadocs for
              details.</td></tr><tr><td>VelocityViewResolver / FreeMarkerViewResolver</td><td>A convenience subclass of UrlBasedViewResolver that
              supports VelocityView (i.e. Velocity templates) or
              FreeMarkerView respectively and custom subclasses of
              them.</td></tr></tbody></table></div><p>As an example, when using JSP for a view technology you can use
      the <tt class="literal">UrlBasedViewResolver</tt>. This view resolver
      translates a view name to a URL and hands the request over the
      RequestDispatcher to render the view. </p><pre class="programlisting">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
    &lt;property name="prefix"&gt;&lt;value&gt;/WEB-INF/jsp/&lt;/value&gt;&lt;/property&gt;
    &lt;property name="suffix"&gt;&lt;value&gt;.jsp&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p> When returning <tt class="literal">test</tt> as a
      viewname, this view resolver will hand the request over to the
      RequestDispatcher that will send the request to
      <tt class="literal">/WEB-INF/jsp/test.jsp</tt>.</p><p>When mixing different view technologies in a web application, you
      can use the ResourceBundleViewResolver: </p><pre class="programlisting">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename"&gt;&lt;value&gt;views&lt;/value&gt;&lt;/property&gt;
    &lt;property name="defaultParentView"&gt;&lt;value&gt;parentView&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The ResourceBundleViewResolver inspects the ResourceBundle
      identified by the basename, and for each view it is supposed to resolve,
      it uses the value of the property <tt class="literal">[viewname].class</tt> as
      the view class and the value of the property
      <tt class="literal">[viewname].url</tt> as the view url. As you can see, you
      can identify a parent view, from which all views in the properties file
      sort of extend. This way you can specify a default view class, for
      example.</p><p><span class="emphasis"><em>A note on caching</em></span> - subclasses of
      <tt class="literal">AbstractCachingViewResolver</tt> cache view instances
      they have resolved. This greatly improves performance when using certain
      view technology. It's possible to turn off the cache, by setting the
      <tt class="literal">cache</tt> property to false. Furthermore, if you have the
      requirement to be able to refresh a certain view at runtime (for example
      when a Velocity template has been modified), you can use the
      <tt class="literal">removeFromCache(String viewName, Locale loc)</tt>
      method.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-viewresolver-chaining"></a>12.5.2.&nbsp;Chaining ViewResolvers</h3></div></div><div></div></div><p>Spring supports more than just one view resolver. This allows you to
      chain resolvers and, for example, override specific views in certain
      circumstances. Chaining view resolvers is pretty straightforward - just
      add more than one resolver to your application context and, if necessary,
      set the <tt class="literal">order</tt> property to specify an order. Remember,
      the higher the order property, the later the view resolver will be
      positioned in the chain.</p><p>In the following example, the chain of view resolvers consists of two
      resolvers, a <tt class="literal">InternalResourceViewResolver</tt> (positioned
      as the second and last resolver in the chain) and an
      <tt class="literal">XmlViewResolver</tt> for specifying Excel
      views (which are not supported by the InternalResourceViewResolver):
		</p><pre class="programlisting">
&lt;bean id="jspViewResolver"
		class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
	&lt;property name="order"&gt;&lt;value&gt;2&lt;/value&gt;&lt;/property&gt;
	&lt;property name="viewClass"&gt;
		&lt;value&gt;org.springframework.web.servlet.view.JstlView&lt;/value&gt;
	&lt;/property&gt;
	&lt;property name="prefix"&gt;&lt;value&gt;/WEB-INF/jsp/&lt;/value&gt;&lt;/property&gt;
	&lt;property name="suffix"&gt;&lt;value&gt;.jsp&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="excelViewResolver"&gt;
		class="org.springframework.web.servlet.view.XmlViewResolver"&gt;
	&lt;property name="order"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;
	&lt;property name="location"&gt;&lt;value&gt;/WEB-INF/views.xml&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

### views.xml

&lt;beans&gt;
	&lt;bean name="report" class="org.springframework.example.ReportExcelView"/&gt;
&lt;/beans&gt;
</pre><p>
		</p><p>If a specific view resolver does not result in a view, Spring will
			inspect the context to see if other view resolvers are configured. If
      there are additional view resolvers, it will continue to inspect them. If
      not, it will throw an Exception.</p><p>You have to keep something else in mind - the contract of a view
      resolver mentions that a view resolver <span class="emphasis"><em>can</em></span> return
      null to indicate the view could not be found. Not all view resolvers do
      this however! This is because in some cases, the resolver simply cannot
      detect whether or not the view exists. For example, the
      <tt class="literal">InternalResourceViewResolver</tt> uses the RequestDispatcher
			internally, and dispatching is the only way to figure out if a JSP exists
      -this can only be done once. The same holds for the VelocityViewResolver
      and some others. Check the JavaDoc for the view resolver to see if
      you're dealing with a view resolver that does not report non-existing
      views. As a result of this, putting an
      <tt class="literal">InternalResourceViewResolver</tt> in the chain in a place
      other than the last, will result in the chain not being fully inspected,
      since the <tt class="literal">InternalResourceViewResolver</tt> will
      <span class="emphasis"><em>always</em></span> return a view!</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-localeresolver"></a>12.6.&nbsp;Using locales</h2></div></div><div></div></div><p>Most parts of Spring's architecture support internationalization, just
    as the Spring web MVC framework does. DispatcherServlet enables you to
    automatically resolve messages using the client's locale. This is done with
    <tt class="literal">LocaleResolver</tt> objects.</p><p>When a request comes in, the DispatcherServlet looks for a locale
    resolver and if it finds one it tries to use it to set the locale. Using
    the <tt class="literal">RequestContext.getLocale()</tt> method, you can always
    retrieve the locale that was resolved by the locale resolver.</p><p>Besides the automatic locale resolution, you can also attach an
    interceptor to the handler mapping (see <a href="#mvc-handlermapping-interceptor" title="12.4.3.&nbsp;Adding HandlerInterceptors">Section&nbsp;12.4.3, &#8220;Adding HandlerInterceptors&#8221;</a> for more information on handler
    mapping interceptors), to change the locale under specific circumstances,
    based on a parameter in the request, for example.</p><p>Locale resolvers and interceptors are all defined in the
    <tt class="literal">org.springframework.web.servlet.i18n</tt> package, and are
    configured in your application context in the normal way. Here is a
    selection of the locale resolvers included in Spring.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-acceptheader"></a>12.6.1.&nbsp;<tt class="literal">AcceptHeaderLocaleResolver</tt></h3></div></div><div></div></div><p>This locale resolver inspects the
      <tt class="literal">accept-language</tt> header in the request that was sent
      by the browser of the client. Usually this header field contains the
      locale of the client's operating system.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-cookie"></a>12.6.2.&nbsp;<tt class="literal">CookieLocaleResolver</tt></h3></div></div><div></div></div><p>This locale resolver inspects a Cookie that might exist on the
      client, to see if a locale is specified. If so, it uses that
      specific locale. Using the properties of this locale resolver, you can
      specify the name of the cookie, as well as the maximum age.
      </p><pre class="programlisting">&lt;bean id="localeResolver"&gt;
    &lt;property name="cookieName"&gt;&lt;value&gt;clientlanguage&lt;/value&gt;&lt;/property&gt;
    &lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;
    &lt;property name="cookieMaxAge"&gt;&lt;value&gt;100000&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p> This is an example of defining a
      CookieLocaleResolver.</p><div class="table"><a name="d0e7622"></a><p class="title"><b>Table&nbsp;12.6.&nbsp;Special beans in the WebApplicationContext</b></p><table summary="Special beans in the WebApplicationContext" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>cookieName</td><td>classname + LOCALE</td><td>The name of the cookie</td></tr><tr><td>cookieMaxAge</td><td>Integer.MAX_INT</td><td>The maximum time a cookie will stay persistent on the
              client. If -1 is specified, the cookie will not be persisted. It
              will only be available until the client shuts down his or her
              browser.</td></tr><tr><td>cookiePath</td><td>/</td><td>Using this parameter, you can limit the visibility of the
              cookie to a certain part of your site. When cookiePath is
              specified, the cookie will only be visible to that path, and the
              paths below it.</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-session"></a>12.6.3.&nbsp;<tt class="literal">SessionLocaleResolver</tt></h3></div></div><div></div></div><p>The <tt class="literal">SessionLocaleResolver</tt> allows you to
      retrieve locales from the session that might be associated with the user's
      request.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-interceptor"></a>12.6.4.&nbsp;<tt class="literal">LocaleChangeInterceptor</tt></h3></div></div><div></div></div><p>You can build in changing of locales using the
      <tt class="literal">LocaleChangeInterceptor</tt>. This interceptor needs to be
      added to one of the handler mappings (see <a href="#mvc-handlermapping" title="12.4.&nbsp;Handler mappings">Section&nbsp;12.4, &#8220;Handler mappings&#8221;</a>). It will detect a parameter in the
      request and change the locale (it calls <tt class="literal">setLocale()</tt>
      on the LocaleResolver that also exists in the context). </p><pre class="programlisting">&lt;bean id="localeChangeInterceptor"
      class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
    &lt;property name="paramName"&gt;&lt;value&gt;siteLanguage&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="localeResolver"
      class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/&gt;

&lt;bean id="urlMapping"
      class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
    &lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref local="localeChangeInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="mappings"&gt;
        &lt;props&gt;
            &lt;prop key="/**/*.view"&gt;someController&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p> All calls to all *.view resources containing a
      parameter named <tt class="literal">siteLanguage</tt> will now change the
      locale. So a call to
      <tt class="literal">http://www.sf.net/home.view?siteLanguage=nl</tt> will
      change the site language to Dutch.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-themeresolver"></a>12.7.&nbsp;Using themes</h2></div></div><div></div></div><p>Dummy paragraph</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-multipart"></a>12.8.&nbsp;Spring's multipart (fileupload) support</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-introduction"></a>12.8.1.&nbsp;Introduction</h3></div></div><div></div></div><p>Spring has built-in multipart support to handle fileuploads in
      web applications. The design for the multipart support is done with
      pluggable <tt class="literal">MultipartResovler</tt> objects, defined in the
      <tt class="literal">org.springframework.web.multipart</tt> package. Out of the
      box, Spring provides <tt class="literal">MultipartResolver</tt>s for use with
      <span class="emphasis"><em>Commons FileUpload</em></span> (<a href="http://jakarta.apache.org/commons/fileupload" target="_top">http://jakarta.apache.org/commons/fileupload</a>) and
      <span class="emphasis"><em>COS FileUpload</em></span> (<a href="http://www.servlets.com/cos" target="_top">http://www.servlets.com/cos</a>). How uploading files is
      supported will be described in the rest of this chapter.</p><p>By default, no multipart handling will be done by Spring, as some
      developers will want to handle multiparts themselves. You will have to
      enable it yourself by adding a multipart resolver to the web application's
      context. After you have done that, each request will be inspected to see
      if it contains a multipart. If no multipart is found, the request will
      continue as expected. However, if a multipart is found in the request, the
      MultipartResolver that has been declared in your context will be used.
      After that, the multipart attribute in your request will be treated like
      any other attribute.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-resolver"></a>12.8.2.&nbsp;Using the <tt class="literal">MultipartResolver</tt></h3></div></div><div></div></div><p>The following example shows how to use the
      <tt class="literal">CommonsMultipartResolver</tt>: </p><pre class="programlisting">&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;

    &lt;!-- one of the properties available; the maximum file size in bytes --&gt;
    &lt;property name="maxUploadSize"&gt;
        &lt;value&gt;100000&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p> This is an example using the
      <tt class="literal">CosMultipartResolver</tt>: </p><pre class="programlisting">&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.cos.CosMultipartResolver"&gt;

    &lt;!-- one of the properties available; the maximum file size in bytes --&gt;
    &lt;property name="maxUploadSize"&gt;
        &lt;value&gt;100000&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Of course you need to stick the appropriate jars in your classpath
      for the multipart resolver to work. In the case of the
      CommonsMultipartResolver, you need to use
      <tt class="literal">commons-fileupload.jar</tt>, while in the case of the
      CosMultipartResolver, use <tt class="literal">cos.jar</tt>.</p><p>Now that you have seen how to set Spring up to handle multipart
      requests, let's talk about how to actually use it. When the Spring
      DispatcherServlet detects a Multipart request, it activates the resolver
      that has been declared in your context and hands over the request. What
      it basically does is wrap the current
      <tt class="literal">HttpServletRequest</tt> into a
      <tt class="literal">MultipartHttpServletRequest</tt> that has support for
      multiparts. Using the MultipartHttpServletRequest you can get
      information about the multiparts contained by this request and actually
      get the multiparts themselves in your controllers.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-forms"></a>12.8.3.&nbsp;Handling a fileupload in a form</h3></div></div><div></div></div><p>After the MultipartResolver has finished doing its job, the
      request will be processed like any other. To use it, you create a form
      with an upload field, then let Spring bind the file on your form. Just
      as with any other property that's not automagically convertible to a
      String or primitive type, to be able to put binary data in your beans
      you have to register a custom editor with the
      <tt class="literal">ServletRequestDatabinder</tt>. There are a couple of
      editors available for handling files and setting the results on a bean.
      There's a <tt class="literal">StringMultipartEditor</tt> capable of converting
      files to Strings (using a user-defined character set) and there is a
      <tt class="literal">ByteArrayMultipartEditor</tt> which converts files to byte
      arrays. They function just as the <tt class="literal">CustomDateEditor</tt>
      does.</p><p>So, to be able to upload files using a form in a website, declare
      the resolver, a url mapping to a controller that will process the bean,
      and the controller itself. </p><pre class="programlisting">&lt;beans&gt;

    ...

    &lt;bean id="multipartResolver"
        class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/&gt;

    &lt;bean id="urlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="/upload.form"&gt;fileUploadController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="fileUploadController" class="examples.FileUploadController"&gt;
        &lt;property name="commandClass"&gt;&lt;value&gt;examples.FileUploadBean&lt;/value&gt;&lt;/property&gt;
        &lt;property name="formView"&gt;&lt;value&gt;fileuploadform&lt;/value&gt;&lt;/property&gt;
        &lt;property name="successView"&gt;&lt;value&gt;confirmation&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>After that, create the controller and the actual bean to hold the
      file property </p><pre class="programlisting">// snippet from FileUploadController
public class FileUploadController extends SimpleFormController {

    protected ModelAndView onSubmit(
        HttpServletRequest request,
        HttpServletResponse response,
        Object command,
        BindException errors)
        throws ServletException, IOException {

        // cast the bean
        FileUploadBean bean = (FileUploadBean)command;

        // let's see if there's content there
        byte[] file = bean.getFile();
        if (file == null) {
            // hmm, that's strange, the user did not upload anything
        }

        // well, let's do nothing with the bean for now and return:
        return super.onSubmit(request, response, command, errors);
    }

    protected void initBinder(
        HttpServletRequest request,
        ServletRequestDataBinder binder)
        throws ServletException {
        // to actually be able to convert Multipart instance to byte[]
        // we have to register a custom editor (in this case the
        // ByteArrayMultipartEditor
        binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());
        // now Spring knows how to handle multipart object and convert them
    }

}

// snippet from FileUploadBean
public class FileUploadBean {
    private byte[] file;

    public void setFile(byte[] file) {
        this.file = file;
    }

    public byte[] getFile() {
        return file;
    }
}</pre><p> As you can see, the FileUploadBean has a property typed
      byte[] that holds the file. The controller registers a custom editor to
      let Spring know how to actually convert the multipart objects the
      resolver has found to properties specified by the bean. In these
      examples, nothing is done with the byte[] property of the bean itself,
      but in practice you can do whatever you want (save it in a database,
      mail it to somebody, etc).</p><p>But we're still not finished. To actually let the user upload
      something, we have to create a form: </p><pre class="programlisting">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Upload a file please&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Please upload a file&lt;/h1&gt;
        &lt;form method="post" action="upload.form" enctype="multipart/form-data"&gt;
            &lt;input type="file" name="file"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p> As you can see, we've created a field named
      after the property of the bean that holds the byte[]. Furthermore we've
      added the encoding attribute which is necessary to let the browser know
      how to encode the multipart fields (do not forget this!). Now
      everything should work.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-exceptionhandlers"></a>12.9.&nbsp;Handling exceptions</h2></div></div><div></div></div><p>Spring provides <tt class="literal">HandlerExceptionResolvers</tt> to ease
    the pain of unexpected exceptions occurring while your request is being
    handled by a controller which matched the request.
    <tt class="literal">HandlerExceptionResolvers</tt> somewhat resemble the
    exception mappings you can define in the web application descriptor
    <tt class="literal">web.xml</tt>. However, they provide a more flexible way to
    handle exceptions. They provide information about what handler was
    executing when the exception was thrown. Furthermore, a programmatic way
    of handling exception gives you many more options for how to respond
    appropriately before the request is forwarded to another URL (the same
    end result as when using the servlet specific exception mappings).</p><p>Besides implementing the
    <tt class="literal">HandlerExceptionResolver</tt>, which is only a matter of
    implementing the <tt class="literal">resolveException(Exception, Handler)</tt>
    method and returning a <tt class="literal">ModelAndView</tt>, you may also use
    the <tt class="literal">SimpleMappingExceptionResolver</tt>. This resolver
    enables you to take the class name of any exception that might be thrown
    and map it to a view name. This is functionally equivalent to the
    exception mapping feature from the Servlet API, but it's also possible to
    implement more fine grained mappings of exceptions from different
    handlers.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="view"></a>Chapter&nbsp;13.&nbsp;Integrating view technologies</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-introduction"></a>13.1.&nbsp;Introduction</h2></div></div><div></div></div><p>One of the areas in which Spring excels is in the separation of view
    technologies from the rest of the MVC framework. For example, deciding to
    use Velocity or XSLT in place of an existing JSP is primarily a matter of
    configuration. This chapter covers the major view technologies that work
    with Spring and touches briefly on how to add new ones. This chapter
    assumes you are already familiar with <a href="#mvc-viewresolver" title="12.5.&nbsp;Views and resolving them">Section&nbsp;12.5, &#8220;Views and resolving them&#8221;</a>
    which covers the basics of how views in general are coupled to the MVC
    framework.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-jsp"></a>13.2.&nbsp;JSP &amp; JSTL</h2></div></div><div></div></div><p>Spring provides a couple of out-of-the-box solutions for JSP and
    JSTL views. Using JSP or JSTL is done using a normal viewresolver defined
    in the WebApplicationContext. Furthermore, of course you need to write
    some JSPs that will actually render the view. This part describes some of
    the additional features Spring provides to facilitate JSP
    development.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-resolver"></a>13.2.1.&nbsp;View resolvers</h3></div></div><div></div></div><p>Just as with any other view technology you're integrating with
      Spring, for JSPs you'll need a view resolver that will resolve your
      views. The most commonly used view resolvers when developing with JSPs
      are the <tt class="literal">InternalResourceViewResolver</tt> and the
      <tt class="literal">ResourceBundleViewResolver</tt>. Both are declared in the
      WebApplicationContext:</p><pre class="programlisting"># The ResourceBundleViewResolver:
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename"&gt;&lt;value&gt;views&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

# And a sample properties file is uses (views.properties in WEB-INF/classes):
welcome.class=org.springframework.web.servlet.view.JstlView
welcome.url=/WEB-INF/jsp/welcome.jsp

productList.class=org.springframework.web.servlet.view.JstlView
productList.url=/WEB-INF/jsp/productlist.jsp</pre><p>As you can see, the ResourceBundleViewResolver needs a properties
      file defining the view names mapped to 1) a class and 2) a URL. With a
      ResourceBundleViewResolver you can mix different types of views using
      only one resolver.</p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
    &lt;property name="viewClass"&gt;&lt;value&gt;org.springframework.web.servlet.view.JstlView&lt;/value&gt;&lt;/property&gt;
    &lt;property name="prefix"&gt;&lt;value&gt;/WEB-INF/jsp/&lt;/value&gt;&lt;/property&gt;
    &lt;property name="suffix"&gt;&lt;value&gt;.jsp&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The InternalResourceBundleViewResolver can be configured for using
      JSPs as described above. As a best practice, we strongly encourage
      placing your JSP files in a a directory under the WEB-INF directory, so
      there can be no direct access by clients.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-jstl"></a>13.2.2.&nbsp;'Plain-old' JSPs versus JSTL</h3></div></div><div></div></div><p>When using Java Standard Tag Library you must use a special view
      class, the <tt class="literal">JstlView</tt>, as JSTL needs some preparation
      before things such as the i18N features will work.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-tags"></a>13.2.3.&nbsp;Additional tags facilitating development</h3></div></div><div></div></div><p>Spring provides data binding of request parameters to command
      objects as described in earlier chapters. To facilitate the development
      of JSP pages in combination with those data binding features, Spring
      provides a few tags that make things even easier. All Spring tags have
      <span class="emphasis"><em>html escaping</em></span> features to enable or disable
      escaping of characters.</p><p>The tag library descriptor (TLD) is included in the
      <tt class="literal">spring.jar</tt> as well in the distribution itself. More
      information about the individual tags can be found online: <a href="http://www.springframework.org/docs/taglib/index.html" target="_top">http://www.springframework.org/docs/taglib/index.html</a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-tiles"></a>13.3.&nbsp;Tiles</h2></div></div><div></div></div><p>It is possible to integrate Tiles - just as any other view
    technology - in web applications using Spring. The following describes in
    a broad way how to do this.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tiles-dependencies"></a>13.3.1.&nbsp;Dependencies</h3></div></div><div></div></div><p>To be able to use Tiles you have to have a couple of additional
      dependencies included in your project. The following is the list of
      dependencies you need.</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">struts version 1.1</tt></p></li><li><p><tt class="literal">commons-beanutils</tt></p></li><li><p><tt class="literal">commons-digester</tt></p></li><li><p><tt class="literal">commons-logging</tt></p></li><li><p><tt class="literal">commons-lang</tt></p></li></ul></div><p>The dependencies are all available in the Spring
      distribution.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tiles-integrate"></a>13.3.2.&nbsp;How to integrate Tiles</h3></div></div><div></div></div><p>To be able to use Tiles, you have to configure it using files
      containing definitions (for basic information on definitions and other
      Tiles concepts, please have a look at <a href="http://jakarta.apache.org/struts" target="_top">http://jakarta.apache.org/struts</a>). In Spring this is done
      using the <tt class="literal">TilesConfigurer</tt>. Have a look at the
      following piece of example ApplicationContext configuration:
      </p><pre class="programlisting">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles.TilesConfigurer"&gt;
    &lt;property name="factoryClass"&gt;
        &lt;value&gt;org.apache.struts.tiles.xmlDefinition.I18nFactorySet&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="definitions"&gt;
        &lt;list&gt;
            &lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>As you can see, there are five files containing definitions, which
      are all located in the WEB-INF/defs directory. At initialization of the
      WebApplicationContext, the files will be loaded and the
      definitionsfactory defined by the
      <tt class="literal">factoryClass</tt>-property is initialized. After that has
      been done, the tiles includes in the definition files can be used as
      views within your Spring web application. To be able to use the views
      you have to have a <tt class="literal">ViewResolver</tt> just as with any
      other view technology used with Spring. Below you can find two
      possibilities, the <tt class="literal">InternalResourceViewResolver</tt> and
      the <tt class="literal">ResourceBundleViewResolver</tt>.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tiles-internal"></a>13.3.2.1.&nbsp;<tt class="literal">InternalResourceViewResolver</tt></h4></div></div><div></div></div><p>The InternalResourceViewResolver instantiates the given
        <tt class="literal">viewClass</tt> for each view it has to resolve.
        </p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
    &lt;property name="requestContextAttribute"&gt;&lt;value&gt;requestContext&lt;/value&gt;&lt;/property&gt;
    &lt;property name="viewClass"&gt;
        &lt;value&gt;org.springframework.web.servlet.view.tiles.TilesView&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tiles-resource"></a>13.3.2.2.&nbsp;<tt class="literal">ResourceBundleViewResolver</tt></h4></div></div><div></div></div><p>The ResourceBundleViewResolver has to be provided with a
        property file containing viewnames and viewclasses the resolver can
        use: </p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename"&gt;&lt;value&gt;views&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><pre class="programlisting">    ...
    welcomeView.class=org.springframework.web.servlet.view.tiles.TilesView
    welcomeView.url=welcome (&lt;b&gt;this is the name of a definition&lt;/b&gt;)
        
    vetsView.class=org.springframework.web.servlet.view.tiles.TilesView
    vetsView.url=vetsView (&lt;b&gt;again, this is the name of a definition&lt;/b&gt;)
        
    findOwnersForm.class=org.springframework.web.servlet.view.JstlView
    findOwnersForm.url=/WEB-INF/jsp/findOwners.jsp
    ...</pre><p> As you can see, when using the
        ResourceBundleViewResolver, you can mix view using different view
        technologies.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-velocity"></a>13.4.&nbsp;Velocity &amp; FreeMarker</h2></div></div><div></div></div><p><a href="http://jakarta.apache.org/velocity" target="_top">Velocity</a> and
    <a href="http://www.freemarker.org" target="_top">FreeMarker</a> are two
    templating languages that can both be used as view technologies within
    Spring MVC applications. The languages are quite similar and serve similar
    needs and so are considered together in this section. For semantic and
    syntactic differences between the two languages, see the <a href="http://www.freemarker.org" target="_top">FreeMarker</a> web site.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-dependencies"></a>13.4.1.&nbsp;Dependencies</h3></div></div><div></div></div><p>Your web application will need to include
      <tt class="literal">velocity-1.x.x.jar</tt> or
      <tt class="literal">freemarker-2.x.jar</tt> in order to work with Velocity or
      FreeMarker respectively and <tt class="literal">commons-collections.jar</tt>
      needs also to be available for Velocity. Typically they are included in
      the <tt class="literal">WEB-INF/lib</tt> folder where they are guaranteed to
      be found by a J2EE server and added to the classpath for your
      application. It is of course assumed that you already have the
      <tt class="literal">spring.jar</tt> in your <tt class="literal">WEB-INF/lib</tt>
      folder too! The latest stable velocity, freemarker and commons
      collections jars are supplied with the Spring framework and can be
      copied from the relevant <tt class="literal">/lib/</tt> sub-directories. If
      you make use of Spring's dateToolAttribute or numberToolAttribute in
      your Velocity views, you will also need to include the
      <tt class="literal">velocity-tools-generic-1.x.jar</tt></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-contextconfig"></a>13.4.2.&nbsp;Context configuration</h3></div></div><div></div></div><p>A suitable configuration is initialized by adding the relevant
      configurer bean definition to your *-servlet.xml as shown below:</p><pre class="programlisting">&lt;!--
  This bean sets up the Velocity environment for us based on a root path for templates.
  Optionally, a properties file can be specified for more control over the Velocity
  environment, but the defaults are pretty sane for file based template loading.
--&gt;
&lt;bean 
  id="velocityConfig" 
  class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
  &lt;property name="resourceLoaderPath"&gt;&lt;value&gt;/WEB-INF/velocity/&lt;/value&gt;&lt;/property&gt;          
&lt;/bean&gt;

&lt;!--
  View resolvers can also be configured with ResourceBundles or XML files.  If you need
  different view resolving based on Locale, you have to use the resource bundle resolver.
--&gt;
&lt;bean 
  id="viewResolver" 
  class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt;
  &lt;property name="cache"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
  &lt;property name="prefix"&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
  &lt;property name="suffix"&gt;&lt;value&gt;.vm&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><pre class="programlisting">&lt;!-- freemarker config --&gt;
&lt;bean 
  id="freemarkerConfig" 
  class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
  &lt;property name="templateLoaderPath"&gt;&lt;value&gt;/WEB-INF/freemarker/&lt;/value&gt;&lt;/property&gt; 
&lt;/bean&gt;

&lt;!--
  View resolvers can also be configured with ResourceBundles or XML files.  If you need
  different view resolving based on Locale, you have to use the resource bundle resolver.
--&gt;
&lt;bean 
  id="viewResolver" 
  class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt;
  &lt;property name="cache"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
  &lt;property name="prefix"&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
  &lt;property name="suffix"&gt;&lt;value&gt;.ftl&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>NB: For non web-apps add a
      <tt class="literal">VelocityConfigurationFactoryBean</tt> or a
      <tt class="literal">FreeMarkerConfigurationFactoryBean</tt> to your
      application context definition file.</em></span></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-createtemplates"></a>13.4.3.&nbsp;Creating templates</h3></div></div><div></div></div><p>Your templates need to be stored in the directory specified by the
      <tt class="literal">*Configurer</tt> bean shown above in <a href="#view-velocity-contextconfig" title="13.4.2.&nbsp;Context configuration">Section&nbsp;13.4.2, &#8220;Context configuration&#8221;</a> This document does not cover
      details of creating templates for the two languages - please see their
      relevant websites for information. If you use the view resolvers
      highlighted, then the logical view names relate to the template file
      names in similar fashion to
      <tt class="literal">InternalResourceViewResolver</tt> for JSP's. So if your
      controller returns a ModelAndView object containing a view name of
      "welcome" then the resolvers will look for the
      <tt class="literal">/WEB-INF/freemarker/welcome.ftl</tt> or
      <tt class="literal">/WEB-INF/velocity/welcome.vm</tt> template as
      appropriate.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-advancedconfig"></a>13.4.4.&nbsp;Advanced configuration</h3></div></div><div></div></div><p>The basic configurations highlighted above will be suitable for
      most application requirements, however additional configuration options
      are available for when unusual or advanced requirements dictate.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-velocity-example-velocityproperties"></a>13.4.4.1.&nbsp;velocity.properties</h4></div></div><div></div></div><p>This file is completely optional, but if specified, contains the
        values that are passed to the Velocity runtime in order to configure
        velocity itself. Only required for advanced configurations, if you
        need this file, specify its location on the
        <tt class="literal">VelocityConfigurer</tt> bean definition above.</p><pre class="programlisting">&lt;bean 
  id="velocityConfig" 
  class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
  &lt;property name="configLocation"&gt;
    &lt;value&gt;/WEB-INF/velocity.properties&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Alternatively, you can specify velocity properties directly in
        the bean definition for the Velocity config bean by replacing the
        "configLocation" property with the following inline properties.</p><pre class="programlisting">&lt;bean 
  id="velocityConfig" 
  class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
  &lt;property name="velocityProperties"&gt;
    &lt;props&gt;
      &lt;prop key="resource.loader"&gt;file&lt;/prop&gt;
      &lt;prop key="file.resource.loader.class"&gt;
        org.apache.velocity.runtime.resource.loader.FileResourceLoader
      &lt;/prop&gt;
      &lt;prop key="file.resource.loader.path"&gt;${webapp.root}/WEB-INF/velocity&lt;/prop&gt;
      &lt;prop key="file.resource.loader.cache"&gt;false&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Refer to the <a href="http://www.springframework.org/docs/api/org/springframework/ui/velocity/VelocityEngineFactory.html" target="_top">API
        documentation</a> for Spring configuration of Velocity, or the
        Velocity documentation for examples and definitions of the
        <tt class="literal">velocity.properties</tt> file itself.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8065"></a>13.4.4.2.&nbsp;FreeMarker</h4></div></div><div></div></div><p>FreeMarker 'Settings' and 'SharedVariables' can be passed
        directly to the FreeMarker <tt class="literal">Configuration</tt> object
        managed by Spring by setting the appropriate bean properties on the
        <tt class="literal">FreeMarkerConfigurer</tt> bean. The
        <tt class="literal">freemarkerSettings</tt> property requires a
        <tt class="literal">java.util.Properties</tt> object and the
        <tt class="literal">freemarkerVariables</tt> property requires a
        <tt class="literal">java.util.Map</tt>.</p><pre class="programlisting">&lt;bean 
  id="freemarkerConfig" 
  class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
  &lt;property name="templateLoaderPath"&gt;&lt;value&gt;/WEB-INF/freemarker/&lt;/value&gt;&lt;/property&gt; 
  &lt;property name="freemarkerVariables"&gt;
    &lt;map&gt;
      &lt;entry key="xml_escape"&gt;&lt;ref local="fmXmlEscape"/&gt;&lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/&gt;</pre><p>See the FreeMarker documentation for details of settings and
        variables as they apply to the <tt class="literal">Configuration</tt>
        object.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-forms"></a>13.4.5.&nbsp;Bind support and form handling</h3></div></div><div></div></div><p>Spring provides a tag library for use in JSP's that contains
      (amongst other things) a <tt class="literal">&lt;spring:bind&gt;</tt> tag.
      This tag primarily enables forms to display values from form backing
      objects and to show the results of failed validations from a
      <tt class="literal">Validator</tt> in the web or business tier. From version
      1.1, Spring now has support for the same functionality in both Velocity
      and FreeMarker, with additional convenience macros for generating form
      input elements themselves.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-velocity-validation"></a>13.4.5.1.&nbsp;the bind macros</h4></div></div><div></div></div><p>A standard set of macros are maintained within the
        <tt class="literal">spring.jar</tt> file for both languages, so they are
        always available to a suitably configured application. However they
        can only be used if your view sets the bean property
        <tt class="literal">exposeSpringMacroHelpers</tt> to <tt class="literal">true</tt>
        . The same property can be set on
        <tt class="literal">VelocityViewResolver</tt> or
        <tt class="literal">FreeMarkerViewResolver</tt> too if you happen to be
        using it, in which case all of your views will inherit the value from
        it. Note that this property is <span class="bold"><b>not
        required</b></span> for any aspect of HTML form handling <span class="bold"><b>except</b></span> where you wish to take advantage of the
        Spring macros. Below is an example of a view.properties file showing
        correct configuration of such a view for either language;</p><pre class="programlisting">personFormV.class=org.springframework.web.servlet.view.velocity.VelocityView
personFormV.url=personForm.vm
personFormV.exposeSpringMacroHelpers=true</pre><pre class="programlisting">personFormF.class=org.springframework.web.servlet.view.freemarker.FreeMarkerView
personFormF.url=personForm.ftl
personFormF.exposeSpringMacroHelpers=true</pre><p>Some of the macros defined in the Spring libraries are
        considered internal (private) but no such scoping exists in the macro
        definitions making all macros visible to calling code and user
        templates. The following sections concentrate only on the macros you
        need to be directly calling from within your templates. If you wish to
        view the macro code directly, the files are called spring.vm /
        spring.ftl and are in the packages
        <tt class="literal">org.springframework.web.servlet.view.velocity</tt> or
        <tt class="literal">org.springframework.web.servlet.view.freemarker</tt>
        respectively.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-velocity-validationmessages"></a>13.4.5.2.&nbsp;simple binding</h4></div></div><div></div></div><p>In your html forms (vm / ftl templates) that act as the
        'formView' for a Spring form controller, you can use code similar to
        the following to bind to field values and display error messages for
        each input field in similar fashion to the JSP equivalent. Note that
        the name of the command object is "command" by default, but can be
        overridden in your MVC configuration by setting the 'commandName' bean
        property on your form controller. Example code is shown below for the
        <tt class="literal">personFormV</tt> and <tt class="literal">personFormF</tt>
        views configured earlier;</p><pre class="programlisting">&lt;!-- velocity macros are automatically available --&gt;
&lt;html&gt;
...
&lt;form action="" method="POST"&gt;
  Name: 
  #springBind( "command.name" )
  &lt;input type="text" 
    name="${status.expression}" 
    value="$!status.value" /&gt;&lt;br&gt;
  #foreach($error in $status.errorMessages) &lt;b&gt;$error&lt;/b&gt; &lt;br&gt; #end
  &lt;br&gt;
  ... 
  &lt;input type="submit" value="submit"/&gt;
&lt;/form&gt;
...
&lt;/html&gt;</pre><pre class="programlisting">&lt;!-- freemarker macros have to be imported into a namespace.  We strongly
recommend sticking to 'spring' --&gt;
&lt;#import "spring.ftl" as spring /&gt;
&lt;html&gt;
...
&lt;form action="" method="POST"&gt;
  Name: 
  &lt;@spring.bind "command.name" /&gt; 
  &lt;input type="text" 
    name="${spring.status.expression}" 
    value="${spring.status.value?default("")}" /&gt;&lt;br&gt;
  &lt;#list spring.status.errorMessages as error&gt; &lt;b&gt;${error}&lt;/b&gt; &lt;br&gt; &lt;/#list&gt;
  &lt;br&gt;
  ... 
  &lt;input type="submit" value="submit"/&gt;
&lt;/form&gt;
...
&lt;/html&gt;</pre><p><tt class="literal">#springBind</tt> /
        <tt class="literal">&lt;@spring.bind&gt;</tt> requires a 'path' argument
        which consists of the name of your command object (it will be
        'command' unless you changed it in your FormController properties)
        followed by a period and the name of the field on the command object
        you wish to bind to. Nested fields can be used too such as
        "command.address.street". The <tt class="literal">bind</tt> macro assumes
        the default HTML escaping behavior specified by the ServletContext
        parameter <tt class="literal">defaultHtmlEscape</tt> in web.xml</p><p>The optional form of the macro called
        <tt class="literal">#springBindEscaped</tt> /
        <tt class="literal">&lt;@spring.bindEscaped&gt;</tt> takes a second argument
        and explicitly specifies whether HTML escaping should be used in the
        status error messages or values. Set to true or false as required.
        Additional form handling macros simplify the use of HTML escaping and
        these macros should be used wherever possible. They are explained in
        the next section.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8180"></a>13.4.5.3.&nbsp;form input generation macros</h4></div></div><div></div></div><p>Additional convenience macros for both languages simplify both
        binding and form generation (including validation error display). It
        is never necessary to use these macros to generate form input fields,
        and they can be mixed and matched with simple HTML or calls direct to
        the spring bind macros highlighted previously.</p><p>The following table of available macros show the VTL and FTL
        definitions and the parameter list that each takes.</p><div class="table"><a name="d0e8187"></a><p class="title"><b>Table&nbsp;13.1.&nbsp;table of macro definitions</b></p><table summary="table of macro definitions" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="center">macro</th><th align="center">VTL definition</th><th align="center">FTL definition</th></tr></thead><tbody><tr><td align="left"><span class="bold"><b>message</b></span> (output a
                string from a resource bundle based on the code
                parameter)</td><td><tt class="literal">#springMessage($code)</tt></td><td><tt class="literal">&lt;@spring.message
                code/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>messageText</b></span> (output a
                string from a resource bundle based on the code parameter,
                falling back to the value of the default parameter)</td><td><tt class="literal">#springMessageText($code
                $default)</tt></td><td><tt class="literal">&lt;@spring.messageText code,
                default/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>url</b></span> (prefix a relative
                URL with the application's context root)</td><td><tt class="literal">#springUrl($relativeUrl)</tt></td><td><tt class="literal">&lt;@spring.url
                relativeUrl/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formInput</b></span> (standard
                input field for gathering user input)</td><td><tt class="literal">#springFormInput($path
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formInput path, attributes,
                fieldType/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formHiddenInput *</b></span>
                (hidden input field for submitting non-user input)</td><td><tt class="literal">#springFormHiddenInput($path
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formHiddenInput path,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formPasswordInput</b></span> *
                (standard input field for gathering passwords. Note that no
                value will ever be populated in fields of this type)</td><td><tt class="literal">#springFormPasswordInput($path
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formPasswordInput path,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formTextarea</b></span> (large
                text field for gathering long, freeform text input)</td><td><tt class="literal">#springFormTextarea($path
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formTextarea path,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formSingleSelect</b></span> (drop
                down box of options allowing a single required value to be
                selected)</td><td><tt class="literal">#springFormSingleSelect( $path $options
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formSingleSelect path, options,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formMultiSelect</b></span> (a
                list box of options allowing the user to select 0 or more
                values)</td><td><tt class="literal">#springFormMultiSelect($path $options
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formMultiSelect path, options,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formRadioButtons</b></span> (a
                set of radio buttons allowing a single selection to be made
                from the available choices)</td><td><tt class="literal">#springFormRadioButtons($path $options
                $separator $attributes)</tt></td><td><tt class="literal">&lt;@spring.formRadioButtons path, options
                separator, attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formCheckboxes</b></span> (a set
                of checkboxes allowing 0 or more values to be
                selected)</td><td><tt class="literal">#springFormCheckboxes($path $options
                $separator $attributes)</tt></td><td><tt class="literal">&lt;@spring.formCheckboxes path, options,
                separator, attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>showErrors</b></span> (simplify
                display of validation errors for the bound field)</td><td><tt class="literal">#springShowErrors($separator
                $classOrStyle)</tt></td><td><tt class="literal">&lt;@spring.showErrors separator,
                classOrStyle/&gt;</tt></td></tr></tbody></table></div><p>* In FTL (FreeMarker), these two macros are not actually
        required as you can use the normal <tt class="literal">formInput</tt> macro,
        specifying '<tt class="literal">hidden</tt>' or
        '<tt class="literal">password</tt>' as the value for the
        <tt class="literal">fieldType</tt> parameter.</p><p>The parameters to any of the above macros have consistent
        meanings:</p><div class="itemizedlist"><ul type="disc"><li><p>path: the name of the field to bind to (ie
            "command.name")</p></li><li><p>options: a Map of all the available values that can be
            selected from in the input field. The keys to the map represent
            the values that will be POSTed back from the form and bound to the
            command object. Map objects stored against the keys are the labels
            displayed on the form to the user and may be different from the
            corresponding values posted back by the form. Usually such a map
            is supplied as reference data by the controller. Any Map
            implementation can be used depending on required behavior. For
            strictly sorted maps, a <tt class="literal">SortedMap</tt> such as a
            <tt class="literal">TreeMap</tt> with a suitable Comparator may be used
            and for arbitrary Maps that should return values in insertion
            order, use a <tt class="literal">LinkedHashMap</tt> or a
            <tt class="literal">LinkedMap</tt> from commons-collections.</p></li><li><p>separator: where multiple options are available as discreet
            elements (radio buttons or checkboxes), the sequence of characters
            used to separate each one in the list (ie "&lt;br&gt;").</p></li><li><p>attributes: an additional string of arbitrary tags or text
            to be included within the HTML tag itself. This string is echoed
            literally by the macro. For example, in a textarea field you may
            supply attributes as 'rows="5" cols="60"' or you could pass style
            information such as 'style="border:1px solid silver"'.</p></li><li><p>classOrStyle: for the showErrors macro, the name of the CSS
            class that the span tag wrapping each error will use. If no
            information is supplied (or the value is empty) then the errors
            will be wrapped in &lt;b&gt;&lt;/b&gt; tags.</p></li></ul></div><p>Examples of the macros are outlined below some in FTL and some
        in VTL. Where usage differences exist between the two languages, they
        are explained in the notes.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8379"></a>13.4.5.3.1.&nbsp;Input Fields</h5></div></div><div></div></div><pre class="programlisting">&lt;!-- the Name field example from above using form macros in VTL --&gt;
...
    Name:
    #springFormInput("command.name" "")&lt;br&gt;
    #springShowErrors("&lt;br&gt;" "")&lt;br&gt;</pre><p>The formInput macro takes the path parameter (command.name)
          and an additional attributes parameter which is empty in the example
          above. The macro, along with all other form generation macros,
          performs an implicit spring bind on the path parameter. The binding
          remains valid until a new bind occurs so the showErrors macro
          doesn't need to pass the path parameter again - it simply operates
          on whichever field a bind was last created for.</p><p>The showErrors macro takes a separator parameter (the
          characters that will be used to separate multiple errors on a given
          field) and also accepts a second parameter, this time a class name
          or style attribute. Note that FreeMarker is able to specify default
          values for the attributes parameter, unlike Velocity, and the two
          macro calls above could be expressed as follows in FTL:</p><pre class="programlisting">&lt;@spring.formInput "command.name"/&gt;
&lt;@spring.showErrors "&lt;br&gt;"/&gt;</pre><p>Output is shown below of the form fragment generating the name
          field, and displaying a validation error after the form was
          submitted with no value in the field. Validation occurs through
          Spring's Validation framework.</p><p>The generated HTML looks like this:</p><pre class="programlisting">Name:
  &lt;input type="text" name="name" value=""     
&gt;
&lt;br&gt;
  &lt;b&gt;required&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;</pre><p>The formTextarea macro works the same way as the formInput
          macro and accepts the same parameter list. Commonly, the second
          parameter (attributes) will be used to pass style information or
          rows and cols attributes for the textarea.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8399"></a>13.4.5.3.2.&nbsp;Selection Fields</h5></div></div><div></div></div><p>Four selection field macros can be used to generate common UI
          value selection inputs in your HTML forms.</p><div class="itemizedlist"><ul type="disc"><li><p>formSingleSelect</p></li><li><p>formMultiSelect</p></li><li><p>formRadioButtons</p></li><li><p>formCheckboxes</p></li></ul></div><p>Each of the four macros accepts a Map of options containing
          the value for the form field, and the label corresponding to that
          value. The value and the label can be the same.</p><p>An example of radio buttons in FTL is below. The form backing
          object specifies a default value of 'London' for this field and so
          no validation is necessary. When the form is rendered, the entire
          list of cities to choose from is supplied as reference data in the
          model under the name 'cityMap'.</p><pre class="programlisting">...
  Town:
  &lt;@spring.formRadioButtons "command.address.town", cityMap, "" /&gt;&lt;br&gt;&lt;br&gt;</pre><p>This renders a line of radio buttons, one for each value in
          <tt class="literal">cityMap</tt> using the separator "". No additional
          attributes are supplied (the last parameter to the macro is
          missing). The cityMap uses the same String for each key-value pair
          in the map. The map's keys are what the form actually submits as
          POSTed request parameters, map values are the labels that the user
          sees. In the example above, given a list of three well known cities
          and a default value in the form backing object, the HTML would
          be</p><pre class="programlisting">Town:
&lt;input type="radio" name="address.town" value="London"
   
&gt;
London
&lt;input type="radio" name="address.town" value="Paris"
  checked="checked" 
&gt;
Paris
&lt;input type="radio" name="address.town" value="New York"
   
&gt;
New York</pre><p>If your application expects to handle cities by internal codes
          for example, the map of codes would be created with suitable keys
          like the example below.</p><pre class="programlisting">protected Map referenceData(HttpServletRequest request) throws Exception {
  Map cityMap = new LinkedHashMap();
  cityMap.put("LDN", "London");
  cityMap.put("PRS", "Paris");
  cityMap.put("NYC", "New York");
  
  Map m = new HashMap();
  m.put("cityMap", cityMap);
  return m;
}</pre><p>The code would now produce output where the radio values are
          the relevant codes but the user still sees the more user friendly
          city names.</p><pre class="programlisting">Town:
&lt;input type="radio" name="address.town" value="LDN"
   
&gt;
London
&lt;input type="radio" name="address.town" value="PRS"
  checked="checked" 
&gt;
Paris
&lt;input type="radio" name="address.town" value="NYC"
   
&gt;
New York</pre></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8438"></a>13.4.5.4.&nbsp;overriding HTML escaping and making tags XHTML
        compliant</h4></div></div><div></div></div><p>Default usage of the form macros above will result in HTML tags
        that are HTML 4.01 compliant and that use the default value for HTML
        escaping defined in your web.xml as used by Spring's bind support. In
        order to make the tags XHTML compliant or to override the default HTML
        escaping value, you can specify two variables in your template (or in
        your model where they will be visible to your templates). The
        advantage of specifying them in the templates is that they can be
        changed to different values later in the template processing to
        provide different behavior for different fields in your form.</p><p>To switch to XHTML compliance for your tags, specify a value of
        'true' for a model/context variable named xhtmlCompliant:</p><pre class="programlisting">## for Velocity..
#set($springXhtmlCompliant = true)

&lt;#-- for FreeMarker --&gt;
&lt;#assign xhtmlCompliant = true in spring&gt;</pre><p>Any tags generated by the Spring macros will now be XHTML
        compliant after processing this directive.</p><p>In similar fashion, HTML escaping can be specified per
        field:</p><pre class="programlisting">&lt;#-- until this point, default HTML escaping is used --&gt;

&lt;#assign htmlEscape = true in spring&gt;
&lt;#-- next field will use HTML escaping --&gt;
&lt;@spring.formInput "command.name" /&gt;

&lt;#assign htmlEscape = false in spring&gt;
&lt;#-- all future fields will be bound with HTML escaping off --&gt;</pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-xslt"></a>13.5.&nbsp;XSLT</h2></div></div><div></div></div><p>XSLT is a transformation language for XML and is popular as a view
    technology within web applications. XSLT can be a good choice as a view
    technology if your application naturally deals with XML, or if your model
    can easily be converted to XML. The following section shows how to produce
    an XML document as model data and have it transformed with XSLT in a
    Spring application.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-xslt-firstwords"></a>13.5.1.&nbsp;My First Words</h3></div></div><div></div></div><p>This example is a trivial Spring application that creates a list
      of words in the Controller and adds them to the model map. The map is
      returned along with the view name of our XSLT view. See <a href="#mvc-controller" title="12.3.&nbsp;Controllers">Section&nbsp;12.3, &#8220;Controllers&#8221;</a> for details of Spring
      <tt class="literal">Controller</tt>s. The XSLT view will turn the list of
      words into a simple XML document ready for transformation.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-beandefs"></a>13.5.1.1.&nbsp;Bean definitions</h4></div></div><div></div></div><p>Configuration is standard for a simple Spring application. The
        dispatcher servlet config file contains a reference to a
        <tt class="literal">ViewResolver</tt>, URL mappings and a single controller
        bean.. </p><pre class="programlisting">&lt;bean id="homeController"class="xslt.HomeController"/&gt; </pre><p>
        ..that implements our word generation 'logic'.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-controllercode"></a>13.5.1.2.&nbsp;Standard MVC controller code</h4></div></div><div></div></div><p>The controller logic is encapsulated in a subclass of
        AbstractController, with the handler method being defined like so..
        </p><pre class="programlisting">protected ModelAndView handleRequestInternal(
    HttpServletRequest req,
    HttpServletResponse resp)
    throws Exception {
        
    Map map = new HashMap();
    List wordList = new ArrayList();
        
    wordList.add("hello");
    wordList.add("world");
       
    map.put("wordList", wordList);
      
    return new ModelAndView("home", map);
} </pre><p>So far we've done nothing that's XSLT specific. The model data
        has been created in the same way as you would for any other Spring MVC
        application. Depending on the configuration of the application now,
        that list of words could be rendered by JSP/JSTL by having them added
        as request attributes, or they could be handled by Velocity by adding
        the object to the VelocityContext. In order to have XSLT render them,
        they of course have to be converted into an XML document somehow.
        There are software packages available that will automatically 'domify'
        an object graph, but within Spring, you have complete flexibility to
        create the DOM from your model in any way you choose. This prevents
        the transformation of XML playing too great a part in the structure of
        your model data which is a danger when using tools to manage the
        domification process.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-subclassing"></a>13.5.1.3.&nbsp;Convert the model data to XML</h4></div></div><div></div></div><p>In order to create a DOM document from our list of words or any
        other model data, we subclass
        <tt class="literal">org.springframework.web.servlet.view.xslt.AbstractXsltView</tt>.
        In doing so, we must implement the abstract method
        <tt class="literal">createDomNode()</tt>. The first parameter passed to this
        method is our model Map. Here's the complete listing of the HomePage
        class in our trivial word application - it uses JDOM to build the XML
        document before converting it to the required W3C Node, but this is
        simply because I find JDOM (and Dom4J) easier API's to handle than the
        W3C API. </p><pre class="programlisting">
package xslt;

// imports omitted for brevity

public class HomePage extends AbstractXsltView {

    protected Node createDomNode( 
        Map model, String rootName, HttpServletRequest req, HttpServletResponse res
    ) throws Exception {
        
        org.jdom.Document doc = new org.jdom.Document();
        Element root = new Element(rootName);
        doc.setRootElement(root);

        List words = (List) model.get("wordList");
        for (Iterator it = words.iterator(); it.hasNext();) {
            String nextWord = (String) it.next();
            Element e = new Element("word");
            e.setText(nextWord);
            root.addContent(e);
        }

        // convert JDOM doc to a W3C Node and return
        return new DOMOutputter().output( doc );
    }

}</pre><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8501"></a>13.5.1.3.1.&nbsp;Adding stylesheet parameters</h5></div></div><div></div></div><p>A series of parameter name/value pairs can optionally be
          defined by your subclass which will be added to the transformation
          object. The parameter names must match those defined in your XSLT
          template declared with <tt class="literal">&lt;xsl:param
          name="myParam"&gt;defaultValue&lt;/xsl:param&gt;</tt> To
          specify the parameters, override the method
          <tt class="literal">getParameters()</tt> from AbstractXsltView and return
          a <tt class="literal">Map</tt> of the name/value pairs. If your parameters
          need to derive information from the current request, you can (from
          version 1.1) override the <tt class="literal">getParameters(HttpServletRequest
          request)</tt> method instead.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="view-xslt-formathelper"></a>13.5.1.3.2.&nbsp;Formatting dates and currency</h5></div></div><div></div></div><p>Unlike JSTL and Velocity, XSLT has relatively poor support for
          locale based currency and date formatting. In recognition of the
          fact, Spring provides a helper class that you can use from within
          your <tt class="literal">createDomNode()</tt> methods to get such support.
          See the javadocs for
          <tt class="literal">org.springframework.web.servlet.view.xslt.FormatHelper</tt></p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-viewdefinitions"></a>13.5.1.4.&nbsp;Defining the view properties</h4></div></div><div></div></div><p>The views.properties file (or equivalent xml definition if
        you're using an XML based view resolver as we did in the Velocity
        examples above) looks like this for the one-view application that is
        'My First Words'.. </p><pre class="programlisting">home.class=xslt.HomePage
home.stylesheetLocation=/WEB-INF/xsl/home.xslt
home.root=words</pre><p> Here, you can see how the view is tied in
        with the HomePage class just written which handles the model
        domification in the first property '.class'. The stylesheetLocation
        property obviously points to the XSLT file which will handle the XML
        transformation into HTML for us and the final property '.root' is the
        name that will be used as the root of the XML document. This gets
        passed to the HomePage class above in the second parameter to the
        <tt class="literal">createDomNode</tt> method.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-transforming"></a>13.5.1.5.&nbsp;Document transformation</h4></div></div><div></div></div><p>Finally, we have the XSLT code used for transforming the above
        document. As highlighted in the views.properties file, it is called
        <tt class="literal">home.xslt</tt> and it lives in the war file under
        <tt class="literal">WEB-INF/xsl</tt>. </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:output method="text/html" omit-xml-declaration="yes"/&gt;

    &lt;xsl:template match="/"&gt;
        &lt;html&gt;
            &lt;head&gt;&lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;
            &lt;body&gt;

                &lt;h1&gt;My First Words&lt;/h1&gt;
                &lt;xsl:for-each select="wordList/word"&gt;
                    &lt;xsl:value-of select="."/&gt;&lt;br /&gt;
                &lt;/xsl:for-each&gt; 

            &lt;/body&gt;
        &lt;/html&gt;
    &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-xslt-summary"></a>13.5.2.&nbsp;Summary</h3></div></div><div></div></div><p>A summary of the files discussed and their location in the WAR
      file is shown in the simplified WAR structure below. </p><pre class="programlisting">ProjectRoot
  |
  +- WebContent
      |
      +- WEB-INF
          |
          +- classes
          |    |
          |    +- xslt
          |    |   |
          |    |   +- HomePageController.class 
          |    |   +- HomePage.class
          |    |
          |    +- views.properties
          |
          +- lib
          |   |
          |   +- spring.jar
          |
          +- xsl
          |   |
          |   +- home.xslt
          |
          +- frontcontroller-servlet.xml</pre><p> You will also need
      to ensure that an XML parser and an XSLT engine are available on the
      classpath. JDK 1.4 provides them by default, and most J2EE containers
      will also make them available by default, but it's a possible source of
      errors to be aware of.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-document"></a>13.6.&nbsp;Document views (PDF/Excel)</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-document-intro"></a>13.6.1.&nbsp;Introduction</h3></div></div><div></div></div><p>Returning an HTML page isn't always the best way for the user to
      view the model output, and Spring makes it simple to generate a PDF
      document or an Excel spreadsheet dynamically from the model data. The
      document is the view and will be streamed from the server with the
      correct content type to (hopefully) enable the client PC to run their
      spreadsheet or PDF viewer application in response.</p><p>In order to use Excel views, you need to add the 'poi' library to
      your classpath, and for PDF generation, the iText.jar. Both are included
      in the main Spring distribution.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-document-config"></a>13.6.2.&nbsp;Configuration and setup</h3></div></div><div></div></div><p>Document based views are handled in an almost identical fashion to
      XSLT views, and the following sections build upon the previous one by
      demonstrating how the same controller used in the XSLT example is
      invoked to render the same model as both a PDF document and an Excel
      spreadsheet (which can also be viewed or manipulated in Open
      Office).</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configviews"></a>13.6.2.1.&nbsp;Document view definitions</h4></div></div><div></div></div><p>Firstly, let's amend the views.properties file (or xml
        equivalent) and add a simple view definition for both document types.
        The entire file now looks like this with the XSLT view shown from
        earlier.. </p><pre class="programlisting">home.class=xslt.HomePage
home.stylesheetLocation=/WEB-INF/xsl/home.xslt
home.root=words

xl.class=excel.HomePage

pdf.class=pdf.HomePage</pre><p> <span class="emphasis"><em>If you want to start with a
        template spreadsheet to add your model data to, specify the location
        as the 'url' property in the view definition</em></span></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configcontroller"></a>13.6.2.2.&nbsp;Controller code</h4></div></div><div></div></div><p>The controller code we'll use remains exactly the same from the
        XSLT example earlier other than to change the name of the view to use.
        Of course, you could be clever and have this selected based on a URL
        parameter or some other logic - proof that Spring really is very good
        at decoupling the views from the controllers!</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configsubclasses"></a>13.6.2.3.&nbsp;Subclassing for Excel views</h4></div></div><div></div></div><p>Exactly as we did for the XSLT example, we'll subclass suitable
        abstract classes in order to implement custom behavior in generating
        our output documents. For Excel, this involves writing a subclass of
        <tt class="literal">org.springframework.web.servlet.view.document.AbstractExcelView</tt>
        and implementing the <tt class="literal">buildExcelDocument</tt></p><p>Here's the complete listing for our Excel view which displays
        the word list from the model map in consecutive rows of the first
        column of a new spreadsheet.. </p><pre class="programlisting">package excel;

// imports omitted for brevity

public class HomePage extends AbstractExcelView {

    protected void buildExcelDocument(
        Map model,
        HSSFWorkbook wb,
        HttpServletRequest req,
        HttpServletResponse resp)
        throws Exception {
    
        HSSFSheet sheet;
        HSSFRow sheetRow;
        HSSFCell cell;

        // Go to the first sheet
        // getSheetAt: only if wb is created from an existing document
        //sheet = wb.getSheetAt( 0 );
        sheet = wb.createSheet("Spring");
        sheet.setDefaultColumnWidth((short)12);

        // write a text at A1
        cell = getCell( sheet, 0, 0 );
        setText(cell,"Spring-Excel test");

        List words = (List ) model.get("wordList");
        for (int i=0; i &lt; words.size(); i++) {
            cell = getCell( sheet, 2+i, 0 );
            setText(cell, (String) words.get(i));

        }
    }
}</pre><p>If you now amend the controller such that it returns
        <tt class="literal">xl</tt> as the name of the view (<tt class="literal">return new
        ModelAndView("xl", map);</tt>) and run your application again,
        you should find that the Excel spreadsheet is created and downloaded
        automagically when you request the same page as before.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configsubclasspdf"></a>13.6.2.4.&nbsp;Subclassing for PDF views</h4></div></div><div></div></div><p>The PDF version of the word list is even simpler. This time, the
        class extends
        <tt class="literal">org.springframework.web.servlet.view.document.AbstractPdfView</tt>
        and implements the <tt class="literal">buildPdfDocument()</tt> method as
        follows.. </p><pre class="programlisting">package pdf;

// imports omitted for brevity

public class PDFPage extends AbstractPdfView {

    protected void buildPdfDocument(
        Map model,
        Document doc,
        PdfWriter writer,
        HttpServletRequest req,
        HttpServletResponse resp)
        throws Exception {
        
        List words = (List) model.get("wordList");
        
        for (int i=0; i&lt;words.size(); i++)
            doc.add( new Paragraph((String) words.get(i)));
    
    }
}</pre><p> Once again, amend the controller to return the
        <tt class="literal">pdf</tt> view with a <tt class="literal">return new
        ModelAndView("pdf", map);</tt> and reload the URL in your
        application. This time a PDF document should appear listing each of
        the words in the model map.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-jasper-reports"></a>13.7.&nbsp;JasperReports</h2></div></div><div></div></div><p>JasperReports (<a href="http://jasperreports.sourceforge.net" target="_top">http://jasperreports.sourceforge.net</a>) is a powerful,
    open-source reporting engine that supports the creation of report designs
    using an easily understood XML file formats. JasperReports is capable of
    rendering reports output into four different formats: CSV, Excel, HTML and
    PDF.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-dependencies"></a>13.7.1.&nbsp;Dependencies</h3></div></div><div></div></div><p>Your application will need to include the latest release of
      JasperReports, which at the time of writing was 0.6.1. JasperReports
      itself depends on the following projects:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>BeanShell</p></li><li style="list-style-type: disc"><p>Commons BeanUtils</p></li><li style="list-style-type: disc"><p>Commons Collections</p></li><li style="list-style-type: disc"><p>Commons Digester</p></li><li style="list-style-type: disc"><p>Commons Logging</p></li><li style="list-style-type: disc"><p>iText</p></li><li style="list-style-type: disc"><p>POI</p></li></ul></div><p>JasperReports also requires a JAXP compliant XML parser.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-configuration"></a>13.7.2.&nbsp;Configuration</h3></div></div><div></div></div><p>To configure JasperReports views in your
      <tt class="literal">ApplicationContext</tt> you have to define a
      <tt class="literal">ViewResolver</tt> to map view names to the appropriate
      view class depending on which format you want your report rendered
      in.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-resolver"></a>13.7.2.1.&nbsp;Configuring the <tt class="literal">ViewResolver</tt></h4></div></div><div></div></div><p>Typically, you will use the
        <tt class="literal">ResourceBundleViewResolver</tt> to map view names to
        view classes and files in a properties file </p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename"&gt;
        &lt;value&gt;views&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                  </pre><p>Here we've configured an instance of
        <tt class="literal">ResourceBundleViewResolver</tt> which will look for view
        mappings in the resource bundle with base name
        <tt class="literal">views</tt>. The exact contents of this file is described
        in the next section.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-views"></a>13.7.2.2.&nbsp;Configuring the <tt class="literal">View</tt>s</h4></div></div><div></div></div><p>Spring contains five different View implementations for
        JasperReports four of which corresponds to one of the four output
        formats supported by JasperReports and one that allows for the format
        to be determined at runtime:</p><div class="table"><a name="view-jasper-reports-configuration-views-classes"></a><p class="title"><b>Table&nbsp;13.2.&nbsp;JasperReports <tt class="literal">View</tt> Classes</b></p><table summary="JasperReports View Classes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class Name</th><th>Render Format</th></tr></thead><tbody><tr><td><tt class="literal">JasperReportsCsvView</tt></td><td>CSV</td></tr><tr><td><tt class="literal">JasperReportsHtmlView</tt></td><td>HTML</td></tr><tr><td><tt class="literal">JasperReportsPdfView</tt></td><td>PDF</td></tr><tr><td><tt class="literal">JasperReportsXlsView</tt></td><td>Microsoft Excel</td></tr><tr><td><tt class="literal">JasperReportsMultiFormatView</tt></td><td>Decided at runtime (see <a href="#view-jasper-reports-configuration-multiformat-view" title="13.7.2.4.&nbsp;Using JasperReportsMultiFormatView">Section&nbsp;13.7.2.4, &#8220;Using JasperReportsMultiFormatView&#8221;</a>)</td></tr></tbody></table></div><p>Mapping one of these classes to a view name and a report file is
        simply a matter of adding the appropriate entries into the resource
        bundle configured in the previous section as shown here:</p><pre class="programlisting">simpleReport.class=org.springframework.web.servlet.view.jasperreports.JasperReportsPdfView
simpleReport.url=/WEB-INF/reports/DataSourceReport.jasper
              </pre><p>Here you can see that the view with name,
        <tt class="literal">simpleReport</tt>, is mapped to the
        <tt class="literal">JasperReportsPdfView</tt> class. This will cause the
        output of this report to be rendered in PDF format. The
        <tt class="literal">url</tt> property of the view is set to the location of
        the underlying report file.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-report-files"></a>13.7.2.3.&nbsp;About Report Files</h4></div></div><div></div></div><p>JasperReports has two distinct types of report file: the design
        file, which has a <tt class="literal">.jrxml</tt> extension, and the
        compiled report file, which has a <tt class="literal">.jasper</tt>
        extension. Typically, you use the JasperReports Ant task to compile
        your <tt class="literal">.jrxml</tt> design file into a
        <tt class="literal">.jasper</tt> file before deploying it into your
        application. With Spring you can map either of these files to your
        report file and Spring will take care of compiling the
        <tt class="literal">.jrxml</tt> file on the fly for you. You should note
        that after a <tt class="literal">.jrxml</tt> file is compiled by Spring, the
        compiled report is cached for the life of the application. To make
        changes to the file you will need to restart your application.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-multiformat-view"></a>13.7.2.4.&nbsp;Using <tt class="literal">JasperReportsMultiFormatView</tt></h4></div></div><div></div></div><p>The <tt class="literal">JasperReportsMultiFormatView</tt> allows for
        report format to be specified at runtime. The actual rendering of the
        report is delegated to one of the other JasperReports view classes -
        the <tt class="literal">JasperReportsMultiFormatView</tt> class simply adds
        a wrapper layer that allows for the exact implementation to be
        specified at runtime.</p><p>The <tt class="literal">JasperReportsMultiFormatView</tt> class
        introduces two concepts: the format key and the discriminator key. The
        <tt class="literal">JasperReportsMultiFormatView</tt> class uses the mapping
        key to lookup the actual view implementation class and uses the format
        key to lookup up the mapping key. From a coding perspective you add an
        entry to your model with the formay key as the key and the mapping key
        as the value, for example:</p><pre class="programlisting">public ModelAndView handleSimpleReportMulti(HttpServletRequest request,
HttpServletResponse response) throws Exception {

  String uri = request.getRequestURI();
  String format = uri.substring(uri.lastIndexOf(".") + 1);

  Map model = getModel();
  model.put("format", format);

  return new ModelAndView("simpleReportMulti", model);
}</pre><p>In this example, the mapping key is determined from the
        extension of the request URI and is added to the model under the
        default format key: <tt class="literal">format</tt>. If you wish to use a
        different format key then you can configure this using the
        <tt class="literal">formatKey</tt> property of the
        <tt class="literal">JasperReportsMultiFormatView</tt> class.</p><p>By default the following mapping key mappings are configured in
        <tt class="literal">JasperReportsMultiFormatView</tt>: </p><div class="table"><a name="view-jasper-reports-configuration-multiformat-view-mappings"></a><p class="title"><b>Table&nbsp;13.3.&nbsp;JasperReportsMultiFormatView Default Mapping Key
            Mappings</b></p><table summary="JasperReportsMultiFormatView Default Mapping Key&#xA;            Mappings" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mapping Key</th><th>View Class</th></tr></thead><tbody><tr><td>csv</td><td><tt class="literal">JasperReportsCsvView</tt></td></tr><tr><td>html</td><td><tt class="literal">JasperReportsHtmlView</tt></td></tr><tr><td>pdf</td><td><tt class="literal">JasperReportsPdfView</tt></td></tr><tr><td>xls</td><td><tt class="literal">JasperReportsXlsView</tt></td></tr></tbody></table></div><p> So in the example above a request to URI /foo/myReport.pdf
        would be mapped to the <tt class="literal">JasperReportsPdfView</tt> class.
        You can override the mapping key to view class mappings using the
        <tt class="literal">formatMappings</tt> property of
        <tt class="literal">JasperReportsMultiFormatView</tt>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-model"></a>13.7.3.&nbsp;Populating the <tt class="literal">ModelAndView</tt></h3></div></div><div></div></div><p>In order to render your report correctly in the format you have
      chosen, you must supply Spring with all of the data needed to populate
      your report. For JasperReports this means you must pass in all report
      parameters along with the report datasource. Report parameters are
      simple name/value pairs and can be added be to the
      <tt class="literal">Map</tt> for your model as you would add any name/value
      pair.</p><p>When adding the datasource to the model you have two approaches to
      choose from. The first approach is to add an instance of
      <tt class="literal">JRDataSource</tt> or <tt class="literal">Collection</tt> to the
      model <tt class="literal">Map</tt> under any arbitrary key. Spring will then
      locate this object in the model and treat it as the report datasource.
      For example, you may populate your model like this: </p><pre class="programlisting">private Map getModel() {
  Map model = new HashMap();
  Collection beanData = getBeanData();
  model.put("myBeanData", beanData);
  return model;
}</pre><p>The second approach is to add the instance of
      <tt class="literal">JRDataSource</tt> or <tt class="literal">Collection</tt> under a
      specific key and then configure this key using the
      <tt class="literal">reportDataKey</tt> property of the view class. In both
      cases Spring will instances of <tt class="literal">Collection</tt> in a
      <tt class="literal">JRBeanCollectionDataSource</tt> instance. For example:
      </p><pre class="programlisting">private Map getModel() {
  Map model = new HashMap();
  Collection beanData = getBeanData();
  Collection someData = getSomeData();
  model.put("myBeanData", beanData);
  model.put("someData", someData);
  return model;
}</pre><p> Here you can see that two <tt class="literal">Collection</tt>
      instances are being added to the model. To ensure that the correct one
      is used, we simply modify our view configuration as appropriate:
      </p><pre class="programlisting">simpleReport.class=org.springframework.web.servlet.view.jasperreports.JasperReportsPdfView
simpleReport.url=/WEB-INF/reports/DataSourceReport.jasper
simpleReport.reportDataKey=myBeanData
              </pre><p>Be aware that when using the first approach, Spring will use the
      first instance of <tt class="literal">JRDataSource</tt> or
      <tt class="literal">Collection</tt> that it encounters. If you need to place
      multiple instances of <tt class="literal">JRDataSource</tt> or
      <tt class="literal">Collection</tt> into the model then you need to use the
      second approach.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-subreports"></a>13.7.4.&nbsp;Working with Sub-Reports</h3></div></div><div></div></div><p>JasperReports provides support for embedded sub-reports within
      your master report files. There are a wide variety of mechanisms for
      including sub-reports in your report files. The easiest way is to hard
      code the report path and the SQL query for the sub report into your
      design files. The drawback of this approach is obvious - the values are
      hard-coded into your report files reducing reusability and making it
      harder to modify and update report designs. To overcome this you can
      configure sub-reports declaratively and you can include additional data
      for these sub-reports directly from your controllers.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-subreports-config-reports"></a>13.7.4.1.&nbsp;Configuring Sub-Report Files</h4></div></div><div></div></div><p>To control which sub-report files are included in a master
        report using Spring, your report file must be configured to accept
        sub-reports from an external source. To do this you declare a
        parameter in your report file like this: </p><pre class="programlisting">&lt;parameter name="ProductsSubReport" class="net.sf.jasperreports.engine.JasperReport"/&gt;</pre><p>
        Then, you define your sub-report to use this sub-report parameter:
        </p><pre class="programlisting">&lt;subreport&gt;
    &lt;reportElement isPrintRepeatedValues="false" x="5" y="25" width="325"
        height="20" isRemoveLineWhenBlank="true" backcolor="#ffcc99"/&gt;
    &lt;subreportParameter name="City"&gt;
        &lt;subreportParameterExpression&gt;&lt;![CDATA[$F{city}]]&gt;&lt;/subreportParameterExpression&gt;
    &lt;/subreportParameter&gt;
    &lt;dataSourceExpression&gt;&lt;![CDATA[$P{SubReportData}]]&gt;&lt;/dataSourceExpression&gt;
    &lt;subreportExpression class="net.sf.jasperreports.engine.JasperReport"&gt;
                  &lt;![CDATA[$P{ProductsSubReport}]]&gt;&lt;/subreportExpression&gt;
&lt;/subreport&gt;</pre><p> This defines a master report file that
        expects the sub-report to be passed in as an instance of
        <tt class="literal">net.sf.jasperreports.engine.JasperReports</tt> under the
        parameter <tt class="literal">ProductsSubReport</tt>. When configuring your
        Jasper view class, you can instruct Spring to load a report file and
        pass into the JasperReports engine as a sub-report using the
        <tt class="literal">subReportUrls</tt> property: </p><pre class="programlisting">&lt;property name="subReportUrls"&gt;
    &lt;map&gt;
        &lt;entry key="ProductsSubReport"&gt;
            &lt;value&gt;/WEB-INF/reports/subReportChild.jrxml&lt;/value&gt;
        &lt;/entry&gt;
    &lt;/map&gt;
&lt;/property&gt;</pre><p> Here, the key of the <tt class="literal">Map</tt>
        corresponds to the name of the sub-report parameter in th report
        design file, and the entry is the URL of the report file. Spring will
        load this report file, compiling it if necessary, and will pass into
        the JasperReports engine under the given key.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-subreports-config-datasources"></a>13.7.4.2.&nbsp;Configuring Sub-Report Data Sources</h4></div></div><div></div></div><p>This step is entirely optional when using Spring configure your
        sub-reports. If you wish, you can still configure the data source for
        your sub-reports using static queries. However, if you want Spring to
        convert data returned in your <tt class="literal">ModelAndView</tt> into
        instances of <tt class="literal">JRDataSource</tt> then you need to specify
        which of the parameters in your <tt class="literal">ModelAndView</tt> Spring
        should convert. To do this configure the list of parameter names using
        the <tt class="literal">subReportDataKeys</tt> property of the your chosen
        view class: </p><pre class="programlisting">&lt;property name="subReportDataKeys"&gt;
    &lt;value&gt;SubReportData&lt;/value&gt;
&lt;/property&gt;</pre><p> Here, the key you supply MUST correspond to
        both the key used in your <tt class="literal">ModelAndView</tt> and the key
        used in your report design file.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-exporter-parameters"></a>13.7.5.&nbsp;Configuring Exporter Parameters</h3></div></div><div></div></div><p>If you have special requirements for exporter configuration -
      perhaps you want a specific page size for your PDF report, then you can
      configure these exporter parameters declaratively in your Spring
      configuration file using the <tt class="literal">exporterParameters</tt>
      property of the view class. The <tt class="literal">exporterParameters</tt>
      property is typed as <tt class="literal">Map</tt> and in your configuration
      the key of an entry should be the fully-qualified name of a static field
      that contains the exporter parameter definition and the value of an
      entry should be the value you want to assign to the parameter. An
      example of this is shown below: </p><pre class="programlisting">&lt;bean id="htmlReport"
          class="org.springframework.web.servlet.view.jasperreports.JasperReportsHtmlView"&gt;
  &lt;property name="url"&gt;
    &lt;value&gt;/WEB-INF/reports/simpleReport.jrxml&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="exporterParameters"&gt;
    &lt;map&gt;
      &lt;entry key="net.sf.jasperreports.engine.export.JRHtmlExporterParameter.HTML_FOOTER"&gt;
        &lt;value&gt;Footer by Spring!
          &amp;lt;/td&amp;gt;&amp;lt;td width="50%"&amp;gt;&amp;amp;nbsp; &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
          &amp;lt;/table&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
        &lt;/value&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p> Here you can see that the
      <tt class="literal">JasperReportsHtmlView</tt> is being configured with an
      exporter parameter for
      <tt class="literal">net.sf.jasperreports.engine.export.JRHtmlExporterParameter.HTML_FOOTER</tt>
      which will output a footer in the resulting HTML.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="webintegration"></a>Chapter&nbsp;14.&nbsp;Integrating with other web frameworks</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="intro"></a>14.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring can be easily integrated into any Java-based web framework.  
    All you need to do is to declare the 
    <a href="http://www.springframework.org/docs/api/org/springframework/web/context/ContextLoaderListener.html" target="_top">
    <tt class="literal">ContextLoaderListener</tt></a> in your <tt class="literal">web.xml</tt> and use a 
    <span class="emphasis"><em>contextConfigLocation</em></span> &lt;context-param&gt; to set which context files 
    to load.</p><p>The &lt;context-param&gt;: </p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>The &lt;listener&gt;: </p><pre class="programlisting">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</pre><p><span class="bold"><b>NOTE:</b></span> Listeners were added to 
    the Servlet API in version 2.3. If you have a Servlet 2.2 container, you can 
    use the <a href="http://www.springframework.org/docs/api/org/springframework/web/context/ContextLoaderServlet.html" target="_top">
    <tt class="literal">ContextLoaderServlet</tt></a> to achieve this same functionality.</p><p>If you don't specify the <span class="emphasis"><em>contextConfigLocation</em></span> 
    context parameter, the <tt class="literal">ContextLoaderListener</tt> will look 
    for a <span class="emphasis"><em>/WEB-INF/applicationContext.xml</em></span> file to load. 
    Once the context files are loaded, Spring creates a 
    <a href="http://www.springframework.org/docs/api/org/springframework/web/context/WebApplicationContext.html" target="_top">
    <tt class="literal">WebApplicationContext</tt></a> object based on the bean 
    definitions and puts it into the <tt class="literal">ServletContext</tt>.</p><p>All Java web frameworks are built on top of the Servlet API, so you 
    can use the following code to get the <tt class="literal">ApplicationContext</tt> 
    that Spring created.</p><pre class="programlisting">WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);</pre><p>The <a href="http://www.springframework.org/docs/api/org/springframework/web/context/support/WebApplicationContextUtils.html" target="_top">
    <tt class="literal">WebApplicationContextUtils</tt></a> class is for convenience, 
    so you don't have to remember the name of the <tt class="literal">ServletContext</tt> 
    attribute. Its <span class="emphasis"><em>getWebApplicationContext()</em></span> method will 
    return null if an object doesn't exist under the 
    <tt class="literal">WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</tt> 
    key. Rather than risk getting NullPointerExceptions in your application, 
    it's better to use the <span class="emphasis"><em>getRequiredWebApplicationContext()</em></span>
    method. This method throws an Exception when the 
    <span class="emphasis"><em>ApplicationContext</em></span> is missing.</p><p>Once you have a reference to the <tt class="literal">WebApplicationContext</tt>, 
    you can retrieve beans by their name or type. Most developers retrieve beans 
    by name, then cast them to one of their implemented interfaces.</p><p>Fortunately, most of the frameworks in this section have simpler 
    ways of looking up beans. Not only do they make it easy to get beans from 
    the <tt class="literal">BeanFactory</tt>, but they also allow you to use dependency 
    injection on their controllers. Each framework section has more detail on 
    its specific integration strategies.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jsf"></a>14.2.&nbsp;JavaServer Faces</h2></div></div><div></div></div><p>JavaServer Faces (JSF) is a component-based, event-driven web framework. 
    According to Sun Microsystem's <a href="http://java.sun.com/j2ee/javaserverfaces/overview.html" target="_top">
    JSF Overview</a>, JSF technology includes:</p><div class="itemizedlist"><ul type="disc"><li><p>A set of APIs for representing UI components and managing 
                their state, handling events and input validation, defining page 
                navigation, and supporting internationalization and accessibility.
   				</p></li><li><p>A JavaServer Pages (JSP) custom tag library for expressing a 
                JavaServer Faces interface within a JSP page.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-delegatingvariableresolver"></a>14.2.1.&nbsp;DelegatingVariableResolver</h3></div></div><div></div></div><p>The easiest way to integrate your Spring middle-tier with your JSF 
	    web layer is to  use the 
	    <a href="http://www.springframework.org/docs/api/org/springframework/web/jsf/DelegatingVariableResolver.html" target="_top">
		<tt class="literal">DelegatingVariableResolver</tt></a> class. To configure 
	    this variable resolver in your application, you'll need to edit your 
	    <span class="emphasis"><em>faces-context.xml</em></span>. After the opening <tt class="literal">
		&lt;faces-config&gt;</tt> element, add an <tt class="literal">&lt;application&gt;</tt> 
	    element and a <tt class="literal">&lt;variable-resolver&gt;</tt> element within it.  
	    The value of the variable resolver should reference Spring's 
	    <tt class="literal">DelegatingVariableResolver</tt>: </p><pre class="programlisting">&lt;faces-config&gt;
	    &lt;application&gt;
	        &lt;variable-resolver&gt;org.springframework.web.jsf.DelegatingVariableResolver&lt;/variable-resolver&gt;
	        &lt;locale-config&gt;
	            &lt;default-locale&gt;en&lt;/default-locale&gt;
	            &lt;supported-locale&gt;en&lt;/supported-locale&gt;
	            &lt;supported-locale&gt;es&lt;/supported-locale&gt;
	        &lt;/locale-config&gt;
	        &lt;message-bundle&gt;messages&lt;/message-bundle&gt;
	    &lt;/application&gt;</pre><p>By specifying Spring's variable resolver, you can configure Spring 
	    beans as managed properties of your managed beans. The 
	    <tt class="literal">DelegatingVariableResolver</tt> will first delegate value lookups 
	    to the default resolver of the underlying JSF implementation, and then to 
	    Spring's root <tt class="literal">WebApplicationContext</tt>. This allows you to 
	    easily inject dependencies into your JSF-managed beans.</p><p>Managed beans are defined in your <tt class="literal">faces-config.xml</tt> 
	    file. Below is an example where #{userManager} is a bean that's retrieved 
	    from Spring's <tt class="literal">BeanFactory</tt>. </p><pre class="programlisting">&lt;managed-bean&gt;
	    &lt;managed-bean-name&gt;userList&lt;/managed-bean-name&gt;
	    &lt;managed-bean-class&gt;com.whatever.jsf.UserList&lt;/managed-bean-class&gt;
	    &lt;managed-bean-scope&gt;request&lt;/managed-bean-scope&gt;
	    &lt;managed-property&gt;
	        &lt;property-name&gt;userManager&lt;/property-name&gt;
	        &lt;value&gt;#{userManager}&lt;/value&gt;
	    &lt;/managed-property&gt;
	&lt;/managed-bean&gt;</pre><p>The <tt class="literal">DelegatingVariableResolver</tt> is the recommended 
	    strategy for integrating JSF and Spring. If you're looking for more robust 
	    integration features, you might take a look at the 
		<a href="http://jsf-spring.sourceforge.net/" target="_top">JSF-Spring</a> project.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-facescontextutils"></a>14.2.2.&nbsp;FacesContextUtils</h3></div></div><div></div></div><p>A custom VariableResolver works well when mapping your properties 
	    to beans in <span class="emphasis"><em>faces-config.xml</em></span>, but at times you may need to grab a bean explicitly.  The 
		<a href="http://www.springframework.org/docs/api/org/springframework/web/jsf/FacesContextUtils.html" target="_top">
		<tt class="literal">FacesContextUtils</tt></a> class makes this easy. It's similar to 
		<tt class="literal">WebApplicationContextUtils</tt>, except that it takes a <tt class="literal">FacesContext</tt> 
		parameter rather than a <tt class="literal">ServletContext</tt> parameter.
		</p><pre class="programlisting">ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="struts"></a>14.3.&nbsp;Struts</h2></div></div><div></div></div><p><a href="http://struts.apache.org" target="_top">Struts</a> is the
    <span class="emphasis"><em>de facto</em></span> web framework for Java applications, mainly 
    because it was one of the first to be released (June 2001). Invented by 
    Craig McClanahan, Struts is an open source project hosted by the Apache 
    Software Foundation. At the time, it greatly simplified the JSP/Servlet 
    programming paradigm and won over many developers who were using 
    proprietary frameworks. It simplified the programming model, it was open 
    source, and it had a large community, which allowed the project to grow 
    and become popular among Java web developers.</p><p>To integrate your Struts application with Spring, you have two 
    options:</p><div class="itemizedlist"><ul type="disc"><li><p>Configure Spring to manage your Actions as beans, using the 
					<tt class="literal">ContextLoaderPlugin</tt>, and set their 
					dependencies in a Spring context file.</p></li><li><p>Subclass Spring's <span class="emphasis"><em>ActionSupport</em></span> 
					classes and grab your Spring-managed beans explicitly using 
					a <span class="emphasis"><em>getWebApplicationContext()</em></span> method.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="struts-contextloaderplugin"></a>14.3.1.&nbsp;ContextLoaderPlugin</h3></div></div><div></div></div><p>The <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/ContextLoaderPlugIn.html" target="_top">
        <tt class="literal">ContextLoaderPlugin</tt></a> is a Struts 1.1+ plug-in 
        that loads a Spring context file for the Struts 
        <tt class="literal">ActionServlet</tt>. This context refers to the root 
        <tt class="literal">WebApplicationContext</tt> (loaded by the 
        <tt class="literal">ContextLoaderListener</tt>) as its parent. The default 
        name of the context file is the name of the mapped servlet, plus 
        <span class="emphasis"><em>-servlet.xml</em></span>. If <tt class="literal">ActionServlet</tt> 
        is defined in web.xml as 
        <tt class="literal">&lt;servlet-name&gt;action&lt;/servlet-name&gt;</tt>, the 
        default is <span class="emphasis"><em>/WEB-INF/action-servlet.xml</em></span>.</p><p>To configure this plug-in, add the following XML to the plug-ins section near the bottom of your 
			<span class="emphasis"><em>struts-config.xml</em></span> file:
			</p><pre class="programlisting">&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"/&gt;</pre><p>The location of the context configuration files can be 
            customized using the "contextConfigLocation" property.
            </p><pre class="programlisting">&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"&gt;
    &lt;set-property property="contextConfigLocation"
        value="/WEB-INF/action-servlet.xml.xml,
               /WEB-INF/applicationContext.xml"/&gt;
&lt;/plug-in&gt;</pre><p>It is possible to use this plugin to load all your context files, which can be useful when using testing tools
        like StrutsTestCase.  StrutsTestCase's <tt class="literal">MockStrutsTestCase</tt> won't initialize Listeners on startup
        so putting all your context files in the plugin is a workaround.  A 
        <a href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1088866&amp;group_id=39190&amp;atid=424562" target="_top">
        bug has been filed</a> for this issue.</p><p>After configuring this plug-in in <span class="emphasis"><em>struts-config.xml</em></span>, you can configure your Action to be 
			managed by Spring. Spring 1.1.3 provides two ways to do this:</p><div class="itemizedlist"><ul type="disc"><li><p>Override Struts' default <tt class="literal">RequestProcessor</tt>
					with Spring's <tt class="literal">DelegatingRequestProcessor</tt>.</p></li><li><p>Use the <span class="emphasis"><em>DelegatingActionProxy</em></span> class 
					in the type attribute of your <tt class="literal">&lt;action-mapping&gt;</tt>.</p></li></ul></div><p>Both of these methods allow you to manage your Actions and 
        their dependencies in the <span class="emphasis"><em>action-context.xml</em></span> file. 
        The bridge between the Action in <span class="emphasis"><em>struts-config.xml</em></span> 
        and <span class="emphasis"><em>action-servlet.xml</em></span> is built with the 
        action-mapping's "path" and the bean's "name". If you have the 
        following in your <span class="emphasis"><em>struts-config.xml</em></span> file:
		</p><pre class="programlisting">&lt;action path="/users" .../&gt;</pre><p>You must define that Action's bean with the "/users" name in
        <span class="emphasis"><em>action-servlet.xml</em></span>:
			</p><pre class="programlisting">&lt;bean name="/users" .../&gt;</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="struts-delegatingrequestprocessor"></a>14.3.1.1.&nbsp;DelegatingRequestProcessor</h4></div></div><div></div></div><p>To configure the <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingRequestProcessor.html" target="_top">
	        <tt class="literal">DelegatingRequestProcessor</tt></a> in your 
	        <span class="emphasis"><em>struts-config.xml</em></span> file, override the "processorClass" 
	        property in the &lt;controller&gt; element. These lines follow the 
	        &lt;action-mapping&gt; element. </p><pre class="programlisting">&lt;controller&gt;
	    &lt;set-property property="processorClass" 
	        value="org.springframework.web.struts.DelegatingRequestProcessor"/&gt;
	&lt;/controller&gt;</pre><p>After adding this setting, your Action will automatically be 
	        looked up in Spring's context file, no matter what the type. In fact, 
	        you don't even need to specify a type. Both of the following snippets 
	        will work: </p><pre class="programlisting">&lt;action path="/user" type="com.whatever.struts.UserAction"/&gt;		
	&lt;action path="/user" type="com.whatever.struts.UserAction"/&gt;</pre><p>If you're using Struts' <span class="emphasis"><em>modules</em></span> feature, 
	        your bean names must contain the module prefix. For example, an action 
	        defined as <tt class="literal">&lt;action path="/user"/&gt;</tt> with module 
	        prefix "admin" requires a bean name with <tt class="literal">&lt;bean name="/admin/user"/&gt;</tt>.</p><p><span class="bold"><b>NOTE:</b></span> If you're using Tiles 
	        in your Struts application, you must configure your &lt;controller&gt;
	        with the <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingTilesRequestProcessor.html" target="_top">
			<tt class="literal">DelegatingTilesRequestProcessor</tt></a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="struts-delegatingactionproxy"></a>14.3.1.2.&nbsp;DelegatingActionProxy</h4></div></div><div></div></div><p>If you have a custom <tt class="literal">RequestProcessor</tt> and 
	        can't use the <tt class="literal">DelegatingTilesRequestProcessor</tt>, you can 
	        use the <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingActionProxy.html" target="_top">
	        <tt class="literal">DelegatingActionProxy</tt></a> as the type in your 
	        action-mapping. </p><pre class="programlisting">&lt;action path="/user" type="org.springframework.web.struts.DelegatingActionProxy"
	    name="userForm" scope="request" validate="false" parameter="method"&gt;
	        &lt;forward name="list" path="/userList.jsp"/&gt;
	        &lt;forward name="edit" path="/userForm.jsp"/&gt;
	&lt;/action&gt;</pre><p>The bean definition in <span class="emphasis"><em>action-servlet.xml</em></span> 
	        remains the same, whether you use a custom <tt class="literal">RequestProcessor</tt>
	        or the <tt class="literal">DelegatingActionProxy</tt>.</p><p>Defining your Action in a context file enables you to use 
	        Spring's IoC features, as well as instantiate new Actions for 
	        ach request. To use this feature, add <span class="emphasis"><em>singleton="false"</em></span> 
			to your action's bean definition. </p><pre class="programlisting">&lt;bean name="/user" <span class="emphasis"><em>singleton="false"</em></span> autowire="byName" 
	    class="org.appfuse.web.UserAction"/&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="struts-actionsupport"></a>14.3.2.&nbsp;ActionSupport Classes</h3></div></div><div></div></div><p>As previously mentioned, you can retrieve the
        <tt class="literal">WebApplicationContext</tt> from the <tt class="literal">ServletContext</tt>
        using the WebApplicationContextUtils class. An easier way is to extend
        Spring's Action classes for Struts. For example, instead of subclassing
        Struts' Action class, you can subclass Spring's
        <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/ActionSupport.html" target="_top">
        <tt class="literal">ActionSupport</tt></a> class.</p><p>The <tt class="literal">ActionSupport</tt> class provides additional
        convenience methods, like <span class="emphasis"><em>getWebApplicationContext()</em></span>.
        Below is an example of how you might use this in an Action:
		</p><pre class="programlisting">public class UserAction extends DispatchActionSupport {

    public ActionForward execute(ActionMapping mapping,
                                 ActionForm form,
                                 HttpServletRequest request,
                                 HttpServletResponse response)
            throws Exception {
        if (log.isDebugEnabled()) {
            log.debug("entering 'delete' method...");
        }

        WebApplicationContext ctx = getWebApplicationContext();
        UserManager mgr = (UserManager) ctx.getBean("userManager");

        // talk to manager for business logic

        return mapping.findForward("success");
    }
}</pre><p>Spring includes subclasses for all of the standard Struts Actions
    - the Spring versions merely have <span class="emphasis"><em>Support</em></span> appended to
    the name:

    </p><div class="itemizedlist"><ul type="disc" compact><li><p><a href="http://www.springframework.org/docs/api/org/springframework/web/struts/ActionSupport.html" target="_top"><tt class="literal">ActionSupport</tt></a>,</p></li><li><p><a href="http://www.springframework.org/docs/api/org/springframework/web/struts/DispatchActionSupport.html" target="_top"><tt class="literal">DispatchActionSupport</tt></a>,</p></li><li><p><a href="http://www.springframework.org/docs/api/org/springframework/web/struts/LookupDispatchActionSupport.html" target="_top"><tt class="literal">LookupDispatchActionSupport</tt></a> and</p></li><li><p><a href="http://www.springframework.org/docs/api/org/springframework/web/struts/MappingDispatchActionSupport.html" target="_top"><tt class="literal">MappingDispatchActionSupport</tt></a>.</p></li></ul></div><p>
    </p><p>The recommended strategy is to use the approach that best suits
    your project. Subclassing makes your code more readable, and you know
    exactly how your dependencies are resolved. However, using the
    <tt class="literal">ContextLoaderPlugin</tt> allow you to easily add new
    dependencies in your context XML file. Either way, Spring provides some
    nice options for integrating the two frameworks.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-tapestry"></a>14.4.&nbsp;Tapestry</h2></div></div><div></div></div><p>Tapestry is a powerful, component-oriented web application framework
    from Apache's Jakarta project (<a href="http://jakarta.apache.org/tapestry" target="_top">http://jakarta.apache.org/tapestry</a>). While Spring has its
    own powerful web ui layer, there are a number of unique advantages to
    building a J2EE application using a combination of Tapestry for the web
    ui, and the Spring container for the lower layers. This document attempts
    to detail a few best practices for combining these two frameworks. It is
    expected that you are relatively familiar with both Tapestry and Spring
    Framework basics, so they will not be explained here. General introductory
    documentation for both Tapestry and Spring Framework are available on
    their respective web sites.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tapestry-architecture"></a>14.4.1.&nbsp;Architecture</h3></div></div><div></div></div><p>A typical layered J2EE application built with Tapestry and Spring
      will consist of a top UI layer built with Tapestry, and a number of
      lower layers, hosted out of one or more Spring Application
      Contexts.</p><div class="itemizedlist"><ul type="disc"><li><p>
						<span class="emphasis"><em>User Interface Layer:</em></span>
					</p><p>- concerned with the user interface</p><p>- contains some application logic</p><p>- provided by Tapestry</p><p>- aside from providing UI via Tapestry, code in this layer
          does its work via objects which implement interfaces from the
          Service Layer. The actual objects which implement these service
          layer interfaces are obtained from a Spring Application
          Context.</p></li><li><p>
						<span class="emphasis"><em>Service Layer:</em></span>
					</p><p>- application specific 'service' code</p><p>- works with domain objects, and uses the Mapper API to get
          those domain objects into and out of some sort of repository
          (database)</p><p>- hosted in one or more Spring contexts</p><p>- code in this layer manipulates objects in the domain model,
          in an application specific fashion. It does its work via other code
          in this layer, and via the Mapper API. An object in this layer is
          given the specific mapper implementations it needs to work with, via
          the Spring context.</p><p>- since code in this layer is hosted in the Spring context, it
          may be transactionally wrapped by the Spring context, as opposed to
          managing its own transactions</p></li><li><p>
						<span class="emphasis"><em>Domain Model:</em></span>
					</p><p>- domain specific object hierarchy, which deals with data and
          logic specific to this domain</p><p>- although the domain object hierarchy is built with the idea
          that it is persisted somehow and makes some general concessions to
          this (for example, bidirectional relationships), it generally has no
          knowledge of other layers. As such, it may be tested in isolation,
          and used with different mapping implementations for production vs.
          testing.</p><p>- these objects may be standalone, or used in conjunction with
          a Spring application context to take advantage of some of the
          benefits of the context, e.g., isolation, inversion of control,
          different strategy implementations, etc.</p></li><li><p>
						<span class="emphasis"><em>Data Source Layer:</em></span>
					</p><p>- Mapper API (also called Data Access Objects): an API used to
          persist the domain model to a repository of some sort (generally a
          DB, but could be the filesystem, memory, etc.)</p><p>- Mapper API implementations: one or more specific
          implementations of the Mapper API, for example, a Hibernate-specific
          mapper, a JDO-specific mapper, JDBC-specific mapper, or a memory
          mapper.</p><p>- mapper implementations live in one or more Spring
          Application Contexts. A service layer object is given the mapper
          objects it needs to work with via the context.</p></li><li><p>
						<span class="emphasis"><em>Database, filesystem, or other
          repositories:</em></span>
					</p><p>- objects in the domain model are stored into one or more
          repositories via one or more mapper implementations</p><p>- a repository may be very simple (e.g. filesystem), or may
          have its own representation of the data from the domain model (i.e.
          a schema in a db). It does not know about other layers
          howerver.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tapestry-implementation"></a>14.4.2.&nbsp;Implementation</h3></div></div><div></div></div><p>The only real question (which needs to be addressed by this
      document), is how Tapestry pages get access to service implementations,
      which are simply beans defined in an instance of the Spring Application
      Context.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-context"></a>14.4.2.1.&nbsp;Sample application context</h4></div></div><div></div></div><p>Assume we have the following simple Application Context
        definition, in xml form: </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" 
        "http://www.springframework.org/dtd/spring-beans.dtd"&gt;
 
&lt;beans&gt;
 
    &lt;!-- ========================= GENERAL DEFINITIONS ========================= --&gt;
 
    &lt;!-- ========================= PERSISTENCE DEFINITIONS ========================= --&gt;
 
    &lt;!-- the DataSource --&gt;
    &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;&lt;value&gt;java:DefaultDS&lt;/value&gt;&lt;/property&gt;
        &lt;property name="resourceRef"&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
 
    &lt;!-- define a Hibernate Session factory via a Spring LocalSessionFactoryBean --&gt;
    &lt;bean id="hibSessionFactory" 
        class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
        &lt;property name="dataSource"&gt;&lt;ref bean="dataSource"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
 
    &lt;!--
     - Defines a transaction manager for usage in business or data access objects.
     - No special treatment by the context, just a bean instance available as reference
     - for business objects that want to handle transactions, e.g. via TransactionTemplate.
     --&gt;
    &lt;bean id="transactionManager" 
        class="org.springframework.transaction.jta.JtaTransactionManager"&gt;
    &lt;/bean&gt;
 
    &lt;bean id="mapper" 
        class="com.whatever.dataaccess.mapper.hibernate.MapperImpl"&gt;
        &lt;property name="sessionFactory"&gt;&lt;ref bean="hibSessionFactory"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
   
    &lt;!-- ========================= BUSINESS DEFINITIONS ========================= --&gt;
 
    &lt;!-- AuthenticationService, including tx interceptor --&gt;
    &lt;bean id="authenticationServiceTarget"
        class="com.whatever.services.service.user.AuthenticationServiceImpl"&gt;
        &lt;property name="mapper"&gt;&lt;ref bean="mapper"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="authenticationService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
        &lt;property name="target"&gt;&lt;ref bean="authenticationServiceTarget"/&gt;&lt;/property&gt;
        &lt;property name="proxyInterfacesOnly"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
    &lt;!-- UserService, including tx interceptor --&gt;
    &lt;bean id="userServiceTarget"
        class="com.whatever.services.service.user.UserServiceImpl"&gt;
        &lt;property name="mapper"&gt;&lt;ref bean="mapper"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="userService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
        &lt;property name="target"&gt;&lt;ref bean="userServiceTarget"/&gt;&lt;/property&gt;
        &lt;property name="proxyInterfacesOnly"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
 &lt;/beans&gt;</pre><p> Inside the Tapestry application, we need to
        load this application context, and allow Tapestry pages to get the
        authenticationService and userService beans, which implement the
        AuthenticationService and UserService interfaces, respectively.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-appctx"></a>14.4.2.2.&nbsp;Obtaining beans in Tapestry pages</h4></div></div><div></div></div><p>At this point, the application context is available to a web
        application by calling Spring's static utility function
        <tt class="literal">WebApplicationContextUtils.getApplicationContext(servletContext)</tt>,
        where servletContext is the standard <tt class="literal">ServletContext</tt>
        from the J2EE Servlet specification. As such, one simple mechanism for
        a page to get an instance of the UserService, for example, would be
        with code such as: </p><pre class="programlisting">    WebApplicationContext appContext = WebApplicationContextUtils.getApplicationContext(
        getRequestCycle().getRequestContext().getServlet().getServletContext());
    UserService userService = (UserService) appContext.getBean("userService");
    ... some code which uses UserService</pre><p> This mechanism does
        work. It can be made a lot less verbose by encapsulating most of the
        functionality in a method in the base class for the page or component.
        However, in some respects it goes against the Inversion of Control
        approach which Spring encourages, which is being used in other layers
        of this app, in that ideally you would like the page to not have to
        ask the context for a specific bean by name, and in fact, the page
        would ideally not know about the context at all.</p><p>Luckily, there is a mechanism to allow this. We rely upon the
        fact that Tapestry already has a mechanism to declaratively add
        properties to a page, and it is in fact the preferred approach to
        manage all properties on a page in this declarative fashion, so that
        Tapestry can properly manage their lifecycle as part of the page and
        component lifecycle.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-exposeappctx"></a>14.4.2.3.&nbsp;Exposing the application context to Tapestry</h4></div></div><div></div></div><p>First we need to make the <tt class="literal">ApplicationContext</tt>
        available to the Tapestry page or Component without having to have the
        <tt class="literal">ServletContext</tt>; this is because at the stage in the
        page's/component's lifecycle when we need to access the
        <tt class="literal">ApplicationContext</tt>, the
        <tt class="literal">ServletContext</tt> won't be easily available to the
        page, so we can't use
        <tt class="literal">WebApplicationContextUtils.getApplicationContext(servletContext)</tt>
        directly. One way is by defining a custom version of the Tapestry
        IEngine which exposes this for us: </p><pre class="programlisting">package com.whatever.web.xportal;
...
import ...
...
public class MyEngine extends org.apache.tapestry.engine.BaseEngine {
 
    public static final String APPLICATION_CONTEXT_KEY = "appContext";
 
    /**
     * @see org.apache.tapestry.engine.AbstractEngine#setupForRequest(org.apache.tapestry.request.RequestContext)
     */
    protected void setupForRequest(RequestContext context) {
        super.setupForRequest(context);
     
        // insert ApplicationContext in global, if not there
        Map global = (Map) getGlobal();
        ApplicationContext ac = (ApplicationContext) global.get(APPLICATION_CONTEXT_KEY);
        if (ac == null) {
            ac = WebApplicationContextUtils.getWebApplicationContext(
                context.getServlet().getServletContext()
            );
            global.put(APPLICATION_CONTEXT_KEY, ac);
        }
    }
}</pre><p>This engine class places the Spring Application Context as
        an attribute called "appContext" in this Tapestry app's 'Global'
        object. Make sure to register the fact that this special IEngine
        instance should be used for this Tapestry application, with an entry
        in the Tapestry application definition file. For example:
        </p><pre class="programlisting">file: xportal.application:
 
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE application PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
&lt;application
    name="Whatever xPortal"
    engine-class="com.whatever.web.xportal.MyEngine"&gt;
&lt;/application&gt;</pre><p>
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-componentdefs"></a>14.4.2.4.&nbsp;Component definition files</h4></div></div><div></div></div><p>Now in our page or component definition file (*.page or *.jwc),
        we simply add property-specification elements to grab the beans we
        need out of the ApplicationContext, and create page or component
        properties for them. For example: </p><pre class="programlisting">    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;</pre><p> The OGNL expression
        inside the property-specification specifies the initial value for the
        property, as a bean obtained from the context. The entire page
        definition might look like this: </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE page-specification PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
     
&lt;page-specification class="com.whatever.web.xportal.pages.Login"&gt;
 
    &lt;property-specification name="username" type="java.lang.String"/&gt;
    &lt;property-specification name="password" type="java.lang.String"/&gt;
    &lt;property-specification name="error" type="java.lang.String"/&gt;
    &lt;property-specification name="callback" type="org.apache.tapestry.callback.ICallback" persistent="yes"/&gt;
    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;
   
    &lt;bean name="delegate" class="com.whatever.web.xportal.PortalValidationDelegate"/&gt;
 
    &lt;bean name="validator" class="org.apache.tapestry.valid.StringValidator" lifecycle="page"&gt;
        &lt;set-property name="required" expression="true"/&gt;
        &lt;set-property name="clientScriptingEnabled" expression="true"/&gt;
    &lt;/bean&gt;
 
    &lt;component id="inputUsername" type="ValidField"&gt;
        &lt;static-binding name="displayName" value="Username"/&gt;
        &lt;binding name="value" expression="username"/&gt;
        &lt;binding name="validator" expression="beans.validator"/&gt;
    &lt;/component&gt;
   
    &lt;component id="inputPassword" type="ValidField"&gt;
        &lt;binding name="value" expression="password"/&gt;
       &lt;binding name="validator" expression="beans.validator"/&gt;
       &lt;static-binding name="displayName" value="Password"/&gt;
       &lt;binding name="hidden" expression="true"/&gt;
    &lt;/component&gt;
 
&lt;/page-specification&gt;</pre><p>
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-getters"></a>14.4.2.5.&nbsp;Adding abstract accessors</h4></div></div><div></div></div><p>Now in the Java class definition for the page or component
        itself, all we need to do is add an abstract getter method for the
        properties we have defined, to access them. When the page or component
        is actually loaded by Tapestry, it performs runtime code
        instrumentation on the classfile to add the properties which have been
        defined, and hook up the abstract getter methods to the newly created
        fields. For example: </p><pre class="programlisting">    // our UserService implementation; will come from page definition
    public abstract UserService getUserService();
    // our AuthenticationService implementation; will come from page definition
    public abstract AuthenticationService getAuthenticationService();</pre><p>
        For completeness, the entire Java class, for a login page in this
        example, might look like this: </p><pre class="programlisting">package com.whatever.web.xportal.pages;
 
/**
 *  Allows the user to login, by providing username and password.
 *  After successfully logging in, a cookie is placed on the client browser
 *  that provides the default username for future logins (the cookie
 *  persists for a week).
 */
public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {
 
    /** the key under which the authenticated user object is stored in the visit as */
    public static final String USER_KEY = "user";
   
    /**
     * The name of a cookie to store on the user's machine that will identify
     * them next time they log in.
     **/
    private static final String COOKIE_NAME = Login.class.getName() + ".username";  
    private final static int ONE_WEEK = 7 * 24 * 60 * 60;
 
    // --- attributes
 
    public abstract String getUsername();
    public abstract void setUsername(String username);
 
    public abstract String getPassword();
    public abstract void setPassword(String password);
 
    public abstract ICallback getCallback();
    public abstract void setCallback(ICallback value);
    
    public abstract UserService getUserService();
 
    public abstract AuthenticationService getAuthenticationService();
 
    // --- methods
 
    protected IValidationDelegate getValidationDelegate() {
        return (IValidationDelegate) getBeans().getBean("delegate");
    }
 
    protected void setErrorField(String componentId, String message) {
        IFormComponent field = (IFormComponent) getComponent(componentId);
        IValidationDelegate delegate = getValidationDelegate();
        delegate.setFormComponent(field);
        delegate.record(new ValidatorException(message));
    }
 
    /**
     *  Attempts to login. 
     *
     *  &lt;p&gt;If the user name is not known, or the password is invalid, then an error
     *  message is displayed.
     *
     **/
    public void attemptLogin(IRequestCycle cycle) {
     
        String password = getPassword();
 
        // Do a little extra work to clear out the password.
 
        setPassword(null);
        IValidationDelegate delegate = getValidationDelegate();
 
        delegate.setFormComponent((IFormComponent) getComponent("inputPassword"));
        delegate.recordFieldInputValue(null);
 
        // An error, from a validation field, may already have occurred.
 
        if (delegate.getHasErrors())
            return;
 
        try {
            User user = getAuthenticationService().login(getUsername(), getPassword());
           loginUser(user, cycle);
        }
        catch (FailedLoginException ex) {
            this.setError("Login failed: " + ex.getMessage());
            return;
        }
    }
 
    /**
     *  Sets up the {@link User} as the logged in user, creates
     *  a cookie for their username (for subsequent logins),
     *  and redirects to the appropriate page, or
     *  a specified page).
     *
     **/
    public void loginUser(User user, IRequestCycle cycle) {
     
        String username = user.getUsername();
 
        // Get the visit object; this will likely force the
        // creation of the visit object and an HttpSession.
 
        Map visit = (Map) getVisit();
        visit.put(USER_KEY, user);
 
        // After logging in, go to the MyLibrary page, unless otherwise
        // specified.
 
        ICallback callback = getCallback();
 
        if (callback == null)
            cycle.activate("Home");
        else
            callback.performCallback(cycle);
 
        // I've found that failing to set a maximum age and a path means that
        // the browser (IE 5.0 anyway) quietly drops the cookie.
 
        IEngine engine = getEngine();
        Cookie cookie = new Cookie(COOKIE_NAME, username);
        cookie.setPath(engine.getServletPath());
        cookie.setMaxAge(ONE_WEEK);
 
        // Record the user's username in a cookie
 
        cycle.getRequestContext().addCookie(cookie);
 
        engine.forgetPage(getPageName());
    }
   
    public void pageBeginRender(PageEvent event) {
        if (getUsername() == null)
            setUsername(getRequestCycle().getRequestContext().getCookieValue(COOKIE_NAME));
    }
}</pre><p>
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tapestry-summary"></a>14.4.3.&nbsp;Summary</h3></div></div><div></div></div><p>In this example, we've managed to allow service beans defined in
      the Spring <tt class="literal">ApplicationContext</tt> to be provided to the
      page in a declarative fashion. The page class does not know where the
      service implementations are coming from, and in fact it is easy to slip
      in another implementation, for example, during testing. This inversion
      of control is one of the prime goals and benefits of the Spring
      Framework, and we have managed to extend it all the way up the J2EE
      stack in this Tapestry application.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webwork"></a>14.5.&nbsp;WebWork</h2></div></div><div></div></div><p><a href="http://www.opensymphony.com/webwork" target="_top">WebWork</a>
    is a web framework designed with simplicity in mind. It's built on top of 
    <a href="http://www.opensymphony.com/xwork" target="_top">XWork</a>, which is a 
    generic command framework. XWork also has an IoC container, but it isn't 
    as full-featured as Spring and won't be covered in this section. WebWork 
    controllers are called Actions, mainly because they must implement the 
    <a href="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/Action.html" target="_top">
    <tt class="literal">Action</tt></a> interface. The 
    <a href="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/ActionSupport.html" target="_top">
    <tt class="literal">ActionSupport</tt></a> class implements this interface, 
    and it is most common parent class for WebWork actions.</p><p>WebWork maintains its own Spring integration project, located on 
    java.net in the <a href="https://xwork-optional.dev.java.net/" target="_top">
    xwork-optional</a> project. Currently, three options are available for 
    integrating WebWork with Spring:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b>SpringObjectFactory</b></span>: 
            override XWork's default 
            <a href="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/ObjectFactory.html" target="_top">
            <tt class="literal">ObjectFactory</tt></a> so XWork will look for 
            Spring beans in the root <tt class="literal">WebApplicationContext</tt>.</p></li><li><p><span class="bold"><b>ActionAutowiringInterceptor:</b></span> 
            use an interceptor to  automatically wire an Action's dependencies 
            as they're created.</p></li><li><p><span class="bold"><b>SpringExternalReferenceResolver:</b></span> 
            look up Spring beans based on the name defined in an &lt;external-ref&gt; 
            element of an &lt;action&gt; element.</p></li></ul></div><p>All of these strategies are explained in further detail in 
    <a href="http://wiki.opensymphony.com/display/WW/WebWork+2+Spring+Integration" target="_top">
    WebWork's Documentation</a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e9685"></a>Chapter&nbsp;15.&nbsp;JMS</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9688"></a>15.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring provides a JMS abstraction framework that simplifies
    the use of the JMS API and shields the user from differences between
    the JMS 1.0.2 and 1.1 APIs.
    </p><p>JMS can be roughly divided into two areas of
    functionality, production and consumption of messages.  In a
    J2EE environment, the ability to consume messages 
    asynchronously is provided for by message-driven beans while in a
    standalone application this is provided for by the creation 
    of MessageListeners or ConnectionConsumers.  The functionality 
    in JmsTemplate is focused on producing messages.  Future releases
    of Spring will address asynchronous message consumption in a standalone 
    environment.
    </p><p>The package <tt class="literal">org.springframework.jms.core</tt> provides 
    the core functionality for using JMS.  
    It contains JMS template classes 
    that simplifies the use of the JMS by handling the creation and release 
    of resources, much like the <tt class="literal">JdbcTemplate</tt> does for JDBC.  

    The design principal common to Spring template classes is to
    provide helper methods to perform common operations and for more
    sophisticated usage, delegate the essence of the processing 
    task to user implemented callback interfaces.  The JMS template
    follows the same design.  The classes offer various convenience methods 
    for the sending of messages, consuming a message synchronously, and 
    exposing the JMS session and message producer to the user.
    </p><p>
    The package <tt class="literal">org.springframework.jms.support</tt>
    provides JMSException translation functionality.  The translation
    converts the checked JMSException hierarchy to a mirrored hierarchy 
    of unchecked exceptions.  If there are any provider specific subclasses 
    of the checked javax.jms.JMSException, this exception is wrapped in the 
    unchecked UncategorizedJmsException.
    The package <tt class="literal">org.springframework.jms.support.converter</tt>
    provides a MessageConverter abstraction to convert between
    Java objects and JMS messages.  The package 
    <tt class="literal">org.springframework.jms.support.destination</tt> provides
    various strategies for managing JMS destinations, such as providing
    a service locator for destinations stored in JNDI.
    </p><p>Finally, the package
    <tt class="literal">org.springframework.jms.connection</tt>
    provides an implementation of the ConnectionFactory suitable for use
    in standalone applications.  It also contains an implementation
    of Spring's <tt class="literal">PlatformTransactionManager</tt>
    for JMS.  This allows for integration of JMS as a transactional
    resource into Spring's transaction management mechanisms.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9722"></a>15.2.&nbsp;Domain unification</h2></div></div><div></div></div><p>There are two major releases of the JMS specification, 1.0.2 
    and 1.1.  JMS 1.0.2 defined two types of messaging domains, 
    point-to-point (Queues) and publish/subscribe (Topics).
    The 1.0.2 API reflected these two
    messaging domains by providing a parallel class hierarchy for each domain.
    Consequentially, a client application was domain specific in the use of
    the JMS API.  JMS 1.1 introduced the concept of domain unification 
    that minimized both the functional differences and client API 
    differences between the two domains.  As an example of a functional 
    difference that was removed, if you use a JMS 1.1 provider you can 
    transactionally consume a message from one domain and produce a message
    on the other using the same <tt class="literal">Session</tt>.
    </p><p>The JMS 1.1 specification was released in April 2002 and
    incorporated as part of J2EE 1.4 in November 2003.
    As a result, most application servers that are currently in use 
    are only required to support JMS 1.0.2.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9732"></a>15.3.&nbsp;JmsTemplate</h2></div></div><div></div></div>
    Two implementations of the JmsTemplate are provided.  The class
    <tt class="literal">JmsTemplate</tt> uses the JMS 1.1 API and the
    subclass <tt class="literal">JmsTemplate102</tt> uses the JMS 1.0.2 API.
    <p>Code that uses the JmsTemplate only needs to implement callback
    interfaces giving them a clearly defined contract.  The 
    <tt class="literal">MessageCreator</tt> callback interface creates a message
    given a Session provided by the calling code in JmsTemplate.
    In order to allow
    for more complex usage of the JMS API, the callback  
    <tt class="literal">SessionCallback</tt> provides the user with the JMS
    session and the callback <tt class="literal">ProducerCallback</tt> exposes
    a Session and MessageProducer pair.
    </p><p>
    The JMS API exposes two types of send methods, one that takes 
    delivery mode, priority, and time-to-live as quality of service 
    (QOS) parameters and one that takes no QOS parameters which uses
    default values.  Since there are many send methods in JmsTemplate, 
    the setting of the QOS parameters have been exposed as bean
    properties to avoid duplication in the number 
    of send methods.  Similarly, the timeout value for
    synchronous receive calls is set using the property
    <tt class="literal">setReceiveTimeout</tt>.
    </p><p>
    Some JMS providers allow the setting of default QOS
    values administratively through the configuration of the 
    ConnectionFactory.
    This has the effect that a call to MessageProducer's send method
    <tt class="literal">send(Destination destination, Message message)</tt>
    will use QOS different default values than those specified in the
    JMS specification.   Therefore, in order to provide consistent
    management of QOS values, the JmsTemplate must be specifically
    enabled to use its own QOS values by setting the boolean property
    <tt class="literal">isExplicitQosEnabled</tt> to true.  
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9766"></a>15.3.1.&nbsp;ConnectionFactory</h3></div></div><div></div></div><p>The JmsTemplate requires a reference to 
      a <tt class="literal">ConnectionFactory</tt>.  
      The <tt class="literal">ConnectionFactory</tt> is part of the JMS
      specification and serves as the entry point for working with JMS.
      It is used by the client application as a factory to 
      create connections with the JMS provider and encapsulates various 
      configuration parameters, many of which are vendor specific such 
      as SSL configuration options.
      </p><p>
      When using JMS inside an EJB the vendor provides implementations
      the JMS interfaces so that they can participate in declarative
      transaction management and perform pooling of connections
      and session.  In order to use this implementation, 
      J2EE containers typically require that you declare a 
      JMS connection factory as a <tt class="literal">resource-ref</tt>
      inside the EJB or servlet deployment descriptors.  To ensure
      the use of these features with the JmsTemplate inside an EJB,
      the client application should ensure that it references the managed 
      implementation of the ConnectionFactory. 
      </p><p>Spring provides an implementation of the ConnectionFactory
      interface, <tt class="literal">SingleConnectionFactory</tt>, that 
      will return the same Connection on all
      <tt class="literal">createConnection</tt> calls and ignore calls
      to <tt class="literal">close.</tt>  This is useful for testing and
      standalone environments so that the same connection can be
      used for multiple JmsTemplate calls that may span any number of
      transactions.  SingleConnectionFactory takes a reference to
      a standard ConnectionFactory that would typically comes from JNDI.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9793"></a>15.3.2.&nbsp;Transaction Management</h3></div></div><div></div></div><p>Spring provides a <tt class="literal">JmsTransactionManager</tt> 
      that manages transactions for a single JMS ConnectionFactory.  
      This allows JMS applications to leverage the managed transaction 
      features of Spring as described in <tt class="literal">Chapter 7</tt>.
      The <tt class="literal">JmsTransactionManager</tt> binds a Connection/Session
      pair from the specified ConnectionFactory to the thread.  However,
      in a J2EE environment the ConnectionFactory will pool connections 
      and sessions, so the instances that are bound to the thread depend
      on the pooling behavior.  In a standalone environment, using Spring's
      <tt class="literal">SingleConnectionFactory</tt> will result in a 
      using a single JMS Connection and each transaction having its own
      Session.  The <tt class="literal">JmsTemplate</tt> can also be used with 
      the <tt class="literal">JtaTransactionManager</tt> and an XA-capable
      JMS ConnectionFactory for performing distributed transactions.
      </p><p>Reusing code across a managed and unmanaged transactional 
      environment can be confusing when using JMS API to create
      a <tt class="literal">Session</tt> from a Connection.
      This is because the JMS API only has only one 
      factory method to create a Session and it requires values for 
      the transaction and acknowledgement modes.  In a managed environment, 
      setting these values in the responsibility of the environments
      transactional infrastructure, so these values are ignored by the 
      vendor's wrapper to the JMS Connection.
      When using the <tt class="literal">JmsTemplate</tt> in an unmanaged
      environment you can specify these values
      though the use of the properties <tt class="literal">SessionTransacted</tt>
      and <tt class="literal">SessionAcknowledgeMode</tt>.
      When using a <tt class="literal">PlatformTransactionManager</tt> with 
      <tt class="literal">JmsTemplate</tt>, the template will always be
      given a transactional JMS Session.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9836"></a>15.3.3.&nbsp;Destination Management</h3></div></div><div></div></div><p>Destinations, like ConnectionFactories, are JMS administered
      objects that can be stored and retrieved in JNDI.  When
      configuring a Spring application context one can use the
      JNDI factory class <tt class="literal">JndiObjectFactoryBean</tt> to
      perform dependency injection on your object's references to
      JMS destinations.  However, often this strategy is cumbersome if
      there are a large number of destinations in the application or if there
      are advanced destination management features unique to the JMS provider.
      Examples of such advanced destination management would be the
      creation of dynamic destinations or support for a hierarchical 
      namespace of destinations.
      The JmsTemplate delegates the resolution of a destination name
      to a JMS destination object to an implementation of the 
      interface <tt class="literal">DestinationResolver</tt>.
      <tt class="literal">DynamicDestinationResolver</tt> is the
      default implementation used by <tt class="literal">JmsTemplate</tt> and
      accommodates resolving dynamic destinations.  
      A <tt class="literal">JndiDestinationResolver</tt> is also provided that
      acts as a service locator for destinations contained in JNDI and 
      optionally falls back to the behavior contained in 
      <tt class="literal">DynamicDestinationResolver</tt>. 
      </p><p>Quite often the destinations used in a JMS application are only 
      known at runtime and therefore can not be administratively created 
      when the application is deployed.  This is often because there is 
      shared application logic between interacting system components that 
      create destinations at runtime according to a well known naming 
      convention.  Even though the creation of dynamic destinations
      are not part of the JMS specification, 
      most vendors have provided this functionality.
      Dynamic destinations are created with
      a name defined by the user which differentiates them from temporary
      destinations and are often not registered in JNDI.  
      The API used to create dynamic destinations varies from provider to
      provider since the properties associated with the destination are
      vendor specific.  However, a simple implementation choice that is
      sometimes made by vendors is to disregard the warnings in the JMS
      specification and to use the <tt class="literal">TopicSession</tt> method 
      <tt class="literal">createTopic(String topicName)</tt> or the 
      <tt class="literal">QueueSession</tt> method 
      <tt class="literal">createQueue(String queueName)</tt>
      to create a new destination with default destination properties.
      Depending on the vendor implementation, 
      <tt class="literal">DynamicDestinationResolver</tt> may then also 
      create a physical destination instead of only resolving one.
      </p><p>The boolean property <tt class="literal">PubSubDomain</tt> is used 
      to configure the <tt class="literal">JmsTemplate</tt>
      with knowledge of what JMS domain is being used.  By default the
      value of this property is false, indicating that the point-to-point
      domain, Queues, will be used.  In the 1.0.2 implementation the value
      of this property determines if the JmsTemplate's send operations will
      send a message to a Queue or to a Topic.  This flag has no effect on send
      operations for the 1.1 implementation.  However, in both implementations,
      this property determines the behavior of resolving dynamic 
      destination via implementations of 
      <tt class="literal">DestinationResolver</tt>.
      </p><p>You can also configure the JmsTemplate with a default destination
      via the property <tt class="literal">DefaultDestination</tt>.  The default
      destination will be used with send and receive operations that do not 
      refer to a specific destination.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9892"></a>15.4.&nbsp;Using the JmsTemplate</h2></div></div><div></div></div><p>To get started using the JmsTemplate you need to select either the
    JMS 1.0.2 implementation <tt class="literal">JmsTemplate102</tt> or the
    JMS 1.1 implementation <tt class="literal">JmsTemplate</tt>.  Check your
    JMS provider to determine what version is supported.  
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9903"></a>15.4.1.&nbsp;Sending a message</h3></div></div><div></div></div><p>The JmsTemplate contains many convenience methods to send a message.
      There are send methods that specify the destination using a 
      <tt class="literal">javax.jms.Destination</tt> object and those that
      specify the destination using a string for use in a JNDI lookup.
      The send method that takes no destination argument uses the
      default destination.  Here is an example that sends a message to 
      a queue using the 1.0.2 implementation.
      </p><pre class="programlisting">import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
import org.springframework.jms.core.MessageCreator;

public class JmsQueueSender {

  private JmsTemplate jt;

  private ConnectionFactory connFactory;

  private Queue queue;

  public void simpleSend() {
    jt = new JmsTemplate102(connFactory, false);
    jt.send(queue, new MessageCreator() {
      public Message createMessage(Session session) throws JMSException {
        return session.createTextMessage("hello queue world");
      }
    });
  }

  public void setConnectionFactory(ConnectionFactory cf) {
      connFactory = cf;
  }

  public void setQueue(Queue q) {
      queue = q;
  }

}
      </pre><p>This example uses the <tt class="literal">MessageCreator</tt> callback 
      to create a text message from the supplied Session object and the
      JmsTemplate is constructed by passing a reference to a ConnectionFactory
      and a boolean specifying the messaging domain.
      A zero argument constructor and a setConnectionFactory/Queue method are 
      also provided and can be used for constructing the instance using
      a BeanFactory.  The method simpleSend modified to send to a topic 
      instead of a queue is shown below
      </p><pre class="programlisting">
public void simpleSend() {
  jt = new JmsTemplate102(connFactory, true);
  jt.send(topic, new MessageCreator() {
     public Message createMessage(Session session) throws JMSException {
        return session.createTextMessage("hello topic world");
     }
  });
}     
      </pre><p>When configuring the 1.0.2 in an application context
      it is important to remember setting the value of the 
      boolean property <tt class="literal">PubSubDomain</tt> property in order
      to indicate if you want to send to Queues or Topics.
      </p><p>The method 
      <tt class="literal">send(String destinationName, MessageCreator c)</tt>
      lets you send to a message using the string name of the destination.
      If these names are registered in JNDI, you should set
      the <tt class="literal">DestinationResolver</tt> property of the template
      to an instance of <tt class="literal">JndiDestinationResolver</tt>.
      </p><p>If you created the JmsTemplate and specified a default 
      destination, the <tt class="literal">send(MessageCreator c)</tt>
      sends a message to that destination.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9941"></a>15.4.2.&nbsp;Synchronous Receiving</h3></div></div><div></div></div><p>While JMS is typically associated with asynchronous processing, it
      is possible to consume messages synchronously.  The overloaded
      <tt class="literal">receive</tt> methods provide this functionality.
      During a synchronous receive the calling thread blocks until a 
      message becomes available.  This can be a dangerous operation since
      the calling thread can potentially be blocked indefinitely.  The
      property <tt class="literal">receiveTimeout</tt> specifies how long
      the receiver should wait before giving up waiting for a message.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9952"></a>15.4.3.&nbsp;Using Message Converters</h3></div></div><div></div></div><p>In order to facilitate the sending 
      of domain model objects the <tt class="literal">JmsTemplate</tt> 
      has various send methods that take a Java object as an argument 
      for a message's  data content.  
      The overloaded methods 
      <tt class="literal">convertAndSend</tt> and 
      <tt class="literal">receiveAndConvert</tt> in
      <tt class="literal">JmsTemplate</tt> delegate the conversion process to
      an instance of the <tt class="literal">MessageConverter</tt> interface.
      This interface defines a simple contract to convert between
      Java objects and JMS messages. The default
      implementation, <tt class="literal">SimpleMessageConverter</tt> 
      supports conversion between <tt class="literal">String</tt> and 
      <tt class="literal">TextMessage</tt>, <tt class="literal">byte[]</tt> and
      <tt class="literal">BytesMesssage</tt>, and <tt class="literal">java.util.Map</tt>
      and <tt class="literal">MapMessage</tt>.
      By using the converter, you
      your application code can focus on the business object that is 
      being sent or received via JMS and not bother with the details of 
      how it is represented as a JMS  message.  
      </p><p>
      The sandbox currently includes a 
      <tt class="literal">MapMessageConverter</tt> which uses reflection
      to convert between a JavaBean and a MapMessage.  
      Other popular implementations choices you might implement yourself
      are Converters that bust an existing XML marshalling packages, such as 
      JAXB, Castor, XMLBeans, or XStream, to create a TextMessage 
      representing the object.  
      </p><p>To accommodate the setting of a message's properties, 
      headers, and body that can not be generically encapsulated inside 
      a converter class, the interface <tt class="literal">MessagePostProcessor</tt>
      gives you access to the message after it has been converted, but before
      it is sent.  The example below shows how to modify a message header and 
      a property after a <tt class="literal">java.util.Map</tt> is
      converted to a message.
      </p><pre class="programlisting">
public void sendWithConversion() {
    Map m = new HashMap();
    m.put("Name", "Mark");
    m.put("Age", new Integer(35));
    jt.convertAndSend("testQueue", m, new MessagePostProcessor() {

         public Message postProcessMessage(Message message)
            throws JMSException {
            message.setIntProperty("AccountID", 1234);
            message.setJMSCorrelationID("123-00001");

            return message;
        }
    });
}
      </pre><p>This results in a message of the form
      </p><pre class="programlisting">
MapMessage={ 
  Header={ 
    ... standard headers ...
    CorrelationID={123-00001} 
  } 
  Properties={ 
    AccountID={Integer:1234}
  } 
  Fields={ 
    Name={String:Mark} 
    Age={Integer:35} 
  } 
}
      </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10012"></a>15.4.4.&nbsp;SessionCallback and ProducerCallback</h3></div></div><div></div></div><p>
        While the send operations cover many common usage scenarios, there
        are cases when you want to perform multiple operations on a
        JMS Session or MessageProducer.  The <tt class="literal">SessionCallback</tt>
        and <tt class="literal">ProducerCallback</tt> expose the JMS Session
        and Session/MessageProducer pair respectfully.  The 
        <tt class="literal">execute()</tt> methods on JmsTemplate execute these
        callback methods.
        </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ejb"></a>Chapter&nbsp;16.&nbsp;Accessing and implementing EJBs</h2></div></div><div></div></div><p>As a lightweight container, Spring is often considered an EJB
  replacement. We do believe that for many if not most applications and use
  cases, Spring as a container, combined with its rich supporting
  functionality in the area of transactions, ORM and JDBC access, is a better
  choice than implementing equivalent functionality via an EJB container and
  EJBs.</p><p>However, it is important to note that using Spring does not prevent
  you from using EJBs. In fact, Spring makes it much easier to access EJBs and
  implement EJBs and functionality within them. Additionally, using Spring to
  access services provided by EJBs allows the implementation of those services
  to later transparently be switched between local EJB, remote EJB, or POJO
  (plain java object) variants, without the client code client code having to
  be changed.</p><p>In this chapter, we look at how Spring can help you access and
  implement EJBs. Spring provides particular value when accessing stateless
  session beans (SLSBs), so we'll begin by discussing this.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ejb-access"></a>16.1.&nbsp;Accessing EJBs</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-concepts"></a>16.1.1.&nbsp;Concepts</h3></div></div><div></div></div><p>To invoke a method on a local or remote stateless session bean,
      client code must normally perform a JNDI lookup to obtain the (local or
      remote) EJB Home object, then use a 'create' method call on that object
      to obtain the actual (local or remote) EJB object. One or more methods
      are then invoked on the EJB.</p><p>To avoid repeated low-level code, many EJB applications use the
      Service Locator and Business Delegate patterns. These are better than
      spraying JNDI lookups throughout client code, but their usual
      implementations have significant disadvantages. For example:</p><div class="itemizedlist"><ul type="disc"><li><p>Typically code using EJBs depends on Service Locator or
          Business Delegate singletons, making it hard to test</p></li><li><p>In the case of the Service Locator pattern used without a
          Business Delegate, application code still ends up having to invoke
          the create() method on an EJB home, and deal with the resulting
          exceptions. Thus it remains tied to the EJB API and the complexity
          of the EJB programming model.</p></li><li><p>Implementing the Business Delegate pattern typically results
          in significant code duplication, where we have to write numerous
          methods that simply call the same method on the EJB.</p></li></ul></div><p>The Spring approach is to allow the creation and use of proxy
      objects, normally configured inside a Spring ApplicationContext or
      BeanFactory, which act as code-less business delegates. You do not need
      to write another Service Locator, another JNDI lookup, or duplicate
      methods in a hand-coded Business Delegate unless you&#8217;re adding real
      value.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-local"></a>16.1.2.&nbsp;Accessing local SLSBs</h3></div></div><div></div></div><p>Assume that we have a web controller that needs to use a local
      EJB. We&#8217;ll follow best practice and use the EJB Business Methods
      Interface pattern, so that the EJB&#8217;s local interface extends a non
      EJB-specific business methods interface. Let&#8217;s call this business
      methods interface MyComponent.</p><pre class="programlisting">public interface MyComponent {
    ...
}</pre><p>(One of the main reasons to the Business Methods Interface pattern
      is to ensure that synchronization between method signatures in local
      interface and bean implementation class is automatic. Another reason is
      that it later makes it much easier for us to switch to a POJO (plain
      java object) implementation of the service if it makes sense to do so)
      Of course we&#8217;ll also need to implement the local home interface and
      provide a bean implementation class that implements SessionBean and the
      MyComponent business methods interface. Now the only Java coding we&#8217;ll
      need to do to hook up our web tier controller to the EJB implementation
      is to expose a setter method of type MyComponent on the controller. This
      will save the reference as an instance variable in the
      controller:</p><pre class="programlisting">private MyComponent myComponent;

public void setMyComponent(MyComponent myComponent) {
    this.myComponent = myComponent;
}</pre><p>We can subsequently use this instance variable in any business
      method in the controller. Now assuming we are obtaining our controller
      object out of a Spring ApplicationContext or BeanFactory, we can in the
      same context configure a
      <tt class="literal">LocalStatelessSessionProxyFactoryBean</tt> instance, which
      will be EJB proxy object. The configuration of the proxy, and setting of
      the <tt class="literal">myComponent</tt> property of the controller is done
      with a configuration entry such as:</p><pre class="programlisting">&lt;bean id="myComponent"
      class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
    &lt;property name="jndiName"&gt;&lt;value&gt;myComponent&lt;/value&gt;&lt;/property&gt;
    &lt;property name="businessInterface"&gt;&lt;value&gt;com.mycom.MyComponent&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="myController" class = "com.mycom.myController"&gt;
    &lt;property name="myComponent"&gt;&lt;ref bean="myComponent"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>There&#8217;s a lot of magic happening behind the scenes, courtesy of
      the Spring AOP framework, although you aren&#8217;t forced to work with AOP
      concepts to enjoy the results. The <tt class="literal">myComponent</tt> bean
      definition creates a proxy for the EJB, which implements the business
      method interface. The EJB local home is cached on startup, so there&#8217;s
      only a single JNDI lookup. Each time the EJB is invoked, the proxy
      invokes the create() method on the local EJB and invokes the
      corresponding business method on the EJB.</p><p>The <tt class="literal">myController</tt> bean definition sets the
      <tt class="literal">myController</tt> property of the controller class to this
      proxy.</p><p>This EJB access mechanism delivers huge simplification of
      application code: The web tier code (or other EJB client code) has no
      dependence on the use of EJB. If we want to replace this EJB reference
      with a POJO or a mock object or other test stub, we could simply change
      the myComponent bean definition without changing a line of Java code.
      Additionally, we haven&#8217;t had to write a single line of JNDI lookup or
      other EJB plumbing code as part of our application.</p><p>Benchmarks and experience in real applications indicate that the
      performance overhead of this approach (which involves reflective
      invocation of the target EJB) is minimal, and undetectable in typical
      use. Remember that we don&#8217;t want to make fine-grained calls to EJBs
      anyway, as there&#8217;s a cost associated with the EJB infrastructure in the
      application server.</p><p>There is one caveat with regards to the JNDI lookup. In a bean
      container, this class is normally best used as a singleton (there simply
      is no reason to make it a prototype). However, if that bean container
      pre-instantiates singletons (as do the XML ApplicationContext variants)
      you may have a problem if the bean container is loaded before the EJB
      container loads the target EJB. That is because the JNDI lookup will be
      performed in the init method of this class and cached, but the EJB will
      not have been bound at the target location yet. The solution is to not
      pre-instantiate this factory object, but allow it to be created on first
      use. In the XML containers, this is controlled via the
      <tt class="literal">lazy-init</tt> attribute.</p><p>Although this will not be of interest to the majority of Spring
      users, those doing programmatic AOP work with EJBs may want to look at
      <tt class="literal">LocalSlsbInvokerInterceptor</tt>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-remote"></a>16.1.3.&nbsp;Accessing remote SLSBs</h3></div></div><div></div></div><p>Accessing remote EJBs is essentially identical to accessing local
      EJBs, except that the
      <tt class="literal">SimpleRemoteStatelessSessionProxyFactoryBean</tt> is used.
      Of course, with or without Spring, remote invocation semantics apply; a
      call to a method on an object in another VM in another computer does
      sometimes have to be treated differently in terms of usage scenarios and
      failure handling.</p><p>Spring's EJB client support adds one more advantage over the
      non-Spring approach. Normally it is problematic for EJB client code to
      be easily switched back and forth between calling EJBs locally or
      remotely. This is because the remote interface methods must declare that
      they throw <tt class="literal">RemoteException</tt>, and client code must deal
      with this, while the local interface methods don't. Client code
      written for local EJBs which needs to be moved to remote EJBs
      typically has to be modified to add handling for the remote exceptions,
      and client code written for remote EJBs which needs to be moved to local
      EJBs, can either stay the same but do a lot of unnecessary handling of
      remote exceptions, or needs to be modified to remove that code. With the
      Spring remote EJB proxy, you can instead not declare any thrown
      <tt class="literal">RemoteException</tt> in your Business Method Interface and
      implementing EJB code, have a remote interface which is identical except
      that it does throw <tt class="literal">RemoteException</tt>, and rely on the
      proxy to dynamically treat the two interfaces as if they were the same.
      That is, client code does not have to deal with the checked
      <tt class="literal">RemoteException</tt> class. Any actual
      <tt class="literal">RemoteException</tt> that is thrown during the EJB
      invocation will be re-thrown as the non-checked
      <tt class="literal">RemoteAccessException</tt> class, which is a subclass of
      <tt class="literal">RuntimeException</tt>. The target service can then be
      switched at will between a local EJB or remote EJB (or even plain Java
      object) implementation, without the client code knowing or caring. Of
      course, this is optional; there is nothing stopping you from declaring
      <tt class="literal">RemoteExceptions</tt> in your business interface.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ejb-implementation"></a>16.2.&nbsp;Using Spring convenience EJB implementation classes</h2></div></div><div></div></div><p>Spring also provides convenience classes to help you implement EJBs.
    These are designed to encourage the good practice of putting business
    logic behind EJBs in POJOs, leaving EJBs responsible for transaction
    demarcation and (optionally) remoting.</p><p>To implement a Stateless or Stateful session bean, or Message Driven
    bean, you derive your implementation class from
    <tt class="literal">AbstractStatelessSessionBean</tt>,
    <tt class="literal">AbstractStatefulSessionBean</tt>, and
    <tt class="literal">AbstractMessageDrivenBean</tt>/<tt class="literal">AbstractJmsMessageDrivenBean</tt>,
    respectively.</p><p>Consider an example Stateless Session bean which actually delegates
    the implementation to a plain java service object. We have the business
    interface:</p><pre class="programlisting">public interface MyComponent {
    public void myMethod(...);
    ...
}</pre><p>We have the plain java implementation object:</p><pre class="programlisting">public class MyComponentImpl implements MyComponent {
    public String myMethod(...) {
        ...
    }
    ...
}</pre><p>And finally the Stateless Session Bean itself:</p><pre class="programlisting">public class MyComponentEJB extends AbstractStatelessSessionBean
        implements MyComponent {

    MyComponent _myComp;

    /**
     * Obtain our POJO service object from the BeanFactory/ApplicationContext
     * @see org.springframework.ejb.support.AbstractStatelessSessionBean#onEjbCreate()
     */
    protected void onEjbCreate() throws CreateException {
        _myComp = (MyComponent) getBeanFactory().getBean(
            ServicesConstants.CONTEXT_MYCOMP_ID);
    }

    // for business method, delegate to POJO service impl.
    public String myMethod(...) {
        return _myComp.myMethod(...);
    }
    ...
}</pre><p>The Spring EJB support base classes will by default create and load
    a BeanFactory (or in this case, its ApplicationContext subclass) as part
    of their lifecycle, which is then available to the EJB (for example, as
    used in the code above to obtain the POJO service object). The loading is
    done via a strategy object which is a subclass of
    <tt class="literal">BeanFactoryLocator</tt>. The actual implementation of
    <tt class="literal">BeanFactoryLocator</tt> used by default is
    <tt class="literal">ContextJndiBeanFactoryLocator</tt>, which creates the
    ApplicationContext from a resource locations specified as a JNDI
    environment variable (in the case of the EJB classes, at
    <tt class="literal">java:comp/env/ejb/BeanFactoryPath</tt>). If there is a need
    to change the BeanFactory/ApplicationContext loading strategy, the default
    <tt class="literal">BeanFactoryLocator</tt> implementation used may be overridden
    by calling the <tt class="literal">setBeanFactoryLocator()</tt> method, either
    in <tt class="literal">setSessionContext()</tt>, or in the actual constructor of
    the EJB. Please see the JavaDocs for more details.</p><p>As described in the JavaDocs, Stateful Session beans expecting to be
    passivated and reactivated as part of their lifecycle, and which use a
    non-serializable BeanFactory/ApplicationContext instance (which is the
    normal case) will have to manually call
    <tt class="literal">unloadBeanFactory()</tt> and
    <tt class="literal">loadBeanFactory</tt> from <tt class="literal">ejbPassivate</tt>
    and <tt class="literal">ejbActivate</tt>, respectively, to unload and reload the
    BeanFactory on passivation and activation, since it can not be saved by
    the EJB container.</p><p>The default usage of
    <tt class="literal">ContextJndiBeanFactoryLocator</tt> to load an
    ApplicationContext for the use of the EJB is adequate for some situations.
    However, it is problematic when the ApplicationContext is loading a number
    of beans, or the initialization of those beans is time consuming or memory
    intensive (such as a Hibernate SessionFactory initialization, for
    example), since every EJB will have their own copy. In this case, the user
    may want to override the default
    <tt class="literal">ContextJndiBeanFactoryLocator</tt> usage and use another
    <tt class="literal">BeanFactoryLocator </tt>variant, such as
    <tt class="literal">ContextSingleton<tt class="literal">BeanFactoryLocator</tt>e</tt>,
    which can load and use a shared BeanFactory or ApplicationContext to be
    used by multiple EJBs or other clients. Doing this is relatively simple,
    by adding code similar to this to the EJB:</p><pre class="programlisting">   /**
    * Override default BeanFactoryLocator implementation
    * 
    * @see javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)
    */
   public void setSessionContext(SessionContext sessionContext) {
       super.setSessionContext(sessionContext);
       setBeanFactoryLocator(ContextSingletonBeanFactoryLocator.getInstance());
       setBeanFactoryLocatorKey(ServicesConstants.PRIMARY_CONTEXT_ID);
   }</pre><p>Please see the respective JavaDocs for
    <tt class="literal">BeanFactoryLocator</tt> and
    <tt class="literal">ContextSingleton<tt class="literal">BeanFactoryLocator</tt>e</tt>
    for more information on their usage.</p><p></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="remoting"></a>Chapter&nbsp;17.&nbsp;Remoting and web services using Spring</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10242"></a>17.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
			Spring features integration classes for remoting support using various
			technologies. The remoting support eases the development of remote-enabled
			services, implemented by your usual (Spring) POJOs. Currently, Spring supports
			four remoting technologies:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						<span class="emphasis"><em>Remote Method Invocation (RMI)</em></span>. Through the use
						of the <tt class="literal">RmiProxyFactoryBean</tt> and the
						<tt class="literal">RmiServiceExporter</tt> Spring supports both traditional
						RMI (with java.rmi.Remote interfaces and java.rmi.RemoteException) and
						transparent remoting via RMI invokers (with any Java interface).
					</p></li><li><p>
						<span class="emphasis"><em>Spring's HTTP invoker</em></span>. Spring provides a special
						remoting strategy which allows for Java serialization via HTTP,
						supporting any Java interface (just like the RMI invoker). The corresponding
						support classes are <tt class="literal">HttpInvokerProxyFactoryBean</tt> and
						<tt class="literal">HttpInvokerServiceExporter</tt>.
					</p></li><li><p>
						<span class="emphasis"><em>Hessian</em></span>. By using the
						<tt class="literal">HessianProxyFactoryBean</tt>
						and the <tt class="literal">HessianServiceExporter</tt> you can transparently
						expose your services using the lightweight binary HTTP-based protocol
						provided by Caucho.
					</p></li><li><p>
						<span class="emphasis"><em>Burlap</em></span>. Burlap is Caucho's XML-based
						alternative for Hessian. Spring provides support classes such
						as <tt class="literal">BurlapProxyFactoryBean</tt> and 
						<tt class="literal">BurlapServiceExporter</tt>.
					</p></li><li><p>
						<span class="emphasis"><em>JAX RPC</em></span>. Spring provides remoting support
						for Web Services via JAX-RPC.
					</p></li><li><p>
						<span class="emphasis"><em>JMS (TODO)</em></span>.
					</p></li></ul></div><p>
		</p><p>
			While discussing the remoting capabilities of Spring, we'll use the following domain 
			model and corresponding services:
			</p><pre class="programlisting">
// Account domain object
public class Account implements Serializable{
  private String name;

  public String getName();
  public void setName(String name) {
    this.name = name;
  }
}
			</pre><p>
			</p><pre class="programlisting">
// Account service
public interface AccountService {

  public void insertAccount(Account acc);
  
  public List getAccounts(String name);
}
			</pre><p>
			</p><pre class="programlisting">
// Remote Account service
public interface RemoteAccountService extends Remote {

  public void insertAccount(Account acc) throws RemoteException;
  
  public List getAccounts(String name) throws RemoteException;
}
			</pre><p>
			</p><pre class="programlisting">
// ... and corresponding implement doing nothing at the moment
public class AccountServiceImpl implements AccountService {

  public void insertAccount(Account acc) {
    // do something
  }
  
  public List getAccounts(String name) {
    // do something
  }
}
			</pre><p>
		</p><p>
			We will start exposing the service to a remote client by using RMI and 
			talk a bit about the drawbacks of using RMI. We'll then continue to show
			an example for Hessian.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10325"></a>17.2.&nbsp;Exposing services using RMI</h2></div></div><div></div></div><p>
			Using Spring's support for RMI, you can transparently expose your services through
			the RMI infrastructure. After having this set up, you basically have a configuration
			similar to remote EJBs, except for the fact that there is no standard support for
			security context propagation or remote transaction propagation. Spring does provide
			hooks for such additional invocation context when using the RMI invoker, so you can
			for example plug in security frameworks or custom security credentials here.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10330"></a>17.2.1.&nbsp;Exporting the service using the <tt class="literal">RmiServiceExporter</tt></h3></div></div><div></div></div><p>
				Using the <tt class="literal">RmiServiceExporter</tt>, we can expose the interface
				of our AccountService object as RMI object. The interface can be accessed by using
				<tt class="literal">RmiProxyFactoryBean</tt>, or via plain RMI in case of a traditional
				RMI service. The <tt class="literal">RmiServiceExporter</tt> explicitly supports the
				exposing of any non-RMI services via RMI invokers.
			</p><p>
				Of course, we first have to set up our service in the Spring BeanFactory:
				</p><pre class="programlisting">
&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
    &lt;!-- any additional properties, maybe a DAO? --&gt;
&lt;/bean&gt;
				</pre><p>				
			</p><p>
				Next we'll have to expose our service using the <tt class="literal">RmiServiceExporter</tt>:
				</p><pre class="programlisting">
&lt;bean class="org.springframework.remoting.rmi.RmiServiceExporter"&gt;
	&lt;!-- does not necessarily have to be the same name as the bean to be exported --&gt;
	&lt;property name="serviceName"&gt;&lt;value&gt;AccountService&lt;/value&gt;&lt;/property&gt;
	&lt;property name="service"&gt;&lt;ref bean="accountService"/&gt;&lt;/property&gt;
	&lt;property name="serviceInterface"&gt;&lt;value&gt;example.AccountService&lt;/value&gt;&lt;/property&gt;
	&lt;!-- defaults to 1099 --&gt;
	&lt;property name="registryPort"&gt;&lt;value&gt;1199&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
				</pre><p>							
				As you can see, we're overriding the port for the RMI registry. Often,
				your application server also maintains an RMI registry and it is wise
				to not interfere with that one.
				Furthermore, the service name is used to bind the service under. So right now,
				the service will be bound at <tt class="literal">rmi://HOST:1199/AccountService</tt>.				
				We'll use the URL later on to link in the service at the client side.
			</p><p>
				<span class="emphasis"><em>Note: We've left out one property, i.e. the <tt class="literal">servicePort</tt>
					property, which is 0 by default. This means an anonymous port will be used
					to communicate with the service. You can specify a different port if you like.</em></span>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10370"></a>17.2.2.&nbsp;Linking in the service at the client</h3></div></div><div></div></div><p>
				Our client is a simple object using the AccountService to manage accounts:
				</p><pre class="programlisting">
public class SimpleObject {
  private AccountService accountService;
  public void setAccountService(AccountService accountService) {
    this.accountService = accountService;
  }
}
				</pre><p>				
			</p><p>
				To link in the service on the client, we'll create a separate bean factory,
				containing the simple object and the service linking configuration bits:
				</p><pre class="programlisting">
&lt;bean class="example.SimpleObject"&gt;
	&lt;property name="accountService"&gt;&lt;ref bean="accountService"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.rmi.RmiProxyFactoryBean"&gt;
	&lt;property name="serviceUrl"&gt;&lt;value&gt;rmi://HOST:1199/AccountService&lt;/value&gt;&lt;/property&gt;
	&lt;property name="serviceInterface"&gt;&lt;value&gt;example.AccountService&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
				</pre><p>
				That's all we need to do to support the remote account service on the client.
				Spring will transparently create an invoker and remotely enable the account
				service through the RmiServiceExporter. At the client we're linking it in using
				the RmiProxyFactoryBean.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10383"></a>17.3.&nbsp;Using Hessian or Burlap to remotely call services via HTTP</h2></div></div><div></div></div><p>
			Hessian offers a binary HTTP-based remoting protocol. It's created by
			Caucho and more information about Hessian itself can be found 
			at <a href="http://www.caucho.com" target="_top">http://www.caucho.com</a>.			
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10390"></a>17.3.1.&nbsp;Wiring up the DispatcherServlet for Hessian</h3></div></div><div></div></div><p>
				Hessian communicates via HTTP and does so using a custom servlet.
				Using Spring's DispatcherServlet principles, you can easily 
				wire up such a servlet exposing your services. First we'll have to
				create a new servlet in your application (this an excerpt from
				<tt class="literal">web.xml</tt>):
				</p><pre class="programlisting">
&lt;servlet&gt;
	&lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
	&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/remoting/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
				</pre><p>
			</p><p>
				You're probably familiar with Spring's DispatcherServlet principles and if so,
				you know that know you'll have to create an application context named
				<tt class="literal">remoting-servlet.xml</tt> (after the name of your servlet) in
				the <tt class="literal">WEB-INF</tt> directory. The application context will be used
				in the next section.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10409"></a>17.3.2.&nbsp;Exposing your beans by using the HessianServiceExporter</h3></div></div><div></div></div><p>
				In the newly created application context called <tt class="literal">remoting-servlet.xml</tt>,
				we'll create a HessianServiceExporter exporting your services:
				</p><pre class="programlisting">
&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
    &lt;!-- any additional properties, maybe a DAO? --&gt;
&lt;/bean&gt;

&lt;bean name="/AccountService" class="org.springframework.remoting.caucho.HessianServiceExporter"&gt;
    &lt;property name="service"&gt;&lt;ref bean="accountService"/&gt;&lt;/property&gt;
    &lt;property name="serviceInterface"&gt;
        &lt;value&gt;example.AccountService&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
				</pre><p>
				Now we're ready to link in the service at the client. No explicit handler mapping
				is specified, mapping request URLs onto services, so BeanNameUrlHandlerMapping
				will be used: hence, the service will be exported at the URL indicated through
				its bean name: <tt class="literal">http://HOST:8080/remoting/AccountService</tt>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10423"></a>17.3.3.&nbsp;Linking in the service on the client</h3></div></div><div></div></div><p>
				Using the <tt class="literal">HessianProxyFactoryBean</tt> we can link in the service
				at the client. The same principles apply as with the RMI example. We'll create
				a separate bean factory or application context and mention the following beans
				where the SimpleObject is using the AccountService to manage accounts:
				</p><pre class="programlisting">
&lt;bean class="example.SimpleObject"&gt;
    &lt;property name="accountService"&gt;&lt;ref bean="accountService"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.caucho.HessianProxyFactoryBean"&gt;
	&lt;property name="serviceUrl"&gt;&lt;value&gt;http://remotehost:8080/AccountService&lt;/value&gt;&lt;/property&gt;
	&lt;property name="ServiceInterface"&gt;&lt;value&gt;example.AccountService&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
				</pre><p>
				That's all there is to it.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10434"></a>17.3.4.&nbsp;Using Burlap</h3></div></div><div></div></div><p>
				We won't discuss Burlap, the XML-based equivalent of Hessian, in detail here,
				since it is configured and set up in exactly the same way as the Hessian
				variant explained above. Just replace the word <tt class="literal">Hessian</tt>
				with <tt class="literal">Burlap</tt> and you're all set to go.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10445"></a>17.3.5.&nbsp;Applying HTTP basic authentication to a service exposed through Hessian or Burlap</h3></div></div><div></div></div><p>
				One of the advantages of Hessian and Burlap is that we can easily apply HTTP basic
				authentication, because both protocols are HTTP-based. Your normal HTTP server security
				mechanism can easily be applied through using the <tt class="literal">web.xml</tt> security
				features, for example. Usually, you don't use per-user security credentials here, but
				rather shared credentials defined at the Hessian/BurlapProxyFactoryBean level
				(similar to a JDBC DataSource).
			</p><p>
				</p><pre class="programlisting">
&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;
	&lt;property name="interceptors"&gt;
		&lt;list&gt;
			&lt;ref bean="authorizationInterceptor"/&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="authorizationInterceptor" 
	class="org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor"&gt;
	&lt;property name="authorizedRoles"&gt;
		&lt;list&gt;
			&lt;value&gt;administrator&lt;/value&gt;
			&lt;value&gt;operator&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;	
&lt;/bean&gt;
				</pre><p>
			</p><p>
				This an example where we explicitly mention the BeanNameUrlHandlerMapping
				and set an interceptor allowing only administrators and operators to call
				the beans mentioned in this application context.
			</p><p>
				<span class="emphasis"><em>
					Note: Of course, this example doesn't show a flexible kind of security
					infrastructure. For more options as far as security is concerned,
					have a look at the Acegi Security System for Spring, to be found at
					<a href="http://acegisecurity.sourceforge.net" target="_top">http://acegisecurity.sourceforge.net</a>.
				</em></span>
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10467"></a>17.4.&nbsp;Exposing services using HTTP invokers</h2></div></div><div></div></div><p>
			As opposed to Burlap and Hessian, which are both lightweight protocols using their
			own slim serialization mechanisms, Spring Http invokers use the standard
			Java serialization mechanism to expose services through HTTP. This has a huge
			advantage if your arguments and return types are complex types that cannot be
			serialized using the serialization mechanisms Hessian and Burlap use (refer to the
			next section for more considerations when choosing a remoting technology).
		</p><p>
			Under the hood, Spring uses either the standard facilities provided by J2SE to
			perform HTTP calls or Commons HttpClient. Use the latter if you need more advanced
			and easy-to-use functionality. Refer to 
			<a href="http://jakarta.apache.org/commons/httpclient" target="_top">jakarta.apache.org/commons/httpclient</a>
			for more info.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10477"></a>17.4.1.&nbsp;Exposing the service object</h3></div></div><div></div></div><p>
				Setting up the HTTP invoker infrastructure for a service objects much resembles
				the way you would do using Hessian or Burlap. Just as Hessian support provides
				the <tt class="literal">HessianServiceExporter</tt>, Spring Http invoker support provides
				the so-called <tt class="literal">org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</tt>.
				To expose the <tt class="literal">AccountService</tt> (mentioned above), the following
				configuration needs to be in place:
</p><pre class="programlisting">
    &lt;bean name="/AccountService" class="org.sprfr.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
        &lt;property name="service"&gt;&lt;ref bean="accountService"/&gt;&lt;/property&gt;
        &lt;property name="serviceInterface"&gt;
            &lt;value&gt;example.AccountService&lt;/value&gt;
        &lt;/property&gt;
	&lt;/bean&gt;
</pre><p>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10494"></a>17.4.2.&nbsp;Linking in the service at the client</h3></div></div><div></div></div><p>
				Again, linking in the service from the client much resembles the way you would
				do it when using Hessian or Burlap. Using a proxy, Spring will be able to
				translate your calls to HTTP POST requests to the URL pointing to the exported
				service.
</p><pre class="programlisting">	
	&lt;bean id="httpInvokerProxy" class="org.sprfr.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
		&lt;property name="serviceUrl"&gt;
			&lt;value&gt;http://remotehost:8080/AccountService&lt;/value&gt;
		&lt;/property&gt;
		&lt;property name="serviceInterface"&gt;
			&lt;value&gt;example.AccountService&lt;/value&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
</pre><p>
			</p><p>
				As mentioned before, you can choose what HTTP client you want to use.
				By default, the HttpInvokerProxy uses the J2SE HTTP functionality, but
				you can also use the Commons HttpClient by setting the <tt class="literal">httpInvokerRequestExecutor</tt> property:
</p><pre class="programlisting">
&lt;property name="httpInvokerRequestExecutor"&gt;
	&lt;bean class="org.springframework.remoting.httpinvoker.CommonsHttpInvokerRequestExecutor"/&gt;
&lt;/property&gt;
</pre><p>
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10510"></a>17.5.&nbsp;Web Services</h2></div></div><div></div></div><p>
			Spring has support for:
			</p><div class="itemizedlist"><ul type="disc" compact><li>Exposing services using JAX-RPC</li><li>Accessing Web Services</li></ul></div><p>
		</p><p>
            Next to the support listed above, you can also expose your web services using
            XFire <a href="http://xfire.codehaus.org" target="_top">xfire.codehaus.org</a>.
            XFire is a ligthweight SOAP library, currently in development at Codehaus.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10526"></a>17.5.1.&nbsp;Exposing services using JAX-RPC</h3></div></div><div></div></div><p>
				Spring has a convenience base class for JAX-RPC servlet endpoint implementations -
				<tt class="literal">ServletEndpointSupport</tt>. To expose our AccountService we extend Spring's ServletEndpointSupport class
				and implement our business logic here, usually delegating the call to the business layer.
</p><pre class="programlisting">
/**
 * JAX-RPC compliant RemoteAccountService implementation that simply delegates
 * to the AccountService implementation in the root web application context.
 *
 * This wrapper class is necessary because JAX-RPC requires working with
 * RMI interfaces. If an existing service needs to be exported, a wrapper that
 * extends ServletEndpointSupport for simple application context access is
 * the simplest JAX-RPC compliant way.
 *
 * This is the class registered with the server-side JAX-RPC implementation.
 * In the case of Axis, this happens in "server-config.wsdd" respectively via
 * deployment calls. The Web Service tool manages the life-cycle of instances
 * of this class: A Spring application context can just be accessed here.
 */
public class AccountServiceEndpoint extends ServletEndpointSupport implements RemoteAccountService {
    
    private AccountService biz;
	
    protected void onInit() {
        this.biz = (AccountService) getWebApplicationContext().getBean("accountService");
    }

    public void insertAccount(Account acc) throws RemoteException {
        biz.insertAccount(acc);
    }
  
    public Account[] getAccounts(String name) throws RemoteException {
        return biz.getAccounts(name);
    }
  
}	
</pre><p>
				Our AccountServletEndpoint needs to run in the same web application as the Spring context to allow for access
				to Spring's facilities. In case of Axis, copy the AxisServlet definition into your web.xml, and set up
				the endpoint in "server-config.wsdd" (or use the deploy tool).
				See the sample application JPetStore where the OrderService is exposed as a Web Service using Axis.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10537"></a>17.5.2.&nbsp;Accessing Web Services</h3></div></div><div></div></div><p>
				Spring has two factory beans to create web service proxies <tt class="literal">LocalJaxRpcServiceFactoryBean</tt> and
				<tt class="literal">JaxRpcPortProxyFactoryBean</tt>. The former can only return a JAX-RPC Service class for us to work with.
				The latter is the full fledged version that can return a proxy that implements our business service interface.
				In this example we use the later to create a proxy for the AccountService Endpoint we exposed in the previous paragraph.
				You will see that Spring has great support for Web Services requiring little coding efforts - most of the magic is done in
				the spring configuration file as usual:
</p><pre class="programlisting">
    &lt;bean id="accountWebService" class="org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean"&gt;
        &lt;property name="serviceInterface"&gt;
            &lt;value&gt;example.RemoteAccountService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="wsdlDocumentUrl"&gt;
            &lt;value&gt;http://localhost:8080/account/services/accountService?WSDL&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="namespaceUri"&gt;
            &lt;value&gt;http://localhost:8080/account/services/accountService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="serviceName"&gt;
            &lt;value&gt;AccountService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="portName"&gt;
            &lt;value&gt;AccountPort&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</pre><p>
				Where <tt class="literal">serviceInterface</tt> is our remote business interface the clients will use.
				<tt class="literal">wsdlDocumentUrl</tt> is the URL for the WSDL file. Spring needs this a startup time to create the JAX-RPC Service.
				<tt class="literal">namespaceUri</tt> corresponds to the targetNamespace in the .wsdl file.
				<tt class="literal">serviceName</tt> corresponds to the serivce name in the .wsdl file.
				<tt class="literal">portName</tt> corresponds to the port name in the .wsdl file.
			</p><p>
				Accessing the Web Service is now very easy as we have a bean factory for it that will expose it as <tt class="literal">RemoteAccountService</tt>
				interface. We can wire this up in Spring:
</p><pre class="programlisting">
    &lt;bean id="client" class="example.AccountClientImpl"&gt;
        ...
        &lt;property name="service"&gt;
            &lt;ref bean="accountWebService"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</pre><p>
				And from the client code we can access the Web Service just as if it was a normal class, except that it throws RemoteException.
</p><pre class="programlisting">
public class AccountClientImpl {

    private RemoteAccountService service;
    
    public void setService(RemoteAccountService service) {
        this.service = service;
    }
    
    public void foo() {
       try {
           service.insertAccount(...);
        } catch (RemoteException e) {
           // ouch
           ...
        }
     }
     
}
</pre><p>
			</p><p>
				We can get rid of the checked RemoteException since Spring supports automatic conversion to its corresponding unchecked
				<tt class="literal">RemoteAccessException</tt>. This requires that we provide a non RMI interface also. Our configuration is now:
</p><pre class="programlisting">
    &lt;bean id="accountWebService" class="org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean"&gt;
        &lt;property name="serviceInterface"&gt;
            &lt;value&gt;example.AccountService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="portInterface"&gt;
            &lt;value&gt;example.RemoteAccountService&lt;/value&gt;
        &lt;/property&gt;
        ...
    &lt;/bean&gt;
</pre><p>
				Where <tt class="literal">serviceInterface</tt> is changed to our non RMI interface. Our RMI interface is now defined using the property
				<tt class="literal">portInterface</tt>. Our client code can now avoid handling <tt class="literal">java.rmi.RemoteException</tt>:
</p><pre class="programlisting">
public class AccountClientImpl {

    private AccountService service;
    
    public void setService(AccountService service) {
        this.service = service;
    }
    
    public void foo() {
        service.insertAccount(...);
     }
     
}
</pre><p>
    		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10597"></a>17.5.3.&nbsp;Register Bean Mappings</h3></div></div><div></div></div><p>
				To transfer complex objects over the wire such as Account we must register bean mappings on the client side.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
						On the server side using Axis registering bean mappings is usually done in server-config.wsdd.
					</p></td></tr></table></div><p>
				We will use Axis to register bean mappings on the client side. To do this we need to subclass Spring Bean factory and
				register the bean mappings programmatic:
</p><pre class="programlisting">
public class AxisPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {

	protected void postProcessJaxRpcService(Service service) {
		TypeMappingRegistry registry = service.getTypeMappingRegistry();
		TypeMapping mapping = registry.createTypeMapping();
		registerBeanMapping(mapping, Account.class, "Account");
		registry.register("http://schemas.xmlsoap.org/soap/encoding/", mapping);
	}

	protected void registerBeanMapping(TypeMapping mapping, Class type, String name) {
		QName qName = new QName("http://localhost:8080/account/services/accountService", name);
		mapping.register(type, qName,
		    new BeanSerializerFactory(type, qName),
		    new BeanDeserializerFactory(type, qName));
	}

}
</pre><p>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10609"></a>17.5.4.&nbsp;Registering our own Handler</h3></div></div><div></div></div><p>
				In this section we will register our own <tt class="literal">javax.rpc.xml.handler.Handler</tt> to the Web Service Proxy
				where we can do custom code before the SOAP message is sent over the wire.
				The <tt class="literal">javax.rpc.xml.handler.Handler</tt> is a callback interface. There is a convenience base class provided
				in jaxrpc.jar -	<tt class="literal">javax.rpc.xml.handler.GenericHandler</tt> that we will extend:
</p><pre class="programlisting">
public class AccountHandler extends GenericHandler {

    public QName[] getHeaders() {
        return null;
    }

    public boolean handleRequest(MessageContext context) {
        SOAPMessageContext smc = (SOAPMessageContext) context;
        SOAPMessage msg = smc.getMessage();

        try {
            SOAPEnvelope envelope = msg.getSOAPPart().getEnvelope();
            SOAPHeader header = envelope.getHeader();
            ...
		
        } catch (SOAPException e) {
            throw new JAXRPCException(e);
        }

        return true;
    }

}
</pre><p>
			What we need to do now is to register our AccountHandler to JAX-RPC Service so it would invoke <tt class="literal">handleRequest</tt>
			before the message is sent over the wire. Spring has at this time of writing no declarative support for registering handlers.
			So we must use the programmatic approach. However Spring has made it very easy for us to do this as we can extend its bean factory
			and override its <tt class="literal">postProcessJaxRpcService</tt> method that is designed for this: 
</p><pre class="programlisting">
public class AccountHandlerJaxRpcPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {

    protected void postProcessJaxRpcService(Service service) {
        QName port = new QName(this.getNamespaceUri(), this.getPortName());
        List list = service.getHandlerRegistry().getHandlerChain(port);
        list.add(new HandlerInfo(AccountHandler.class, null, null));

        logger.info("Registered JAX-RPC Handler [" + AccountHandler.class.getName() + "] on port " + port);
    }

}
</pre><p>
			And the last thing we must remember to do is to change the Spring configuration to use our factory bean:
</p><pre class="programlisting">
    &lt;bean id="accountWebService" class="example.AccountHandlerJaxRpcPortProxyFactoryBean"&gt;
        ...
    &lt;/bean&gt;    
</pre><p>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10638"></a>17.5.5.&nbsp;Exposing web services using XFire</h3></div></div><div></div></div><p>
                XFire is a lightweight SOAP library, hosted by Codehaus. At the time of writing (March 2005), XFire
                is still in development. Although Spring support is stable, lots of features should be added in the future.
                Exposing XFire is done using an XFire context that shipping with XFire itself in combination with a
                RemoteExporter-style bean you have to add to your WebApplicationContext.
            </p><p>
                As with all methods that allow you to expose service, you have to create a DispatcherServlet with
                a corresponding WebApplicationContext containing the services you will be exposing:
                </p><pre class="programlisting">
&lt;servlet&gt;
  &lt;servlet-name&gt;xfire&lt;/servlet-name&gt;
  &lt;servlet-class&gt;
    org.springframework.web.servlet.DispatcherServlet
  &lt;/servlet-class&gt;
&lt;/servlet&gt;
                </pre><p>
            </p><p>
                You also have to link in the XFire configuration. This is done by adding a context file to the
                <tt class="literal">contextConfigLocations</tt> context parameter picked up by the ContextLoaderListener
                (or Servlet for that matter). The configuration file is located in the XFire jar and should of course
                be placed on the classpath of your application archive.
                </p><pre class="programlisting">
&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;
    classpath:org/codehaus/xfire/spring/xfire.xml
  &lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
  &lt;listener-class&gt;
    org.springframework.web.context.ContextLoaderListener
  &lt;/listener-class&gt;
&lt;/listener&gt;
                </pre><p>
            </p><p>
              After you added a servlet mapping (mapping /* to the XFire servlet declared above) you only have to add
              one extra bean to expose the service using XFire. Add for example the following you <tt class="literal">xfire-servlet.xml</tt>:
              </p><pre class="programlisting">
&lt;beans&gt;
  &lt;bean name="/Echo" class="org.codehaus.xfire.spring.XFireExporter"&gt;
    &lt;property name="service"&gt;
      &lt;ref bean="echo"/&gt;
    &lt;/property&gt;
    &lt;property name="serviceInterface"&gt;
      &lt;value&gt;org.codehaus.xfire.spring.Echo&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="serviceBuilder"&gt;
      &lt;ref bean="xfire.serviceBuilder"/&gt;
    &lt;/property&gt;
    &lt;!-- the XFire bean is wired up in the xfire.xml file you've linked in earlier
    &lt;property name="xfire"&gt;
      &lt;ref bean="xfire"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="echo" class="org.codehaus.xfire.spring.EchoImpl"/&gt;
&lt;/beans&gt;
</pre><p>
            </p><p>
              XFire handles the rest. It introspects your service interface and generates a WSDL from it.
              Parts of this documentation have been taken from the XFire site. For more detailed information on XFire
              Spring integration, have a look at the <a href="http://docs.codehaus.org/display/XFIRE/Spring" target="_top">docs.codehaus.org/display/XFIRE/Spring</a>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10669"></a>17.6.&nbsp;Auto-detection is not implemented for remote interfaces</h2></div></div><div></div></div><p>
            The main reason why auto-detection of implemented interfaces does not occur for
            remote interfaces is to avoid opening too many doors to remote callers. The target
            object might implement internal callback interfaces like InitializingBean or
            DisposableBean which one would not want to expose to callers.
        </p><p>
            Offering a proxy with all interfaces implemented by the target usually does not
            matter in the local case. But when exporting a remote service, you should expose
            a specific service interface, with specific operations intended for remote usage.
            Besides internal callback interfaces, the target might implement multiple business
            interfaces, with just one of them intended for remote exposure. For these reasons,
            we <span class="emphasis"><em>require</em></span> such a service interface to be specified.
        </p><p>
            This is a trade-off between configuration convenience and the risk of accidental
            exposure of internal methods. Always specifying a service interface is not too much
            effort, and puts you on the safe side regarding controlled exposure of specific
            methods.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10681"></a>17.7.&nbsp;Considerations when choosing a technology</h2></div></div><div></div></div><p>
			Each and every technology presented here has its drawbacks. You should carefully
			consider you needs, the services your exposing and the objects you'll be sending
			over the wire when choosing a technology.
		</p><p>
			When using RMI, it's not possible to access the objects through the HTTP protocol,
			unless you're tunneling the RMI traffic. RMI is a fairly heavy-weight protocol
			in that it support full-object serialization which is important when using a
			complex data model that needs serialization over the wire. However, RMI-JRMP
			is tied to Java clients: It is a Java-to-Java remoting solution.
		</p><p>
			Spring's HTTP invoker is a good choice if you need HTTP-based remoting but also
			rely on Java serialization. It shares the basic infrastructure with RMI invokers,
			just using HTTP as transport. Note that HTTP invokers are not only limited to
			Java-to-Java remoting but also to Spring on both the client and server side.
			(The latter also applies to Spring's RMI invoker for non-RMI interfaces.)
		</p><p>
			Hessian and/or Burlap might provide significant value when operating in a
			heterogeneous environment, because they explicitly allow for non-Java clients.
			However, non-Java support is still limited. Known problems include the serialization
			of Hibernate objects in combination with lazily initializing collections. If you
			have such a data model, consider using RMI or HTTP invokers instead of Hessian.
		</p><p>
			JMS can be useful for providing clusters of services and allowing the JMS broker
      to take care of load balancing, discovery and auto-failover.
      By default Java serialization is used when using JMS remoting but
      the JMS provider could use a different mechanism for the wire formatting,
      such as XStream to allow servers to be implemented in other technologies.
		</p><p>
			Last but not least, EJB has an advantage over RMI in that it supports standard
			role-based authentication and authorization and remote transaction propagation.
			It is possible to get RMI invokers or HTTP invokers to support security context
			propagation as well, although this is not provided by core Spring: There are
			just appropriate hooks for plugging in third-party or custom solutions here.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mail"></a>Chapter&nbsp;18.&nbsp;Sending Email with Spring mail abstraction layer</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-introduction"></a>18.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring provides a higher level of abstraction for sending electronic
    mail which shields the user from the specifics of underlying mailing
    system and is responsible for a low level resource handling on behalf of
    the client.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-structure"></a>18.2.&nbsp;Spring mail abstraction structure</h2></div></div><div></div></div><p>The main package of Spring mail abstraction layer is
    <tt class="literal">org.springframework.mail</tt> package. It contains central
    interface for sending emails called <tt class="literal">MailSender</tt> and the
    <span class="emphasis"><em>value object</em></span> which encapsulates properties of a
    simple mail such as <span class="emphasis"><em>from</em></span>, <span class="emphasis"><em>to</em></span>,
    <span class="emphasis"><em>cc</em></span>, <span class="emphasis"><em>subject</em></span>,
    <span class="emphasis"><em>text</em></span> called <tt class="literal">SimpleMailMessage</tt>.
    This package also contains a hierarchy of checked exceptions which provide
    a higher level of abstraction over the lower level mail system exceptions
    with the root exception being <tt class="literal">MailException.</tt>Please
    refer to JavaDocs for more information on mail exception hierarchy.</p><p>Spring also provides a sub-interface of <tt class="literal">MailSender</tt>
    for specialized <span class="emphasis"><em>JavaMail</em></span> features such as MIME
    messages, namely
    <tt class="literal">org.springframework.mail.javamail.JavaMailSender</tt> It
    also provides a callback interface for preparation of JavaMail MIME
    messages, namely
    <tt class="literal">org.springframework.mail.javamail.MimeMessagePreparator</tt></p><p>MailSender: </p><pre class="programlisting">public interface MailSender {

    /**
     * Send the given simple mail message.
     * @param simpleMessage message to send
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(SimpleMailMessage simpleMessage) throws MailException;

    /**
     * Send the given array of simple mail messages in batch.
     * @param simpleMessages messages to send
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(SimpleMailMessage[] simpleMessages) throws MailException;

}</pre><p> JavaMailSender: </p><pre class="programlisting">public interface JavaMailSender extends MailSender {

    /**
     * Create a new JavaMail MimeMessage for the underlying JavaMail Session
     * of this sender. Needs to be called to create MimeMessage instances
     * that can be prepared by the client and passed to send(MimeMessage).
     * @return the new MimeMessage instance
     * @see #send(MimeMessage)
     * @see #send(MimeMessage[])
     */
    public MimeMessage createMimeMessage();

    /**
     * Send the given JavaMail MIME message.
     * The message needs to have been created with createMimeMessage.
     * @param mimeMessage message to send
     * @throws MailException in case of message, authentication, or send errors
     * @see #createMimeMessage
     */
    public void send(MimeMessage mimeMessage) throws MailException;

    /**
     * Send the given array of JavaMail MIME messages in batch.
     * The messages need to have been created with createMimeMessage.
     * @param mimeMessages messages to send
     * @throws MailException in case of message, authentication, or send errors
     * @see #createMimeMessage
     */
    public void send(MimeMessage[] mimeMessages) throws MailException;

    /**
     * Send the JavaMail MIME message prepared by the given MimeMessagePreparator.
     * Alternative way to prepare MimeMessage instances, instead of createMimeMessage
     * and send(MimeMessage) calls. Takes care of proper exception conversion.
     * @param mimeMessagePreparator the preparator to use
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(MimeMessagePreparator mimeMessagePreparator) throws MailException;

    /**
     * Send the JavaMail MIME messages prepared by the given MimeMessagePreparators.
     * Alternative way to prepare MimeMessage instances, instead of createMimeMessage
     * and send(MimeMessage[]) calls. Takes care of proper exception conversion.
     * @param mimeMessagePreparators the preparator to use
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(MimeMessagePreparator[] mimeMessagePreparators) throws MailException;

}</pre><p> MimeMessagePreparator: </p><pre class="programlisting">public interface MimeMessagePreparator {

    /**
     * Prepare the given new MimeMessage instance.
     * @param mimeMessage the message to prepare
     * @throws MessagingException passing any exceptions thrown by MimeMessage
     * methods through for automatic conversion to the MailException hierarchy
     */
    void prepare(MimeMessage mimeMessage) throws MessagingException;

}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-usage"></a>18.3.&nbsp;Using Spring mail abstraction</h2></div></div><div></div></div><p>Let's assume there is a business interface called
    <tt class="literal">OrderManager</tt></p><pre class="programlisting">public interface OrderManager {

    void placeOrder(Order order);
}</pre><p> and there is a use case that says that an email message
    with order number would need to be generated and sent to a customer
    placing that order. So for this purpose we want to use
    <tt class="literal">MailSender</tt> and
    <tt class="literal">SimpleMailMessage</tt></p><p><span class="emphasis"><em>Please note that as usual, we work with interfaces in the
    business code and let Spring IoC container take care of wiring of all the
    collaborators for us.</em></span></p><p>Here is the implementation of <tt class="literal">OrderManager</tt>
    </p><pre class="programlisting">import org.springframework.mail.MailException;
import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;

public class OrderManagerImpl implements OrderManager {

    private MailSender mailSender;
    private SimpleMailMessage message;

    public void setMailSender(MailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void setMessage(SimpleMailMessage message) {
        this.message = message;
    }

    public void placeOrder(Order order) {

        //... * Do the business calculations....
        //... * Call the collaborators to persist the order

        //Create a thread safe "sandbox" of the message
        SimpleMailMessage msg = new SimpleMailMessage(this.message);
        msg.setTo(order.getCustomer().getEmailAddress());
        msg.setText(
            "Dear "
                + order.getCustomer().getFirstName()
                + order.getCustomer().getLastName()
                + ", thank you for placing order. Your order number is "
                + order.getOrderNumber());
        try{
            mailSender.send(msg);
        }
        catch(MailException ex) {
            //log it and go on
            System.err.println(ex.getMessage());            
        }
    }
}</pre><p>Here is what the bean definitions for the code above would
    look like:</p><pre class="programlisting">&lt;bean id="mailSender"
      class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
    &lt;property name="host"&gt;&lt;value&gt;mail.mycompany.com&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="mailMessage"
      class="org.springframework.mail.SimpleMailMessage"&gt;
    &lt;property name="from"&gt;&lt;value&gt;customerservice@mycompany.com&lt;/value&gt;&lt;/property&gt;
    &lt;property name="subject"&gt;&lt;value&gt;Your order&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="orderManager"
      class="com.mycompany.businessapp.support.OrderManagerImpl"&gt;
    &lt;property name="mailSender"&gt;&lt;ref bean="mailSender"/&gt;&lt;/property&gt;
    &lt;property name="message"&gt;&lt;ref bean="mailMessage"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>Here is the implementation of <tt class="literal">OrderManager</tt> using
    <tt class="literal">MimeMessagePreparator</tt> callback interface. Please note
    that the mailSender property is of type <tt class="literal">JavaMailSender</tt>
    in this case in order to be able to use JavaMail MimeMessage:
    </p><pre class="programlisting">import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import javax.mail.internet.MimeMessage;
import org.springframework.mail.MailException;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;

public class OrderManagerImpl implements OrderManager {
    private JavaMailSender mailSender;
    
    public void setMailSender(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void placeOrder(final Order order) {

        //... * Do the business calculations....
        //... * Call the collaborators to persist the order
        
        
        MimeMessagePreparator preparator = new MimeMessagePreparator() {
            public void prepare(MimeMessage mimeMessage) throws MessagingException {
                mimeMessage.setRecipient(Message.RecipientType.TO, 
                        new InternetAddress(order.getCustomer().getEmailAddress()));
                mimeMessage.setFrom(new InternetAddress("mail@mycompany.com"));
                mimeMessage.setText(
                    "Dear "
                        + order.getCustomer().getFirstName()
                        + order.getCustomer().getLastName()
                        + ", thank you for placing order. Your order number is "
                        + order.getOrderNumber());
            }
        };
        try{
            mailSender.send(preparator);
        }
        catch(MailException ex) {
            //log it and go on
            System.err.println(ex.getMessage());            
        }
    }
}</pre><p>If you want to use JavaMail MimeMessage to the full power, the
    <tt class="literal">MimeMessagePreparator</tt> is available at your
    fingertips.</p><p><span class="emphasis"><em>Please note that the mail code is a crosscutting concern
    and is a perfect candidate for refactoring into a custom Spring AOP advice,
    which then could easily be applied to OrderManager target. Please see the
    AOP chapter.</em></span></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10811"></a>18.3.1.&nbsp;Pluggable MailSender implementations</h3></div></div><div></div></div><p>Spring comes with two MailSender implementations out of the box -
      the JavaMail implementation and the implementation on top of Jason
      Hunter's <span class="emphasis"><em>MailMessage</em></span> class that's included in
      <a href="http://servlets.com/cos" target="_top">http://servlets.com/cos</a>
      (com.oreilly.servlet). Please refer to JavaDocs for more
      information.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10822"></a>18.4.&nbsp;Using the JavaMail MimeMessageHelper</h2></div></div><div></div></div><p>
  		One of the components that comes in pretty handy when dealing with
  		JavaMail messages is the <tt class="literal">org.springframework.mail.javamail.MimeMessageHelper</tt>.
  		It prevents you from having to use the nasty APIs the the <tt class="literal">javax.mail.internet</tt> classes.
  		A couple of possible scenarios:
  	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10833"></a>18.4.1.&nbsp;Creating a simple MimeMessage and sending it</h3></div></div><div></div></div><p>
  			Using the MimeMessageHelper it's pretty easy to setup and send a MimeMessage:
  			</p><pre class="programlisting">
// of course you would setup the mail sender using 
// DI in any real-world cases
JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMesage();
MimeMessageHelper helper = new MimeMessageHelper(message);
helper.setTo("test@host.com");
helper.setText("Thank you for ordering!");

sender.send(message);
			</pre><p>
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10841"></a>18.4.2.&nbsp;Sending attachments and inline resources</h3></div></div><div></div></div><p>
			Email allow for attachments, but also for inline resources in multipart
			messages. Inline resources could for example be images or stylesheet you
			want to use in your message, but don't want displayed as attachment.
			The following shows you how to use the MimeMessageHelper to send an
			email along with an inline image.
			</p><pre class="programlisting">
JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMesage();

// use the true flag to indicate you need a multipart message
MimeMessageHelper helper = new MimeMessageHelper(message, true);
helper.setTo("test@host.com");

// use the true flag to indicate the text included is HTML
helper.setText(
  "&lt;html&gt;&lt;body&gt;&lt;img src='cid:identifier1234'&gt;&lt;/body&gt;&lt;/html&gt;"
  true);

// let's include the infamous windows Sample file (this time copied to c:/)
FileSystemResource res = new FileSystemResource(new File("c:/Sample.jpg"));
helper.addInline("identifier1234", res);

// if you would need to include the file as an attachment, use
// addAttachment() methods on the MimeMessageHelper

sender.send(message);
			</pre><p>
			<span class="emphasis"><em>Inline resources are added to the mime message using the Content-ID specified
			as you've seen just now (<tt class="literal">identifier1234</tt> in this case). The order in 
			which you're adding the text and the resource are VERY important. First add the text
			and after that the resources. If you're doing it the other way around, it won't work!</em></span>
		</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="scheduling"></a>Chapter&nbsp;19.&nbsp;Scheduling jobs using Quartz or Timer</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10858"></a>19.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
  		Spring features integration classes for scheduling support. Currently, Spring
  		supports the Timer, part of the JDK since 1.3, and the Quartz Scheduler
  		(<a href="http://www.quartzscheduler.org" target="_top">http://www.quartzscheduler.org</a>). Both schedulers are set up
  		using a FactoryBean with optional references to Timers or Triggers, respectively.
  		Furthermore, a convenience class for both the Quartz Scheduler and the Timer is
  		available that allows you to invoke a method of an existing target object
			(analogous to normal <tt class="literal">MethodInvokingFactoryBeans</tt>).
  	</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10868"></a>19.2.&nbsp;Using the OpenSymphony Quartz Scheduler</h2></div></div><div></div></div><p>
  		Quartz uses <tt class="literal">Triggers</tt>, <tt class="literal">Jobs</tt> and 
  		<tt class="literal">JobDetail</tt> ro realize scheduling of all kinds of jobs.
  		For the basic concepts behind Quartz, have a look at 
  		<a href="http://www.opensymphony.com/quartz" target="_top">http://www.opensymphony.com/quartz</a>. For convenience purposes,
  		Spring offers a couple of classes that simplify usage of Quartz within
  		Spring-based applications.
  	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10884"></a>19.2.1.&nbsp;Using the JobDetailBean</h3></div></div><div></div></div><p>
  			<tt class="literal">JobDetail</tt> objects contain all information needed to
  			run a job. Spring provides a so-called <tt class="literal">JobDetailBean</tt>
  			that makes the JobDetail more of an actual JavaBean with sensible defaults.
  			Let's have a look at an example:
  			</p><pre class="programlisting">
&lt;bean name="exampleJob" class="org.springframework.scheduling.quartz.JobDetailBean"&gt;
  &lt;property name="jobClass"&gt;
    &lt;value&gt;example.ExampleJob&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="jobDataAsMap"&gt;
    &lt;map&gt;
      &lt;entry key="timeout"&gt;&lt;value&gt;5&lt;/value&gt;&lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;
			</pre><p>
			
			The job detail bean has all information it needs to run the job (ExampleJob).
			The timeout is specified as the job data map. The job data map is
			available through the JobExecutionContext (passed to you at execution time),
			but the <tt class="literal">JobDetailBean</tt> also maps the properties from the
			job data map to properties of the actual job. So in this case, if the ExampleJob contains
			a property named <tt class="literal">timeout</tt>, the JobDetailBean will automatically apply it:
			</p><pre class="programlisting">
package example;

public class ExampleJob extends QuartzJobBean {

  private int timeout;
  
  /**
   * Setter called after the ExampleJob is instantiated
   * with the value from the JobDetailBean (5)
   */ 
  public void setTimeout(int timeout) {
    this.timeout = timeout;
  }
  
  protected void executeInternal(JobExecutionContext ctx)
  throws JobExecutionException {
      // do the actual work
  }
}
			</pre><p>
			
			All additional settings from the job detail bean are of course available to you as well.
		</p><p>
			<span class="emphasis"><em>Note: Using the <tt class="literal">name</tt> and <tt class="literal">group</tt> properties,
			you can modify the name and the group of the job, respectively. By default the name of
			the job equals the bean name of the job detail bean (in the example above, this is
			<tt class="literal">exampleJob</tt>).</em></span>
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10921"></a>19.2.2.&nbsp;Using the MethodInvokingJobDetailFactoryBean</h3></div></div><div></div></div><p>
			Often you just need to invoke a method on a specific object. Using the
			<tt class="literal">MethodInvokingJobDetailFactoryBean</tt> you can do exactly this:
			</p><pre class="programlisting">
&lt;bean id="methodInvokingJobDetail" 
  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
    &lt;property name="targetObject"&gt;&lt;ref bean="exampleBusinessObject"/&gt;&lt;/property&gt;
    &lt;property name="targetMethod"&gt;&lt;value&gt;doIt&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre><p>
			The above example will result in the <tt class="literal">doIt</tt> being called on the exampleBusinessObject
			(see below):
			</p><pre class="programlisting">
public class BusinessObject {
  
  // properties and collaborators
  
  public void doIt() {
    // do the actual work
  }
}
			</pre><p>

			</p><pre class="programlisting">
&lt;bean id="exampleBusinessObject" class="examples.ExampleBusinessObject"/&gt;
			</pre><p>	
			Using the <tt class="literal">MethodInvokingJobDetailFactoryBean</tt> you don't need to
			create one-line jobs that just invoke a method, and you only need to create the actual
			business object and wire up the detail object.
		</p><p>
			By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering
			with each other. If you specify two triggers for the same JobDetail, it might be possible
			that before the first job has finished, the second one will start. If JobDetail objects
			implement the Stateful interface, this won't happen. The second job will not start before
			the first one has finished. To make jobs resulting from the MethodInvokingJobDetailFactoryBean
			non-concurrent, set the <tt class="literal">concurrent</tt> flag to <tt class="literal">false</tt>.
			</p><pre class="programlisting">
&lt;bean id="methodInvokingJobDetail"
  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
    &lt;property name="targetObject"&gt;&lt;ref bean="exampleBusinessObject"/&gt;&lt;/property&gt;
    &lt;property name="targetMethod"&gt;&lt;value&gt;doIt&lt;/value&gt;&lt;/property&gt;
    &lt;property name="concurrent"&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
			</pre><p>
			<span class="emphasis"><em>Note: By default, jobs will run in a concurrent fashion.</em></span>
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10958"></a>19.2.3.&nbsp;Wiring up jobs using triggers and the SchedulerFactoryBean</h3></div></div><div></div></div><p>
			We've created job details, jobs and we've reviewed the convenience bean
			that allows to you invoke a method on a specific object. Of course, we still need
			to schedule the jobs themselves. This is done using triggers and a 
			<tt class="literal">SchedulerFactoryBean</tt>. Several triggers are available
			within Quartz. Spring offers two subclassed triggers with convenient defaults:
			<tt class="literal">CronTriggerBean</tt> and <tt class="literal">SimpleTriggerBean</tt>.
		</p><p>
			Triggers need to be scheduled. Spring offers a SchedulerFactoryBean exposing properties
			to set the triggers. SchedulerFactoryBean schedules the actual jobs with those triggers.
		</p><p>
			A couple of examples:
			</p><pre class="programlisting">
&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean"&gt;
  &lt;property name="jobDetail"&gt;
    &lt;!-- see the example of method invoking job above --&gt;    
    &lt;ref bean="methodInvokingJobDetail"/&gt;
  &lt;/property&gt;
  &lt;property name="startDelay"&gt;
    &lt;!-- 10 seconds --&gt;
    &lt;value&gt;10000&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="repeatInterval"&gt;
    &lt;!-- repeat every 50 seconds --&gt;
    &lt;value&gt;50000&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt;
  &lt;property name="jobDetail"&gt;
    &lt;ref bean="exampleJob"/&gt;
  &lt;/property&gt;
  &lt;property name="cronExpression"&gt;
    &lt;!-- run every morning at 6 AM --&gt;
    &lt;value&gt;0 0 6 * * ?&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;
			</pre><p>
			OK, now we've set up two triggers, one running every 50 seconds with a starting delay of
			10 seconds and one every morning at 6 AM. To finalize everything, we need to set up the
			SchedulerFactoryBean:
			</p><pre class="programlisting">
&lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
  &lt;property name="triggers"&gt;
    &lt;list&gt;
      &lt;ref local="cronTrigger"/&gt;
      &lt;ref local="simpleTrigger"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
			</pre><p>
			More properties are available for the SchedulerFactoryBean for you to set, such as the
			calendars used by the job details, properties to customize Quartz with, etc. Have a look
			at the JavaDoc (<a href="http://www.springframework.org/docs/api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html" target="_top">http://www.springframework.org/docs/api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html</a>)
			for more information.
		</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10984"></a>19.3.&nbsp;Using JDK Timer support</h2></div></div><div></div></div><p>
  		The other way to schedule jobs in Spring is using JDK Timer objects.
  		More information about Timers themselves can be found at
  		<a href="http://java.sun.com/docs/books/tutorial/essential/threads/timer.html" target="_top">http://java.sun.com/docs/books/tutorial/essential/threads/timer.html</a>.
  		The concepts discussed above also apply to the Timer support. You can create
  		custom timers or use the timer that invokes methods. Wiring timers has to be done
  		using the TimerFactoryBean.
  	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10991"></a>19.3.1.&nbsp;Creating custom timers</h3></div></div><div></div></div><p>
  			Using the <tt class="literal">TimerTask</tt> you can create customer timer tasks, similar to Quartz jobs:
  			</p><pre class="programlisting">
public class CheckEmailAddresses extends TimerTask {

  private List emailAddresses;
  
  public void setEmailAddresses(List emailAddresses) {
    this.emailAddresses = emailAddresses;
  }
  
  public void run() {
    // iterate over all email addresses and archive them
  }
}
			</pre><p>
			
			Wiring it up is simple:
			
			</p><pre class="programlisting">
&lt;bean id="checkEmail" class="examples.CheckEmailAddress"&gt;
  &lt;property name="emailAddresses"&gt;
    &lt;list&gt;
      &lt;value&gt;test@springframework.org&lt;/value&gt;
      &lt;value&gt;foo@bar.com&lt;/value&gt;
      &lt;value&gt;john@doe.net&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="scheduledTask" class="org.springframework.scheduling.timer.ScheduledTimerTask"&gt;
  &lt;!-- wait 10 seconds before starting repeated execution --&gt;
  &lt;property name="delay"&gt;
    &lt;value&gt;10000&lt;/value&gt;
  &lt;/property&gt;
  &lt;!-- run every 50 seconds --&gt;
  &lt;property name="period"&gt;
    &lt;value&gt;50000&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="timerTask"&gt;
    &lt;ref local="checkEmail"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;
			</pre><p>			
		</p><p>
			<span class="emphasis"><em>Letting the task only run once can be done by changing the <tt class="literal">period</tt> property to -1 (or some other
				negative value)</em></span>				
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11013"></a>19.3.2.&nbsp;Using the MethodInvokingTimerTaskFactoryBean</h3></div></div><div></div></div><p>
			Similar to the Quartz support, the Timer support also features a component that
			allows you to periodically invoke a method:
			</p><pre class="programlisting">
&lt;bean id="methodInvokingTask" 
  class="org.springframework.scheduling.timer.MethodInvokingTimerTaskFactoryBean"&gt;
    &lt;property name="targetObject"&gt;&lt;ref bean="exampleBusinessObject"/&gt;&lt;/property&gt;
    &lt;property name="targetMethod"&gt;&lt;value&gt;doIt&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre><p>
			The above example will result in the <tt class="literal">doIt</tt> being called on the exampleBusinessObject
			(see below):
			</p><pre class="programlisting">
public class BusinessObject {
  
  // properties and collaborators
  
  public void doIt() {
    // do the actual work
  }
}
			</pre><p>
			
			Changing the reference of the above example in which the ScheduledTimerTask is mentioned to the
			<tt class="literal">methodInvokingTask</tt> will result in this task being executed.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11030"></a>19.3.3.&nbsp;Wrapping up: setting up the tasks using the TimerFactoryBean</h3></div></div><div></div></div><p>
			The TimerFactoryBean is similar to the Quartz SchedulerFactoryBean in that it serves the same
			purpose: setting up the actual scheduling. The TimerFactoryBean sets up an actual Timer and
			schedules the tasks it has references to. You can specify whether or not daemon threads should
			be used.
			</p><pre class="programlisting">
&lt;bean id="timerFactory" class="org.springframework.scheduling.timer.TimerFactoryBean"&gt;
  &lt;property name="scheduledTimerTasks"&gt;
    &lt;list&gt;
      &lt;!-- see the example above --&gt;
      &lt;ref local="scheduledTask"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
			</pre><p>	
			That's all!
		</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e11038"></a>Chapter&nbsp;20.&nbsp;JMX Support</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-introduction"></a>20.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The JMX support in Spring provides you with the features to easily
    and transparently integrate your Spring application into a JMX
    infrastructure. Specifically, Spring JMX provides 4 core features:</p><div class="itemizedlist"><ul type="disc"><li><p>Automatic Registration of any Spring bean as a JMX MBean</p></li><li><p>Flexible mechanism for controlling the management interface of
        your beans</p></li><li><p>Declarative exposure of MBeans over remote, JSR-160
        connectors</p></li><li><p>Simple proxying of both local and remote MBean resources</p></li></ul></div><p>These features are designed to work without coupling your
    application components to either Spring or JMX interfaces and classes.
    Indeed, for the most part your application classes need not be aware of
    either Spring or JMX in order to take advantage of the Spring JMX
    features.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-exporting"></a>20.2.&nbsp;Exporting your Beans to JMX</h2></div></div><div></div></div><p>The core class in the Spring JMX framework is the
    <tt class="literal">MBeanExporter</tt>. This class is responsible for taking
    your Spring beans and registering them the JMX
    <tt class="literal">MBeanServer</tt>. For example, consider the simple bean
    class shown below:</p><pre class="programlisting">package org.springframework.jmx;

public class JmxTestBean implements IJmxTestBean {

    private String name;

    private int age;

    private boolean isSuperman;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

}</pre><p>To expose the properties and methods of this bean as attributes and
    operations of a JMX MBean you simply configure an instance of the
    <tt class="literal">MBeanExporter</tt> class in your configuration file and pass
    in the bean as shown below:</p><pre class="programlisting">&lt;beans&gt;
  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name"&gt;
      &lt;value&gt;TEST&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="age"&gt;
      &lt;value&gt;100&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</pre><p>Here, the important definition is the <tt class="literal">exporter</tt>
    bean. The <tt class="literal">beans</tt> property is used to tell the
    <tt class="literal">MBeanExporter</tt> which of your beans should be exported to
    the JMX <tt class="literal">MBeanServer</tt>. The <tt class="literal">beans</tt>
    property is of type <tt class="literal">Map</tt>, and thus you use the
    <tt class="literal">&lt;map&gt;</tt> and <tt class="literal">&lt;entry&gt;</tt> tags
    to configure the beans to be exported. In the default configuration, the
    key of an entry in of the <tt class="literal">Map</tt> is used as the
    <tt class="literal">ObjectName</tt> for the bean that is the value of that
    entry. This behaviour can be changed as described in section XXX.</p><p>With this configuration the <tt class="literal">testBean</tt> bean is
    exposed as a JMX MBean under the <tt class="literal">ObjectName</tt>
    <tt class="literal">bean:name=testBean1</tt>. All public properties of the bean
    are exposed as attributes and all public methods (expect those defined in
    <tt class="literal">Object</tt>) are exposed as operations.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-mbeanserver"></a>20.2.1.&nbsp;Creating an MBeanServer</h3></div></div><div></div></div><p>The configuration shown above assumes that the application is
      running in an environment that has one and only one
      <tt class="literal">MBeanServer</tt> already running. In this case, Spring
      will locate the running <tt class="literal">MBeanServer</tt> and register your
      beans with that. This is useful when your application is running inside
      a container such as Tomcat or IBM WebSphere that has its own
      <tt class="literal">MBeanServer</tt>.</p><p>However, this is approach is no use for standalone environment, or
      when running inside a container that does not provide an
      <tt class="literal">MBeanServer</tt>. To overcome this you can create an
      <tt class="literal">MBeanServer</tt> instance declaratively by adding an
      instance of
      <tt class="literal">org.springframework.jmx.support.MBeanServerFactoryBean</tt>
      to your configuration. You can also ensure that this
      <tt class="literal">MBeanServer</tt> is used by using
      <tt class="literal">MBeanServerFactoryBean</tt> to set the server property of
      the <tt class="literal">MBeanExporter</tt>. This is shown below:</p><pre class="programlisting">&lt;beans&gt;
  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="server"&gt;
      &lt;ref local="mbeanServer"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name"&gt;
      &lt;value&gt;TEST&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="age"&gt;
      &lt;value&gt;100&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"/&gt;
&lt;/beans&gt;</pre><p>Here an instance of <tt class="literal">MBeanServer</tt> is created by
      the <tt class="literal">MBeanServerFactoryBean</tt> and is supplied to the
      <tt class="literal">MBeanExporter</tt> via the server property. When you
      supply your own <tt class="literal">MBeanServer</tt>,
      <tt class="literal">MBeanExporter</tt> will not attempt to locate a running.
      For this to work correctly, you must have a JMX implementation on your
      classpath.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-lazy"></a>20.2.2.&nbsp;Lazy-Initialized MBeans</h3></div></div><div></div></div><p>If you configure a bean with the <tt class="literal">MBeanExporter</tt>
      that is also configured for lazy initialization, then the
      <tt class="literal">MBeanExporter</tt> will NOT break this contract and will
      avoid instantiating the bean. Instead, it will register a proxy with the
      <tt class="literal">MBeanServer</tt> and will defer obtaining the bean from
      the <tt class="literal">BeanFactory</tt> until the first invocation on the
      proxy occurs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-auto"></a>20.2.3.&nbsp;Automatic Registration of MBeans</h3></div></div><div></div></div><p>Any beans that are exported through the
      <tt class="literal">MBeanExporter</tt> and are already valid MBeans are
      registed as is with the <tt class="literal">MBeanServer</tt> without further
      intervention from Spring. MBeans can be automatically detected by the
      <tt class="literal">MBeanExporter</tt> by setting the
      <tt class="literal">autodetect</tt> property to true:</p><pre class="programlisting">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
  &lt;property name="autodetect"&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean name="spring:mbean=true" class="org.springframework.jmx.export.TestDynamicMBean"/&gt;</pre><p>Here, the bean called <tt class="literal">spring:mbean=true</tt> is
      already a valid JMX MBean and will be automatically registered by
      Spring. By default, beans that are autodetected for JMX registration
      have their bean name used as the <tt class="literal">ObjectName</tt>. This
      behavior can be overridden as detailed in section XXX.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-interface"></a>20.3.&nbsp;Controlling the Management Interface of Your Beans</h2></div></div><div></div></div><p>In the previous example, you had little control over the management
    interface of your bean with all the public properties and methods being
    exposed. To solve this proble, Spring JMX provides a comprehensive and
    extensible mechanism for controlling the management interfaces of your
    beans.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-assembler"></a>20.3.1.&nbsp;The <tt class="literal">MBeanInfoAssembler</tt> Interface</h3></div></div><div></div></div><p>Behind the scenes, the <tt class="literal">MBeanExporter</tt> delegates
      to an implementation of the
      <tt class="literal">org.springframework.jmx.export.assembler.MBeanInfoAssembler</tt>
      interface which is responsible for defining the management interface of
      each bean that is being exposed. The default implementation,
      <tt class="literal">org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler</tt>,
      simply defines an interface that exposes all public properties and
      methods as you saw in the previous example. Spring provides two
      additional implementations of the <tt class="literal">MBeanInfoAssembler</tt>
      interface that allow you to control the management interface using
      source level metadata or any arbitrary interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-metadata"></a>20.3.2.&nbsp;Using Source-Level Metadata</h3></div></div><div></div></div><p>Using the <tt class="literal">MetadataMBeanInfoAssembler</tt> you can
      define the management interfaces for your beans using source level
      metadata. The reading of metadata is encapsulated by the
      <tt class="literal">org.springframework.jmx.export.metadata.JmxAttributeSource
      </tt>interface. Out of the box, Spring JMX provides support for two
      implementations of this interface &#8211;
      <tt class="literal">AttributesJmxAttributeSource</tt> for Commons Attributes
      and <tt class="literal">AnnotationsAttributeSource</tt> for JDK 5.0
      annotations. The <tt class="literal">MetadataMBeanInfoAssembler</tt> MUST be
      configured with an implementation of
      <tt class="literal">JmxAttributeSource</tt> for it to function correctly. For
      this example we will use the Commons Attributes metadata
      approach.</p><p>To mark a bean for export to JMX, you should annotate the bean&#8217;s
      class with the <tt class="literal">ManagedResource</tt> attribute. In the case
      of the Commons Attributes metadata approach this class can be found in
      the org.springframework.jmx.metadata package. Each method you wish to
      expose as an operation should be marked with a
      <tt class="literal">ManagedOperation</tt> attribute and each property you wish
      to expose should be marked with a <tt class="literal">ManagedAttribute</tt>
      attribute. When marking properties you can omit either the getter or the
      setter to create a write-only or read-only attribute
      respectively.</p><p>The example below shows the <tt class="literal">JmxTestBean</tt> class
      that you show earlier marked with Commons Attributes metadata:</p><pre class="programlisting">package org.springframework.jmx;

/**
 * @@org.springframework.jmx.export.metadata.ManagedResource
 *  (description="My Managed Bean", objectName="spring:bean=test",
 *  log=true, logFile="jmx.log", currencyTimeLimit=15, persistPolicy="OnUpdate",
 *  persistPeriod=200, persistLocation="foo", persistName="bar")
 *
 */
public class JmxTestBean implements IJmxTestBean {

  private String name;

  private int age;

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *   (description="The Age Attribute", currencyTimeLimit=15)
   */
  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *  (description="The Name Attribute",  currencyTimeLimit=20,
   *   defaultValue="bar", persistPolicy="OnUpdate")
   */
  public void setName(String name) {
    this.name = name;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *   (defaultValue="foo", persistPeriod=300)
   */
  public String getName() {
    return name;
  }


  /**
   * @@org.springframework.jmx.export.metadata.ManagedOperation
   *  (description="Add Two Numbers Together")
   */
  public int add(int x, int y) {
    return x + y;
  }

  public void dontExposeMe() {
    throw new RuntimeException();
  }
}</pre><p>Here you can see that the <tt class="literal">JmxTestBean</tt> class is
      marked with the <tt class="literal">ManagedResource</tt> attribute and that
      this <tt class="literal">ManagedResoure</tt> attribute is configured with a
      set of properties. These properties can be used to configure various
      aspects of the MBean that is generated by the
      <tt class="literal">MBeanExporter</tt> and are explained in greater detail
      later in section <a href="#jmx-interface-metadata-types" title="20.3.4.&nbsp;Source Level Metadata Types">Section&nbsp;20.3.4, &#8220;Source Level Metadata Types&#8221;</a>.</p><p>You will also notice that both the age and name properties are
      marked with the <tt class="literal">ManagedAttribute</tt> attribute but in the
      case of the <tt class="literal">age</tt> property, only the getter is marked.
      This will cause both of these properties to be included in the
      management interface as attributes, and for the <tt class="literal">age</tt>
      attribute to be read-only.</p><p>Finally, you will notice that the <tt class="literal">add(int, int)</tt>
      method is marked with the <tt class="literal">ManagedOperation</tt> attribute
      whereas the <tt class="literal">dontExposeMe() </tt>method is not. This will
      casue the management interface to contain only one operation,
      <tt class="literal">add(int, int)</tt>, when using the
      <tt class="literal">MetadataMBeanInfoAssembler</tt>.</p><p>The code below shows how you configure the
      <tt class="literal">MBeanExporter</tt> to use the
      <tt class="literal">MetadataMBeanInfoAssembler</tt>:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" 
 "http://www.springframework.org/dtd/spring-beans.dtd"&gt;
&lt;beans&gt;
  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
      &lt;ref local="assembler"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
  
  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name"&gt;
      &lt;value&gt;TEST&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="age"&gt;
      &lt;value&gt;100&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="attributeSource" 
        class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"/&gt;

  &lt;bean id="assembler" class="org.springframework.jmx.assembler.MetadataMBeanInfoAssembler"&gt;
    &lt;property name="attributeSource"&gt;
      &lt;ref local="attributeSource"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</pre><p>Here you can see that a
      <tt class="literal">MetadataMBeanInfoAssembler</tt> bean has been configured
      with an instance of <tt class="literal">AttributesJmxAttributeSource</tt> and
      passed to the <tt class="literal">MBeanExporter</tt> through the assembler
      property. This is all that is required to take advantage of
      metadata-driven management interfaces for your Spring-exposed
      MBeans.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-annotations"></a>20.3.3.&nbsp;Using JDK 5.0 Annotations</h3></div></div><div></div></div><p>To enable the use of JDK 5.0 annotations for management interface
      definition, Spring provides a set of annotations that mirror the Commons
      Attribute attribute classes and an implementation of
      <tt class="literal">JmxAttributeSource</tt>,
      <tt class="literal">AnnotationsJmxAttributeSource</tt>, that allows the
      <tt class="literal">MBeanInfoAssembler</tt> to read them.</p><p>The example below shows a bean with a JDK 5.0 annotation defined
      management interface:</p><pre class="programlisting">package org.springframework.jmx;

import org.springframework.jmx.export.annotation.ManagedResource;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedAttribute;

@ManagedResource(objectName="bean:name=testBean4", description="My Managed Bean", log=true,
    logFile="jmx.log", currencyTimeLimit=15, persistPolicy="OnUpdate", persistPeriod=200,
    persistLocation="foo", persistName="bar")
public class AnnotationTestBean implements IJmxTestBean {

   private String name;

  private int age;

  @ManagedAttribute(description="The Age Attribute", currencyTimeLimit=15)
  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  @ManagedAttribute(description="The Name Attribute",
      currencyTimeLimit=20,
      defaultValue="bar",
      persistPolicy="OnUpdate")
  public void setName(String name) {
    this.name = name;
  }

  @ManagedAttribute(defaultValue="foo", persistPeriod=300)
  public String getName() {
    return name;
  }

  @ManagedOperation(description="Add Two Numbers Together")
  public int add(int x, int y) {
    return x + y;
  }

  public void dontExposeMe() {
    throw new RuntimeException();
  }
}</pre><p>As you can see little has changed, other than the basic syntax of
      the metadata definitions. Behind the scenes this approach is a little
      slower at startup because the JDK 5.0 annotations are converted into the
      classes used by Commons Attributes. However, this is only a one-off cost
      and JDK 5.0 annotations give you the benefit of compile-time
      checking.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-metadata-types"></a>20.3.4.&nbsp;Source Level Metadata Types</h3></div></div><div></div></div><p>The following source level metadata types are available for use in
      Spring JMX:</p><div class="table"><a name="d0e11381"></a><p class="title"><b>Table&nbsp;20.1.&nbsp;Source-Level Metadata Types</b></p><table summary="Source-Level Metadata Types" border="1"><colgroup><col align="left"><col><col><col></colgroup><thead><tr><th align="center">Purpose</th><th align="center">Commons Attributes Attribute</th><th align="center">JDK 5.0 Annotation</th><th align="center">Annotation/Attribute Type</th></tr></thead><tbody><tr><td align="left">Mark all instances of a Class as JMX managed
                resources</td><td><tt class="literal">ManagedResource</tt></td><td><tt class="literal">@ManagedResource</tt></td><td>Class</td></tr><tr><td align="left">Mark a method as a JMX operation</td><td><tt class="literal">ManagedOperation</tt></td><td><tt class="literal">@ManagedOperation</tt></td><td>Method</td></tr><tr><td align="left">Mark a getter or setter as one half of a JMX
                attribute</td><td><tt class="literal">ManagedAttribute</tt></td><td><tt class="literal">@ManagedAttribute</tt></td><td>Method (only getters and setters)</td></tr><tr><td align="left">Define descriptions for operation parameters</td><td><tt class="literal">ManagedOperationParameter</tt></td><td><tt class="literal">@ManagedOperationParameter</tt> and
                <tt class="literal">@ManagedOperationParameters</tt></td><td>Method</td></tr></tbody></table></div><p>The following configuration parameters are available for use on
      these source-level metadata types:</p><div class="table"><a name="d0e11447"></a><p class="title"><b>Table&nbsp;20.2.&nbsp;Source-Level Metadata Parameters</b></p><table summary="Source-Level Metadata Parameters" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="center">Parameter</th><th align="center">Description</th><th align="center">Applies to</th></tr></thead><tbody><tr><td align="left"><tt class="literal">objectName</tt></td><td>Used by <tt class="literal">MetadataNamingStrategy</tt> to
                determine the <tt class="literal">ObjectName</tt> of a managed
                resource</td><td><tt class="literal">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">description</tt></td><td>Sets the friendly description of the resource,
                attribute or operation</td><td><tt class="literal">ManagedResource</tt>,
                <tt class="literal">ManagedAttribute</tt>,
                <tt class="literal">ManagedOperation</tt>,
                <tt class="literal">ManagedOperationParameter</tt></td></tr><tr><td align="left"><tt class="literal">currencyTimeLimit</tt></td><td>Sets the value of the
                <tt class="literal">currencyTimeLimit</tt> descriptor field</td><td><tt class="literal">ManagedResource</tt>,
                <tt class="literal">ManagedAttribute</tt></td></tr><tr><td align="left"><tt class="literal">defaultValue</tt></td><td>Sets the value of the <tt class="literal">defaultValue</tt>
                descriptor field</td><td><tt class="literal">ManagedAttribute</tt></td></tr><tr><td align="left"><tt class="literal">log</tt></td><td>Sets the value of the <tt class="literal">log</tt> descriptor
                field</td><td><tt class="literal">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">logFile</tt></td><td>Sets the value of the <tt class="literal">logFile</tt>
                descriptor field</td><td><tt class="literal">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">persistPolicy</tt></td><td>Sets the value of the <tt class="literal">persistPolicy</tt>
                descriptor field</td><td><tt class="literal">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">persistPeriod</tt></td><td>Sets the value of the <tt class="literal">persistPeriod</tt>
                descriptor field</td><td><tt class="literal">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">persistLocation</tt></td><td>Sets the value of the
                <tt class="literal">persistLocation</tt> descriptor field</td><td><tt class="literal">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">persistName</tt></td><td>Sets the value of the <tt class="literal">persistName</tt>
                descriptor field</td><td><tt class="literal">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">name</tt></td><td>Sets the display name of an operation parameter</td><td><tt class="literal">ManagedOperationParameter</tt></td></tr><tr><td align="left"><tt class="literal">index</tt></td><td>Sets the index of an operation parameter</td><td><tt class="literal">ManagedOperationParameter</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-autodetect"></a>20.3.5.&nbsp;The <tt class="literal">AutodetectCapableMBeanInfoAssembler</tt>
      Interface</h3></div></div><div></div></div><p>To simply configuration even further, Spring introduces the
      <tt class="literal">AutodetectCapableMBeanInfoAssembler</tt> interface which
      extends the <tt class="literal">MBeanInfoAssembler</tt> interface to add
      support for autodetection of MBean resources. If you configure the
      <tt class="literal">MBeanExporter</tt> with an instance of
      <tt class="literal">AutodetectCapableMBeanInfoAssembler</tt> then it is
      allowed to &#8216;vote&#8217; on the inclusion of beans for exposure to JMX.</p><p>Out of the box, the only implementation of
      <tt class="literal">AutodetectCapableMBeanInfo</tt> is the
      <tt class="literal">MetadataMBeanInfoAssembler</tt> which will vote to include
      any bean which is marked with the <tt class="literal">ManagedResource</tt>
      attribute. The default approach in this case is to use the bean name as
      the <tt class="literal">ObjectName</tt> which results in a configuration like
      this:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" 
 "http://www.springframework.org/dtd/spring-beans.dtd"&gt;
&lt;beans&gt;
  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="assembler"&gt;
      &lt;ref local="assembler"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="bean:name=testBean1" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name"&gt;
      &lt;value&gt;TEST&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="age"&gt;
      &lt;value&gt;100&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
  
  &lt;bean id="attributeSource" 
        class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"/&gt;

  &lt;bean id="assembler" class="org.springframework.jmx.assembler.MetadataMBeanInfoAssembler"&gt;
    &lt;property name="attributeSource"&gt;
      &lt;ref local="attributeSource"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</pre><p>Notice that in this configuration no beans are passed to the
      <tt class="literal">MBeanExporter</tt>, however the
      <tt class="literal">JmxTestBean</tt> will still be registered since it is
      marked with the <tt class="literal">ManagedResource</tt> attribute and the
      <tt class="literal">MetadataMBeanInfoAssembler</tt> detects this and votes to
      include it. The only problem with this approach is that the name of the
      <tt class="literal">JmxTestBean</tt> now has business meaning. You can solve
      this problem by changing the default behavior for
      <tt class="literal">ObjectName</tt> creation as defined in section <a href="#jmx-naming" title="20.4.&nbsp;Controlling the ObjectNames for your&#xA;    Beans">Section&nbsp;20.4, &#8220;Controlling the ObjectNames for your
    Beans&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-java"></a>20.3.6.&nbsp;Defining Management Interfaces using Java Interfaces</h3></div></div><div></div></div><p>In addition to the <tt class="literal">MetadataMBeanInfoAssembler</tt>,
      Spring also includes the
      <tt class="literal">InterfaceBasedMBeanInfoAssembler</tt> which allows you to
      constrain the methods and properties that are exposed based on the set
      of methods defined in a collection of interfaces.</p><p>Although the standard mechanism for exposing MBeans is to use
      interfaces and a simple naming scheme, the
      <tt class="literal">InterfaceBasedMBeanInfoAssembler</tt> extends this
      functionality by removing the need for naming conventions, allowing you
      to use more than one interface and removing the need for your beans to
      implement the MBean interfaces.</p><p>Consider this interface that is used to define a management
      interface for the <tt class="literal">JmxTestBean</tt> class that you saw
      earlier:</p><pre class="programlisting">public interface IJmxTestBean {

  public int add(int x, int y);

  public long myOperation();

  public int getAge();

  public void setAge(int age);

  public void setName(String name);

  public String getName();  
}</pre><p>This interface defines the methods and properties that will be
      exposed as operations and attributes on the JMX MBean. The code below
      shows how to configure Spring JMX to use this interface as the
      definition for the management interface:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean5"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
      &lt;bean class="org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"&gt;
        &lt;property name="managedInterfaces"&gt;
          &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;/value&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name"&gt;
      &lt;value&gt;TEST&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="age"&gt;
      &lt;value&gt;100&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Here you can see that the
      <tt class="literal">InterfaceBasedMBeanInfoAssembler</tt> is configured to use
      the <tt class="literal">IJmxTestBean</tt> interface when constructing the
      management interface for any bean. It is important to understand that
      beans processed by the
      <tt class="literal">InterfaceBasedMBeanInfoAssembler</tt> are NOT required to
      implement the interface used to generate the JMX management
      interface.</p><p>In the case above, the <tt class="literal">IJmxTestBean</tt> interface
      is used to construct all management interfaces for all beans. In many
      cases this is not the desired behavior and you may want to use different
      interfaces for different beans. In this case, you can pass
      <tt class="literal">InterfaceBasedMBeanInfoAssembler</tt> a
      <tt class="literal">Properties</tt> via the
      <tt class="literal">interfaceMappings</tt> property, where the key of each
      entry is the bean name and the value of each entry is a comma-seperated
      list of interface names to use for that bean.</p><p>If no management interface is specified through either the
      <tt class="literal">managedInterfaces</tt> or
      <tt class="literal">interfaceMappings</tt> properties, then
      <tt class="literal">InterfaceBasedMBeanInfoAssembler</tt> will reflect on the
      bean and use all interfaces implemented by that bean to create the
      management interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-methodnames"></a>20.3.7.&nbsp;Using
      <tt class="literal">MethodNameBasedMBeanInfoAssembler</tt></h3></div></div><div></div></div><p>The <tt class="literal">MethodNameBasedMBeanInfoAssembler</tt> allows
      you to specify a list of method names that will be exposed to JMX as
      attributes and operations. The code below shows a sample configuration
      for this:</p><pre class="programlisting">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean5"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
      &lt;bean class="org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler"&gt;
        &lt;property name="managedMethods"&gt;
          &lt;value&gt;add,myOperation,getName,setName,getAge&lt;/value&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Here you can see that the methods <tt class="literal">add</tt> and
      <tt class="literal">myOperation</tt> will be exposed as JMX operations and
      <tt class="literal">getName</tt>, <tt class="literal">setName</tt> and
      <tt class="literal">getAge</tt> will be exposed as the appropriate half of a
      JMX attribute. In the code above, the method mappings apply to beans
      that are exposed to JMX. To control method exposure on a bean by bean
      basis, use the <tt class="literal">methodMappings</tt> property of
      <tt class="literal">MethodNameMBeanInfoAssembler</tt> to map bean names to
      lists of method names.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-naming"></a>20.4.&nbsp;Controlling the <tt class="literal">ObjectName</tt>s for your
    Beans</h2></div></div><div></div></div><p>Behind the scenes, the <tt class="literal">MBeanExporter</tt> delegates to
    an implementation of the <tt class="literal">ObjectNamingStrategy</tt> to obtain
    <tt class="literal">ObjectName</tt>s for each of the beans it is registering.
    The default implementation, <tt class="literal">KeyNamingStrategy</tt>, will, by
    default, use the key of the <tt class="literal">beans</tt>
    <tt class="literal">Map</tt> as the <tt class="literal">ObjectName</tt>. In addition,
    the <tt class="literal">KeyNamingStrategy</tt> can map the key of the
    <tt class="literal">beans</tt> <tt class="literal">Map</tt> to an entry in a
    <tt class="literal">Properties</tt> file (or files) to resolve the
    <tt class="literal">ObjectName</tt>. In addition to the
    <tt class="literal">KeyNamingStrategy</tt>, Spring provides two additional
    <tt class="literal">ObjectNamingStrategy</tt> implementations:
    <tt class="literal">IdentityNamingStrategy</tt> that builds an
    <tt class="literal">ObjectName</tt> based on the identity of the bean and
    <tt class="literal">MetadataNamingStrategy</tt> that uses the source level
    metadata to obtain the <tt class="literal">ObjectName</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-naming-properties"></a>20.4.1.&nbsp;Reading <tt class="literal">ObjectName</tt>s from
      <tt class="literal">Properties</tt></h3></div></div><div></div></div><p>You can configure your own <tt class="literal">KeyNamingStrategy</tt>
      instance and configure it to read <tt class="literal">ObjectName</tt>s from a
      <tt class="literal">Properties</tt> instance rather than use bean key. The
      <tt class="literal">KeyNamingStrategy</tt> will attempt to locate an entry in
      the <tt class="literal">Properties</tt> with a key corresponding to the bean
      key. If no entry is found or if the <tt class="literal">Properties</tt>
      instance is null then the bean key itself is used.</p><p>The code below shows a sample configuration for the
      <tt class="literal">KeyNamingStrategy</tt>:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" 
 "http://www.springframework.org/dtd/spring-beans.dtd"&gt;
&lt;beans&gt;
  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="testBean"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="namingStrategy"&gt;
      &lt;ref local="namingStrategy"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name"&gt;
      &lt;value&gt;TEST&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="age"&gt;
      &lt;value&gt;100&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.KeyNamingStrategy"&gt;
    &lt;property name="mappings"&gt;
      &lt;props&gt;
        &lt;prop key="testBean"&gt;bean:name=testBean1&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name="mappingLocations"&gt;
      &lt;value&gt;names1.properties,names2.properties&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean
&lt;/beans&gt;</pre><p>Here an instance of <tt class="literal">KeyNamingStrategy</tt> is
      configured with a <tt class="literal">Properties</tt> instance that is merged
      from the <tt class="literal">Properties</tt> instance defined by the mapping
      property and the properties files located in the paths defined by the
      mappings property. In this configuration, the
      <tt class="literal">testBean</tt> bean will be given the
      <tt class="literal">ObjectName</tt> <tt class="literal">bean:name=testBean1
      </tt>since this is the entry in the <tt class="literal">Properties</tt>
      instance that has a key corresponding to the bean key.</p><p>If no entry in the <tt class="literal">Properties</tt> instance can be
      found then the bean key is used as the
      <tt class="literal">ObjectName</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-naiming-metadata"></a>20.4.2.&nbsp;Using the <tt class="literal">MetadataNamingStrategy</tt></h3></div></div><div></div></div><p>The <tt class="literal">MetadataNamingStrategy</tt> uses
      <tt class="literal">objectName</tt> property of the
      <tt class="literal">ManagedResource</tt> attribute on each bean to create the
      <tt class="literal">ObjectName</tt>. The code below shows the configuration
      for the <tt class="literal">MetadataNamingStrategy</tt>:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" 
 "http://www.springframework.org/dtd/spring-beans.dtd"&gt;
&lt;beans&gt;
  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="testBean"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="namingStrategy"&gt;
      &lt;ref local="namingStrategy"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name"&gt;
      &lt;value&gt;TEST&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="age"&gt;
      &lt;value&gt;100&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
  
  &lt;bean id="attributeSource" 
        class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"/&gt;

  &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
    &lt;property name="attributeSource"&gt;
      &lt;ref local="attributeSource"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-jsr160"></a>20.5.&nbsp;Exporting your Beans with JSR-160 Connectors</h2></div></div><div></div></div><p>For remote access, Spring JMX module offers two
    <tt class="literal">FactoryBean</tt> implementations inside the
    <tt class="literal">org.springframework.jmx.support</tt> package for creating
    server-side and client-side connectors.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-jsr160-server"></a>20.5.1.&nbsp;Server-side Connectors</h3></div></div><div></div></div><p>To have Spring JMX create,start and expose a JSR-160
      <tt class="literal">JMXConnectorServer</tt> use the following
      configuration:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"/&gt;</pre><p>By default <tt class="literal">ConnectorServerFactoryBean</tt> creates a
      <tt class="literal">JMXConnectorServer</tt> bound to
      &#8220;service:jmx:jmxmp://localhost:9875&#8221;. The serverConnector bean thus
      exposes the local <tt class="literal">MBeanServer</tt> to clients through the
      jmxmp protocol on localhost, port 9875. Note that JMXMP protocol is
      marked as optional by the JSR 160 &#8211; currently popular open-source
      implementation MX4J and the one provided with Java 5.0 do not support
      JMXMP.</p><p>To specify another URL and register the
      <tt class="literal">JMXConnectorServer</tt> itself with the
      <tt class="literal">MBeanServer</tt> use the <tt class="literal">serviceUrl</tt> and
      <tt class="literal">objectName</tt> properties respectively:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
    &lt;property name="objectName"&gt;
      &lt;value&gt;connector:name=rmi&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="serviceUrl"&gt;
      &lt;value&gt;service:jmx:rmi://localhost:9875&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>If the <tt class="literal">objectName</tt> property is set Spring will
      automatically register your connector with the
      <tt class="literal">MBeanServer</tt> under that <tt class="literal">ObjectName</tt>.
      The example below shows the full set of parameters which you can pass to
      the <tt class="literal">ConnectorServerFactoryBean</tt> when creating the
      JMXConnector:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
    &lt;property name="objectName"&gt;
      &lt;value&gt;connector:name=iiop&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="serviceUrl"&gt;
      &lt;value&gt;service:jmx:iiop://localhost:9875&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="threaded"&gt;
      &lt;value&gt;true&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="daemon"&gt;
      &lt;value&gt;true&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="environment"&gt;
      &lt;map&gt;
        &lt;entry key="someKey"&gt;
         &lt;value&gt;someValue&lt;/value&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>For more information on these properties consult the
      JavaDoc.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-jsr160-client"></a>20.5.2.&nbsp;Client-side Connectors</h3></div></div><div></div></div><p>To create an <tt class="literal">MBeanServerConnection</tt> to a remote
      JSR-160 enabled <tt class="literal">MBeanServer</tt> use the
      <tt class="literal">MBeanServerConnectionFactoryBean</tt> as shown
      below:</p><pre class="programlisting">&lt;bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
    &lt;property name="serviceUrl"&gt;
      &lt;value&gt;service:jmx:rmi://localhost:9876&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-jsr160-protocols"></a>20.5.3.&nbsp;JMX over Burlap/Hessian/SOAP</h3></div></div><div></div></div><p>JSR-160 permits extensions to the way in which communication is
      done between the client and the server. The examples above are using the
      mandatory RMI-based implementation required by the JSR-160(IIOP and
      JRMP) and the optional JMXMP. By using other providers or
      implementations like <a href="http://mx4j.sourceforge.net" target="_top">MX4J</a> you can take advantage of
      protocols like SOAP, Hessian, Burlap over simple HTTP or SSL and
      other:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
  &lt;property name="objectName"&gt;
    &lt;value&gt;connector:name=burlap&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="serviceUrl"&gt;
    &lt;value&gt;service:jmx:burlap://localhost:9874&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>For this example MX4J 3.0.0 was used &#8211; see the official MX4J
      documentation for more information.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-proxy"></a>20.6.&nbsp;Accessing MBeans via Proxies</h2></div></div><div></div></div><p>Spring JMX allows you to create proxies that re-route calls to
    MBeans registered in a local or remote <tt class="literal">MBeanServer</tt>.
    These proxies provide you with a standard Java interface through which you
    can interact with your MBeans. The code below shows how to to configure a
    proxy for an MBean running in the local
    <tt class="literal">MBeanServer</tt>:</p><pre class="programlisting">&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
    &lt;property name="objectName"&gt;
      &lt;value&gt;bean:name=testBean&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="proxyInterface"&gt;
      &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Here you can see that a proxy is created for the MBean registered
    under the <tt class="literal">ObjectName</tt>:
    <tt class="literal">bean:name=testBean</tt>. The set of interfaces that the
    proxy will implement is controlled by the
    <tt class="literal">proxyInterfaces</tt> property and the rules for mapping
    methods and properties on these interfaces to operations and attributes on
    the MBean are the same rules used by the
    <tt class="literal">InterfaceBasedMBeanInfoAssembler</tt>.</p><p>The <tt class="literal">MBeanProxyFactoryBean</tt> can create a proxy to
    any MBean that is accessible via an
    <tt class="literal">MBeanServerConnection</tt>. By default, the local
    <tt class="literal">MBeanServer</tt> is located and used, but you can override
    this and provide an <tt class="literal">MBeanServerConnection</tt> pointing to a
    remote <tt class="literal">MBeanServer</tt> allowing for proxies pointing to
    remote MBeans:</p><pre class="programlisting">&lt;bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
    &lt;property name="serviceUrl"&gt;
      &lt;value&gt;service:jmx:rmi://remotehost:9876&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
    &lt;property name="objectName"&gt;
      &lt;value&gt;bean:name=testBean&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="proxyInterface"&gt;
      &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Here you can see that we create an
    <tt class="literal">MBeanServerConnection</tt> pointing to a remote machine
    using the <tt class="literal">MBeanServerConnectionFactoryBean</tt>. This
    <tt class="literal">MBeanServerConnection</tt> is then passed to the
    <tt class="literal">MBeanProxyFactoryBean</tt> via the <tt class="literal">server</tt>
    property. The proxy that is created will pass on all invocations to the
    <tt class="literal">MBeanServer</tt> via this
    <tt class="literal">MBeanServerConnection</tt>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="testing"></a>Chapter&nbsp;21.&nbsp;Testing</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="unit-testing"></a>21.1.&nbsp;Unit testing</h2></div></div><div></div></div><p>You don't need this manual to help you write effective unit
    tests for Spring-based applications.</p><p>One of the main benefits of Dependency Injection is that your code
    should depend far less on the container than in traditional J2EE
    development.</p><p>The POJOs that comprise your application should be testable in JUnit
    tests, with objects simply instantiated using the new operator,
    <span class="emphasis"><em>without Spring or any other container</em></span>. You can use
    mock objects or many other valuable testing techniques, to test your code
    in isolation. If you follow the architecture recommendations around
    Spring--for example, those in <span class="emphasis"><em>J2EE without EJB</em></span>--you
    will find that the resulting clean layering will also greatly facilitate
    testing. For example, you will be able to test service layer objects by
    stubbing or mocking DAO interfaces, without any need to access persistent
    data while running unit tests.</p><p>True unit tests will run extremely quickly, as there is no runtime
    infrastructure to set up, whether application server, database, ORM tool
    etc. Thus emphasizing true unit tests will boost your productivity.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-testing"></a>21.2.&nbsp;Integration testing</h2></div></div><div></div></div><p>However, it's also important to be able to perform some
    integration testing without deployment to your application server. This
    will test things such as:</p><div class="itemizedlist"><ul type="disc"><li><p>Correct wiring of your Spring contexts.</p></li><li><p>Data access using JDBC or ORM tool--correctness of SQL
        statements. For example, you can test your DAO implementation classes.</p></li></ul></div><p>Thus Spring provides valuable support for integration testing, in
    the <tt class="literal">spring-mock.jar.</tt> This can be thought of as a
    significantly superior alternative to in-container testing using tools
    such as Cactus. </p><p>The <tt class="literal">org.springframework.test </tt>package provides
    valuable superclasses for integration tests using a Spring container, but
    not dependent on an application server or other deployed environment. Such
    tests can run in JUnit--even in an IDE--without any special deployment
    step. They will be slower to run than unit tests, but much faster to run
    than Cactus tests or remote tests relying on deployment to an application
    server.</p><p>The superclasses in this package provide the following
    functionality:</p><div class="itemizedlist"><ul type="disc"><li><p>Context caching.</p></li><li><p>Dependency Injection for test classes.</p></li><li><p>Transaction management appropriate to tests.</p></li><li><p>Inherited instance variables useful for testing.</p></li></ul></div><p>Numerous Interface21 and other projects since late 2004 have
    demonstrated the power and utility of this approach. Let's look at
    some of the important areas of functionality in detail.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12141"></a>21.2.1.&nbsp;Context management and caching</h3></div></div><div></div></div><p>The <tt class="literal">org.springframework.test</tt> package provides
      support for consistent loading of Spring contexts, and caching of loaded
      contexts. The latter is important, because if you are working on a large
      project startup time may become an issue--not because of the overhead of
      Spring itself, but because the objects instantiated by the Spring
      container will themselves take time to instantiate. For example, a
      project with 50-100 Hibernate mapping files might take 10-20 seconds to
      load them, and incurring that cost before running every test case will
      greatly reduce productivity.</p><p>Thus, <tt class="literal">AbstractDependencyInjectionSpringContextTests</tt>
      has an abstract protected method that subclasses must implement, to
      provide the location of contexts:</p><pre class="programlisting">protected abstract String[] getConfigLocations();</pre><p>This should provide a list of the context locations--typically on
      the classpath--used to configure the application. This will be the same,
      or nearly the same, as the list of config locations specified in web.xml
      or other deployment configuration.</p><p>By default, once loaded, the set of configs will be reused for
      each test case. Thus the setup cost will be incurred only once, and
      subsequent test execution will be much faster.</p><p>In the unlikely case that a test may "dirty" the config
      location, requiring reloading--for example, by changing a bean
      definition or the state of an application object--you can call the
      <tt class="literal">setDirty()</tt> method on <tt class="literal">AbstractDependencyInjectionSpringContextTests</tt>
      to cause it to reload the configurations and rebuild the application
      context before executing the next test case.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12169"></a>21.2.2.&nbsp;Dependency Injection of test class instances</h3></div></div><div></div></div><p>When <tt class="literal">AbstractDependencyInjectionSpringContextTests</tt>
      (and subclasses) load your application context, they can optionally
      configure instances of yourr test classes by Setter Injection. All you
      need to do is to define instance variables and the corresponding
      setters. <tt class="literal">AbstractDependencyInjectionSpringContextTests</tt>
      will automatically locate the corresponding object in the set of
      configuration files specified in the<tt class="literal"> getConfigLocations()
      </tt>method. </p><p>The superclasses use <span class="emphasis"><em>autowire by type</em></span>. Thus
      if you have multiple bean definitions of the same type, you cannot rely
      on this approach for those particular beans. In that case, you can use
      the inherited <tt class="literal">applicationContext</tt> instance variable,
      and explicit lookup using <tt class="literal">getBean()</tt>.</p><p>If you don't want Setter Injection applied to your test cases,
      don't declare any setters. Or extend <tt class="literal">AbstractSpringContextTests</tt>--the
      root of the class hierarchy in the <tt class="literal">org.springframework.test</tt>
      package. It merely contains convenience methods to load Spring contexts,
      and performs no Dependency Injection.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12202"></a>21.2.3.&nbsp;Transaction management</h3></div></div><div></div></div><p>One common problem in tests that access a real database is their
      effect on the state of the persistence store. Even when you're using
      a development database, changes to the state may affect future tests.</p><p>Also, many operations--such as inserting to or modifying
      persistence data--can't be done (or verified) outside a transaction.</p><p>The <tt class="literal">org.springframework.test.AbstractTransactionalDataSourceSpringContextTests</tt>
      superclass (and subclasses) exist to meet this need. By default, they
      create and roll back a transaction for each test case. You simply write
      code that can assume the existence of a transaction. If you call
      transactionally proxied objects in your tests, they will behave
      correctly, according to their transactional semantics.</p><p><tt class="literal">AbstractTransactionalSpringContextTests</tt> depends
      on a <tt class="literal">PlatformTransactionManager</tt> bean being defined in
      the application context. The name doesn't matter, due to the use of
      autowire by type.</p><p>Typically you will extend the subclass, <tt class="literal">AbstractTransactionalDataSourceSpringContextTests</tt>.
      This also requires a <tt class="literal">DataSource</tt> bean
      definition--again, with any name--is present in the configurations. It
      creates a <tt class="literal">JdbcTemplate</tt> instance variable that is
      useful for convenient querying, and provides handy methods to delete the
      contents of selected tables. (Remember that the transaction will roll
      back by default, so this is safe.)</p><p>If you want a transaction to commit--unusual, but useful if you
      want a particular test to populate the database, for example--you can
      call the <tt class="literal">setComplete()</tt> method inherited from
      <tt class="literal">AbstractTransactionalSpringContextTests</tt>. This will
      cause the transaction to commit instead of roll back.</p><p>There is also convenient ability to end a transaction before the
      test case ends, through calling the <tt class="literal">endTransaction() </tt>method.
      This will roll back the transaction by default, and commit it only if
      <tt class="literal">setComplete() </tt>had previously been called. This
      functionality is useful if you want to test the behaviour of
      "disconnected" data objects, such as Hibernate-mapped objects
      that will be used in a web or remoting tier outside a transaction.
      Often, lazy loading errors are discovered only through UI testing; if
      you call <tt class="literal">endTransaction()</tt> you can ensure correct
      operation of the UI through your JUnit test suite.</p><p><i><span class="remark">Note that these test support classes are designed to work
      with a single database.</span></i></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12254"></a>21.2.4.&nbsp;Convenience variables</h3></div></div><div></div></div><p>When you extend org.springframework.test package you will have
      access to the following protected instance variables:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">applicationContext</tt> (<tt class="literal">ConfigurableApplicationContext</tt>):
          inherited from AbstractDependencyInjectionSpringContextTests. Use
          this to perfom explicit bean lookup, or test the state of the
          context as a whole.</p></li><li><p><tt class="literal">jdbcTemplate</tt>: inherited from
          <tt class="literal">AbstractTransactionalDataSourceSpringContextTests</tt>.
          Useful for querying to confirm state. For example, you might query
          before and after testing application code that creates an object and
          persists it using an ORM tool, to verify that the data appears in
          the database. (Spring will ensure that the query runs in the scope
          of the same transaction.) You will need to tell your ORM tool to
          "flush" its changes for this to work correctly, for example
          using the <tt class="literal">flush() </tt>method on Hibernate's
          <tt class="literal">Session</tt> interface.</p></li></ul></div><p>Often you will provide an application-wide superclass for
      integration tests that provides further useful instance variables used
      in many tests.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12284"></a>21.2.5.&nbsp;Example</h3></div></div><div></div></div><p>The PetClinic sample application included with the Spring
      distribution illustrates the use of these test superclasses (Spring
      1.1.5 and above).</p><p>Most test functionality is included in <tt class="literal">AbstractClinicTests</tt>,
      for which a partial listing is shown belong:</p><pre class="programlisting">public abstract class AbstractClinicTests extends AbstractTransactionalDataSourceSpringContextTests {

   protected Clinic clinic;

   public void setClinic(Clinic clinic) {
      this.clinic = clinic;
   }

   public void testGetVets() {
      Collection vets = this.clinic.getVets();
      assertEquals("JDBC query must show the same number of vets",
         jdbcTemplate.queryForInt("SELECT COUNT(0) FROM VETS"), 
         vets.size());
      Vet v1 = (Vet) EntityUtils.getById(vets, Vet.class, 2);
      assertEquals("Leary", v1.getLastName());
      assertEquals(1, v1.getNrOfSpecialties());
      assertEquals("radiology", ((Specialty) v1.getSpecialties().get(0)).getName());
      Vet v2 = (Vet) EntityUtils.getById(vets, Vet.class, 3);
      assertEquals("Douglas", v2.getLastName());
      assertEquals(2, v2.getNrOfSpecialties());
      assertEquals("dentistry", ((Specialty) v2.getSpecialties().get(0)).getName());
      assertEquals("surgery", ((Specialty) v2.getSpecialties().get(1)).getName());
}</pre><p>Notes:</p><div class="itemizedlist"><ul type="disc"><li><p>This test case extends <tt class="literal">org.springframework.AbstractTransactionalDataSourceSpringContextTests</tt>,
          from which it inherits Dependency Injection and transactional
          behaviour.</p></li><li><p>The <tt class="literal">clinic</tt> instance variable--the
          application object being tested--is set by Dependency Injection
          through the setClinic() method.</p></li><li><p>The testGetVets() method illustrates how the inherited
          <tt class="literal">JdbcTemplate</tt> variable can be used to verify
          correct behaviour of the application code being tested. This allows
          for stronger tests, and lessens dependency on the exact test data.
          For example, you can add additional rows in the database without
          breaking tests.</p></li><li><p>Like many integration tests using a database, most of the
          tests in <tt class="literal">AbstractClinicTests</tt> depend on a minimum
          amount of data already in the database before the test cases run.
          You might, however, choose to populate the database in your test
          cases also--again, within the one transaction.</p></li></ul></div><p>The PetClinic application supports three data access
      technologies--JDBC, Hibernate and Apache OJB. Thus <tt class="literal">AbstractClinicTests</tt>
      does not specify the context locations--this is deferred to subclasses,
      that implement the necessary protected abstract method from
      <tt class="literal">AbstractDependencyInjectionSpringContextTests</tt>.</p><p>For example, the JDBC implementation of the PetClinic tests
      contains the following method:</p><pre class="programlisting">public class HibernateClinicTests extends AbstractClinicTests {

   protected String[] getConfigLocations() {
      return new String[] { 
         "/org/springframework/samples/petclinic/hibernate/applicationContext-hibernate.xml" 
      };
   }
}</pre><p>As the PetClinic is a very simple application, there is only one
      Spring configuration file. Of course, more complex applications will
      typically break their Spring configuration across multiple files.</p><p>Instead of being defined in a leaf class, config locations will
      often be specified in a common base class for all application-specific
      integration tests. This may also add useful instance
      variables--populated by Dependency Injection, naturally--such as a
      <tt class="literal">HibernateTemplate</tt>, in the case of an application
      using Hibernate.</p><p>As far as possible, you should have exactly the same Spring
      configuration files in your integration tests as in the deployed
      environment. One likely point of difference concerns database connection
      pooling and transaction infrastructure. If you are deploying to a
      full-blown application server, you will probably use its connection pool
      (available through JNDI) and JTA implementation. Thus in production you
      will use a <tt class="literal">JndiObjectFactoryBean</tt> for the
      <tt class="literal">DataSource</tt>, and <tt class="literal">JtaTransactionManager</tt>.
      JNDI and JTA will not be available in out-of-container integration
      tests, so you should use a combination like the Commons DBCP
      <tt class="literal">BasicDataSource</tt> and <tt class="literal">DataSourceTransactionManager</tt>
      or <tt class="literal">HibernateTransactionManager</tt> for them. You can
      factor out this variant behaviour into a single XML file, having the
      choice between application server and "local" configuration
      separated from all other configuration, which will not vary between the
      test and production environments.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12363"></a>21.2.6.&nbsp;Running integration tests</h3></div></div><div></div></div><p>Integration tests naturally have more environmental dependencies
      than plain unit tests. Such integration testing is an additional form of
      testing, not a substitute for unit testing.</p><p>The main dependency will typically be on a development database
      containing a complete schema used by the application. This may also
      contain test data, set up by a a tool such as a DBUnit, or an import
      using your database's tool set.</p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="springbeansdtd"></a>Appendix&nbsp;A.&nbsp;<tt class="literal">spring-beans.dtd</tt></h2></div></div><div></div></div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!--
	Spring XML Beans DTD
	Authors: Rod Johnson, Juergen Hoeller, Alef Arendsen, Colin Sampaleanu

	This defines a simple and consistent way of creating a namespace
	of JavaBeans objects, managed by a Spring BeanFactory, read by
	XmlBeanDefinitionReader (with DefaultXmlBeanDefinitionParser).

	This document type is used by most Spring functionality, including
	web application contexts, which are based on bean factories.

	Each "bean" element in this document defines a JavaBean.
	Typically the bean class is specified, along with JavaBean properties
	and/or constructor arguments.

	Bean instances can be "singletons" (shared instances) or "prototypes"
	(independent instances). Further scopes are supposed to be built on top
	of the core BeanFactory infrastructure and are therefore not part of it.

	References among beans are supported, i.e. setting a JavaBean property
	or a constructor argument to refer to another bean in the same factory
	(or an ancestor factory).

	As alternative to bean references, "inner bean definitions" can be used.
	Singleton flags of such inner bean definitions are effectively ignored:
	Inner beans are typically anonymous prototypes.

	There is also support for lists, sets, maps, and java.util.Properties
	as bean property types or constructor argument types.

	As the format is simple, a DTD is sufficient, and there's no need
	for a schema at this point.

	XML documents that conform to this DTD should declare the following doctype:

	&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"
		"http://www.springframework.org/dtd/spring-beans.dtd"&gt;
--&gt;


&lt;!--
	The document root. A document can contain bean definitions only,
	imports only, or a mixture of both (typically with imports first).
--&gt;
&lt;!ELEMENT beans (
	description?,
	(import | alias | bean)*
)&gt;

&lt;!--
	Default values for all bean definitions. Can be overridden at
	the "bean" level. See those attribute definitions for details.
--&gt;
&lt;!ATTLIST beans default-lazy-init (true | false) "false"&gt;
&lt;!ATTLIST beans default-dependency-check (none | objects | simple | all) "none"&gt;
&lt;!ATTLIST beans default-autowire (no | byName | byType | constructor | autodetect) "no"&gt;

&lt;!--
	Element containing informative text describing the purpose of the enclosing
	element. Always optional.
	Used primarily for user documentation of XML bean definition documents.
--&gt;
&lt;!ELEMENT description (#PCDATA)&gt;


&lt;!--
	Specifies an XML bean definition resource to import.
--&gt;
&lt;!ELEMENT import EMPTY&gt;

&lt;!--
	The relative resource location of the XML bean definition file to import,
	for example "myImport.xml" or "includes/myImport.xml" or "../myImport.xml".
--&gt;
&lt;!ATTLIST import resource CDATA #REQUIRED&gt;


&lt;!--
	Defines an alias for a bean, which can reside in a different definition file.
--&gt;
&lt;!ELEMENT alias EMPTY&gt;

&lt;!--
	The name of the bean to define an alias for.
--&gt;
&lt;!ATTLIST alias name CDATA #REQUIRED&gt;

&lt;!--
	The alias name to define for the bean.
--&gt;
&lt;!ATTLIST alias alias CDATA #REQUIRED&gt;


&lt;!--
	Defines a single (usually named) bean.

	A bean definition may contain nested tags for constructor arguments,
	property values, lookup methods, and replaced methods. Mixing constructor
	injection and setter injection on the same bean is explicitly supported.
--&gt;
&lt;!ELEMENT bean (
	description?,
	(constructor-arg | property | lookup-method | replaced-method)*
)&gt;

&lt;!--
	Beans can be identified by an id, to enable reference checking.

	There are constraints on a valid XML id: if you want to reference your bean
	in Java code using a name that's illegal as an XML id, use the optional
	"name" attribute. If neither is given, the bean class name is used as id
	(with an appended counter like "#2" if there is already a bean with that name).
--&gt;
&lt;!ATTLIST bean id ID #IMPLIED&gt;

&lt;!--
	Optional. Can be used to create one or more aliases illegal in an id.
	Multiple aliases can be separated by any number of spaces or commas.
--&gt;
&lt;!ATTLIST bean name CDATA #IMPLIED&gt;

&lt;!--
	Each bean definition must specify the fully qualified name of the class,
	except if it pure serves as parent for child bean definitions.
--&gt;
&lt;!ATTLIST bean class CDATA #IMPLIED&gt;

&lt;!--
	Optionally specify a parent bean definition.

	Will use the bean class of the parent if none specified, but can
	also override it. In the latter case, the child bean class must be
	compatible with the parent, i.e. accept the parent's property values
	and constructor argument values, if any.

	A child bean definition will inherit constructor argument values,
	property values and method overrides from the parent, with the option
	to add new values. If init method, destroy method, factory bean and/or factory
	method are specified, they will override the corresponding parent settings.

	The remaining settings will always be taken from the child definition:
	depends on, autowire mode, dependency check, singleton, lazy init.
--&gt;
&lt;!ATTLIST bean parent CDATA #IMPLIED&gt;

&lt;!--
	Is this bean "abstract", i.e. not meant to be instantiated itself but
	rather just serving as parent for concrete child bean definitions.
	Default is false. Specify true to tell the bean factory to not try to
	instantiate that particular bean in any case.
--&gt;
&lt;!ATTLIST bean abstract (true | false) "false"&gt;

&lt;!--
	Is this bean a "singleton" (one shared instance, which will
	be returned by all calls to getBean() with the id),
	or a "prototype" (independent instance resulting from each call to
	getBean(). Default is singleton.

	Singletons are most commonly used, and are ideal for multi-threaded
	service objects.
--&gt;
&lt;!ATTLIST bean singleton (true | false) "true"&gt;

&lt;!--
	If this bean should be lazily initialized.
	If false, it will get instantiated on startup by bean factories
	that perform eager initialization of singletons.
--&gt;
&lt;!ATTLIST bean lazy-init (true | false | default) "default"&gt;

&lt;!--
	Optional attribute controlling whether to "autowire" bean properties.
	This is an automagical process in which bean references don't need to be coded
	explicitly in the XML bean definition file, but Spring works out dependencies.

	There are 5 modes:

	1. "no"
	The traditional Spring default. No automagical wiring. Bean references
	must be defined in the XML file via the &lt;ref&gt; element. We recommend this
	in most cases as it makes documentation more explicit.

	2. "byName"
	Autowiring by property name. If a bean of class Cat exposes a dog property,
	Spring will try to set this to the value of the bean "dog" in the current factory.
	If there is no matching bean by name, nothing special happens;
	use dependency-check="objects" to raise an error in that case.

	3. "byType"
	Autowiring if there is exactly one bean of the property type in the bean factory.
	If there is more than one, a fatal error is raised, and you can't use byType
	autowiring for that bean. If there is none, nothing special happens;
	use dependency-check="objects" to raise an error in that case.

	4. "constructor"
	Analogous to "byType" for constructor arguments. If there isn't exactly one bean
	of the constructor argument type in the bean factory, a fatal error is raised.

	5. "autodetect"
	Chooses "constructor" or "byType" through introspection of the bean class.
	If a default constructor is found, "byType" gets applied.

	The latter two are similar to PicoContainer and make bean factories simple to
	configure for small namespaces, but doesn't work as well as standard Spring
	behaviour for bigger applications.

	Note that explicit dependencies, i.e. "property" and "constructor-arg" elements,
	always override autowiring. Autowire behaviour can be combined with dependency
	checking, which will be performed after all autowiring has been completed.
--&gt;
&lt;!ATTLIST bean autowire (no | byName | byType | constructor | autodetect | default) "default"&gt;

&lt;!--
	Optional attribute controlling whether to check whether all this
	beans dependencies, expressed in its properties, are satisfied.
	Default is no dependency checking.

	"simple" type dependency checking includes primitives and String
	"object" includes collaborators (other beans in the factory)
	"all" includes both types of dependency checking
--&gt;
&lt;!ATTLIST bean dependency-check (none | objects | simple | all | default) "default"&gt;

&lt;!--
	The names of the beans that this bean depends on being initialized.
	The bean factory will guarantee that these beans get initialized before.

	Note that dependencies are normally expressed through bean properties or
	constructor arguments. This property should just be necessary for other kinds
	of dependencies like statics (*ugh*) or database preparation on startup.
--&gt;
&lt;!ATTLIST bean depends-on CDATA #IMPLIED&gt;

&lt;!--
	Optional attribute for the name of the custom initialization method
	to invoke after setting bean properties. The method must have no arguments,
	but may throw any exception.
--&gt;
&lt;!ATTLIST bean init-method CDATA #IMPLIED&gt;

&lt;!--
	Optional attribute for the name of the custom destroy method to invoke
	on bean factory shutdown. The method must have no arguments,
	but may throw any exception. Note: Only invoked on singleton beans!
--&gt;
&lt;!ATTLIST bean destroy-method CDATA #IMPLIED&gt;

&lt;!--
	Optional attribute specifying the name of a factory method to use to
	create this object. Use constructor-arg elements to specify arguments
	to the factory method, if it takes arguments. Autowiring does not apply
	to factory methods.

	If the "class" attribute is present, the factory method will be a static
	method on the class specified by the "class" attribute on this bean
	definition. Often this will be the same class as that of the constructed
	object - for example, when the factory method is used as an alternative
	to a constructor. However, it may be on a different class. In that case,
	the created object will *not* be of the class specified in the "class"
	attribute. This is analogous to FactoryBean behavior.

	If the "factory-bean" attribute is present, the "class" attribute is not
	used, and the factory method will be an instance method on the object
	returned from a getBean call with the specified bean name. The factory
	bean may be defined as a singleton or a prototype.

	The factory method can have any number of arguments. Autowiring is not
	supported. Use indexed constructor-arg elements in conjunction with the
	factory-method attribute.

	Setter Injection can be used in conjunction with a factory method.
	Method Injection cannot, as the factory method returns an instance,
	which will be used when the container creates the bean.
--&gt;
&lt;!ATTLIST bean factory-method CDATA #IMPLIED&gt;

&lt;!--
	Alternative to class attribute for factory-method usage.
	If this is specified, no class attribute should be used.
	This should be set to the name of a bean in the current or
	ancestor factories that contains the relevant factory method.
	This allows the factory itself to be configured using Dependency
	Injection, and an instance (rather than static) method to be used.
--&gt;
&lt;!ATTLIST bean factory-bean CDATA #IMPLIED&gt;


&lt;!--
	Bean definitions can specify zero or more constructor arguments.
	This is an alternative to "autowire constructor".
	Arguments correspond to either a specific index of the constructor argument
	list or are supposed to be matched generically by type.

	Note: A single generic argument value will just be used once, rather than
	potentially matched multiple times (as of Spring 1.1).

	constructor-arg elements are also used in conjunction with the factory-method
	element to construct beans using static or instance factory methods.
--&gt;
&lt;!ELEMENT constructor-arg (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)&gt;

&lt;!--
	The constructor-arg tag can have an optional index attribute,
	to specify the exact index in the constructor argument list. Only needed
	to avoid ambiguities, e.g. in case of 2 arguments of the same type.
--&gt;
&lt;!ATTLIST constructor-arg index CDATA #IMPLIED&gt;

&lt;!--
	The constructor-arg tag can have an optional type attribute,
	to specify the exact type of the constructor argument. Only needed
	to avoid ambiguities, e.g. in case of 2 single argument constructors
	that can both be converted from a String.
--&gt;
&lt;!ATTLIST constructor-arg type CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "ref bean=".
--&gt;
&lt;!ATTLIST constructor-arg ref CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "value".
--&gt;
&lt;!ATTLIST constructor-arg value CDATA #IMPLIED&gt;


&lt;!--
	Bean definitions can have zero or more properties.
	Property elements correspond to JavaBean setter methods exposed
	by the bean classes. Spring supports primitives, references to other
	beans in the same or related factories, lists, maps and properties.
--&gt;
&lt;!ELEMENT property (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)&gt;

&lt;!--
	The property name attribute is the name of the JavaBean property.
	This follows JavaBean conventions: a name of "age" would correspond
	to setAge()/optional getAge() methods.
--&gt;
&lt;!ATTLIST property name CDATA #REQUIRED&gt;

&lt;!--
  A short-cut alternative to a child element "ref bean=".
--&gt;
&lt;!ATTLIST property ref CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "value".
--&gt;
&lt;!ATTLIST property value CDATA #IMPLIED&gt;


&lt;!--
	A lookup method causes the IoC container to override the given method and return
	the bean with the name given in the bean attribute. This is a form of Method Injection.
	It's particularly useful as an alternative to implementing the BeanFactoryAware
	interface, in order to be able to make getBean() calls for non-singleton instances
	at runtime. In this case, Method Injection is a less invasive alternative.
--&gt;
&lt;!ELEMENT lookup-method EMPTY&gt;

&lt;!--
	Name of a lookup method. This method should take no arguments.
--&gt;
&lt;!ATTLIST lookup-method name CDATA #IMPLIED&gt;

&lt;!--
	Name of the bean in the current or ancestor factories that the lookup method
	should resolve to. Often this bean will be a prototype, in which case the
	lookup method will return a distinct instance on every invocation. This
	is useful for single-threaded objects.
--&gt;
&lt;!ATTLIST lookup-method bean CDATA #IMPLIED&gt;


&lt;!--
	Similar to the lookup method mechanism, the replaced-method element is used to control
	IoC container method overriding: Method Injection. This mechanism allows the overriding
	of a method with arbitrary code.
--&gt;
&lt;!ELEMENT replaced-method (
	(arg-type)*
)&gt;

&lt;!--
	Name of the method whose implementation should be replaced by the IoC container.
	If this method is not overloaded, there's no need to use arg-type subelements.
	If this method is overloaded, arg-type subelements must be used for all
	override definitions for the method.
--&gt;
&lt;!ATTLIST replaced-method name CDATA #IMPLIED&gt;

&lt;!--
	Bean name of an implementation of the MethodReplacer interface
	in the current or ancestor factories. This may be a singleton or prototype
	bean. If it's a prototype, a new instance will be used for each method replacement.
	Singleton usage is the norm.
--&gt;
&lt;!ATTLIST replaced-method replacer CDATA #IMPLIED&gt;

&lt;!--
	Subelement of replaced-method identifying an argument for a replaced method
	in the event of method overloading.
--&gt;
&lt;!ELEMENT arg-type (#PCDATA)&gt;

&lt;!--
	Specification of the type of an overloaded method argument as a String.
	For convenience, this may be a substring of the FQN. E.g. all the
	following would match "java.lang.String":
	- java.lang.String
	- String
	- Str

	As the number of arguments will be checked also, this convenience can often
	be used to save typing.
--&gt;
&lt;!ATTLIST arg-type match CDATA #IMPLIED&gt;


&lt;!--
	Defines a reference to another bean in this factory or an external
	factory (parent or included factory).
--&gt;
&lt;!ELEMENT ref EMPTY&gt;

&lt;!--
	References must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	to be checked at runtime.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
--&gt;
&lt;!ATTLIST ref bean CDATA #IMPLIED&gt;
&lt;!ATTLIST ref local IDREF #IMPLIED&gt;
&lt;!ATTLIST ref parent CDATA #IMPLIED&gt;


&lt;!--
	Defines a string property value, which must also be the id of another
	bean in this factory or an external factory (parent or included factory).
	While a regular 'value' element could instead be used for the same effect,
	using idref in this case allows validation of local bean ids by the xml
	parser, and name completion by helper tools.
--&gt;
&lt;!ELEMENT idref EMPTY&gt;

&lt;!--
	ID refs must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	potentially to be checked at runtime by bean factory implementations.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
--&gt;
&lt;!ATTLIST idref bean CDATA #IMPLIED&gt;
&lt;!ATTLIST idref local IDREF #IMPLIED&gt;


&lt;!--
	Contains a string representation of a property value.
	The property may be a string, or may be converted to the
	required type using the JavaBeans PropertyEditor
	machinery. This makes it possible for application developers
	to write custom PropertyEditor implementations that can
	convert strings to objects.

	Note that this is recommended for simple objects only.
	Configure more complex objects by populating JavaBean
	properties with references to other beans.
--&gt;
&lt;!ELEMENT value (#PCDATA)&gt;

&lt;!--
	The value tag can have an optional type attribute, to specify the
	exact type that the value should be converted to. Only needed
	if the type of the target property or constructor argument is
	too generic: for example, in case of a collection element.
--&gt;
&lt;!ATTLIST value type CDATA #IMPLIED&gt;

&lt;!--
	Denotes a Java null value. Necessary because an empty "value" tag
	will resolve to an empty String, which will not be resolved to a
	null value unless a special PropertyEditor does so.
--&gt;
&lt;!ELEMENT null (#PCDATA)&gt;


&lt;!--
	A list can contain multiple inner bean, ref, collection, or value elements.
	Java lists are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
	A list can also map to an array type. The necessary conversion
	is automatically performed by the BeanFactory.
--&gt;
&lt;!ELEMENT list (
	(bean | ref | idref | value | null | list | set | map | props)*
)&gt;

&lt;!--
	A set can contain multiple inner bean, ref, collection, or value elements.
	Java sets are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
--&gt;
&lt;!ELEMENT set (
	(bean | ref | idref | value | null | list | set | map | props)*
)&gt;


&lt;!--
	A Spring map is a mapping from a string key to object.
	Maps may be empty.
--&gt;
&lt;!ELEMENT map (
	(entry)*
)&gt;

&lt;!--
	A map entry can be an inner bean, ref, value, or collection.
	The key of the entry is given by the "key" attribute or child element.
--&gt;
&lt;!ELEMENT entry (
  key?,
	(bean | ref | idref | value | null | list | set | map | props)?
)&gt;

&lt;!--
	Each map element must specify its key as attribute or as child element.
	A key attribute is always a String value.
--&gt;
&lt;!ATTLIST entry key CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a "key" element with a "ref bean=" child element.
--&gt;
&lt;!ATTLIST entry key-ref CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "value".
--&gt;
&lt;!ATTLIST entry value CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "ref bean=".
--&gt;
&lt;!ATTLIST entry value-ref CDATA #IMPLIED&gt;

&lt;!--
	A key element can contain an inner bean, ref, value, or collection.
--&gt;
&lt;!ELEMENT key (
	(bean | ref | idref | value | null | list | set | map | props)
)&gt;


&lt;!--
	Props elements differ from map elements in that values must be strings.
	Props may be empty.
--&gt;
&lt;!ELEMENT props (
	(prop)*
)&gt;

&lt;!--
	Element content is the string value of the property.
	Note that whitespace is trimmed off to avoid unwanted whitespace
	caused by typical XML formatting.
--&gt;
&lt;!ELEMENT prop (#PCDATA)&gt;

&lt;!--
	Each property element must specify its key.
--&gt;
&lt;!ATTLIST prop key CDATA #REQUIRED&gt;
</pre></div></div></body></html>